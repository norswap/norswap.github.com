<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>norswap</title>
    <description></description>      
    <link>http://norswap.com/</link>
    <atom:link href="http://norswap.com/atom.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>The Expression Problem in Java (Litterature Review)</title>
      <description>
&lt;link href=&quot;https://cdnjs.cloudflare.com/ajax/libs/prism/1.16.0/themes/prism.css&quot; rel=&quot;stylesheet&quot; /&gt;

&lt;!-- &lt;link href=&quot;https://cdnjs.cloudflare.com/ajax/libs/prism/1.16.0/themes/prism-tomorrow.min.css&quot; rel=&quot;stylesheet&quot; /&gt; --&gt;

&lt;p&gt;Previously: &lt;a href=&quot;/java-visitor-pattern&quot;&gt;The Visitor Pattern in Java 8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/java-visitor-pattern&quot;&gt;Last time&lt;/a&gt; I presented a way to implement the visitor pattern, by
taking advantage of Java 8&amp;#39;s &lt;code&gt;default&lt;/code&gt; interface methods.&lt;/p&gt;
&lt;p&gt;In the process I said this was a partial solution to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Expression_problem&quot;&gt;expression problem&lt;/a&gt;,
which was defined as:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The goal is to define a datatype by cases, where one can add new cases to the
datatype and new functions over the datatype, without recompiling existing
code, and while retaining static type safety (e.g., no casts).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Recall that in the context of Java, we can think of a &lt;em&gt;datatype&lt;/em&gt; as an interface
or parent class, and of a &lt;em&gt;case&lt;/em&gt; as a class implementing/extending the interface
or parent. When using this interpretation we will call the &lt;em&gt;cases&lt;/em&gt; &amp;quot;&lt;em&gt;data
classes&lt;/em&gt;&amp;quot;, which is a bit less awkward.&lt;/p&gt;
&lt;p&gt;On the other hand, some of the papers we will review will take another
interpretation in order to produce an interesting solution.&lt;/p&gt;
&lt;p&gt;The solution I presented last time is partial, because it is not strictly
type-safe: it uses a cast.&lt;/p&gt;
&lt;p&gt;Today, I want to look at the solutions that have been proposed in the
litterature, and try to extract their guiding insights, and show their
respective strengths and shortcomings.&lt;/p&gt;
&lt;h2 id=&quot;the-contenders&quot;&gt;The Contenders&lt;/h2&gt;
&lt;p&gt;While the litterature on the expression problem in Java-like object-oriented
languages is surprisingly rich, I want to focus specifically on three papers
which I think covers the space of interesting solutions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;The Expression Problem Revisited: Four new solutions using generics&lt;/strong&gt;, Mads
Torgersen, &lt;em&gt;ECOOP 2004&lt;/em&gt; &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.85.2323&quot;&gt;[link with pdf]&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Extensibility for the Masses: Practical Extensibility with Object
Algebras&lt;/strong&gt;, Bruno C. d. S. Oliveira &amp;amp; William R. Cook, &lt;em&gt;ECOOP 2012&lt;/em&gt; &lt;a href=&quot;https://i.cs.hku.hk/~bruno/oa/&quot;&gt;[link with pdf]&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;The expression problem, trivially!&lt;/strong&gt;, Yanlin Wang &amp;amp; Bruno C. d. S. Oliveira,
&lt;em&gt;Modularity 2016&lt;/em&gt;, &lt;a href=&quot;https://i.cs.hku.hk/~bruno/papers/Modularity2016.pdf&quot;&gt;[pdf]&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since the first paper actually presents four solutions, that gives us 6
solutions to review. I&amp;#39;ll also throw my partial solution into the mix for
comparison&amp;#39;s sake.&lt;/p&gt;
&lt;h2 id=&quot;the-problems-raison-dêtre-ambiguous-call-sites&quot;&gt;The Problem&amp;#39;s Raison d&amp;#39;Être: Ambiguous Call Sites&lt;/h2&gt;
&lt;p&gt;For the expression problem to be interesting &lt;em&gt;at all&lt;/em&gt;, it has to involve
ambiguous call sites: the same piece of code has to perform a method call which
could be dispatched to a specialized method for any of datatype cases.&lt;/p&gt;
&lt;p&gt;Said otherwise, if every piece of code is statically typed and doesn&amp;#39;t involve
any kind of &lt;a href=&quot;/polymorphism/&quot;&gt;polymorphism&lt;/a&gt; (e.g. inheritance or generics), then plain static
overloading is enough, and you don&amp;#39;t have a &lt;em&gt;problem&lt;/em&gt; in the first place.&lt;/p&gt;
&lt;p&gt;Therefore, to build a type-safe solution to the expression problem, two big
avenues are open.&lt;/p&gt;
&lt;p&gt;The first one has to be built into the compiler: the compiler will check that
implementations of operations (which can be added by anyone, not just the
original author of the datatype) exist for every data class. But this doesn&amp;#39;t
seem to exist. I said as much in &lt;a href=&quot;/java-visitor-pattern&quot;&gt;the previous post&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In theory, there is nothing that prevents solving the expression problem at
the language level. In an ideal world, we&amp;#39;d just be able to add abstract
extension methods that have to be implemented for all classes implementing the
interface. The linker would then verify that these methods were implemented
for all such classes, and generate the proper virtual method tables. But no
such object-oriented language exists.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The second avenue is to somehow &lt;em&gt;carry&lt;/em&gt; the specialized implementation to the
call sites. This is what every solution in the litterature does, each in its own
way.&lt;/p&gt;
&lt;p&gt;That is also how &lt;a href=&quot;https://en.wikipedia.org/wiki/Type_class&quot;&gt;typeclasses&lt;/a&gt; work in Haskell. In this case, it&amp;#39;s the typeclass
instances that carry the operation&amp;#39;s implementation to the call site.&lt;/p&gt;
&lt;p&gt;In light of this, the statement of the expression problem is somewhat
problematic, because it doesn&amp;#39;t specify which shape the ambiguous call sites can
take.&lt;/p&gt;
&lt;p&gt;But I can think of two very interesting examples.&lt;/p&gt;
&lt;p&gt;The first one is to apply one of the specialized methods on a list of data class
instances, &lt;em&gt;whose exact type is not known&lt;/em&gt; (said otherwise, which just know they
are instances of the datatype).&lt;/p&gt;
&lt;p&gt;Sadly, no type-safe solution in the litterature can do that. Our solution can,
but again, it isn&amp;#39;t type safe.&lt;/p&gt;
&lt;p&gt;Interestingly, Haskell can do this only if using a compiler extension
introducing &lt;a href=&quot;https://wiki.haskell.org/Existential_type&quot;&gt;existential types&lt;/a&gt;. An existential type is basically just a pair of
a type and its associated typeclass instance for a given typeclass. The
existential type just says &amp;quot;here is an instance of &lt;em&gt;something&lt;/em&gt; that has an
instance for the given typeclass&amp;quot;. Then you have to use a list of
existentially-typed values — which crucially you mean you can&amp;#39;t reuse a
pre-existing list that isn&amp;#39;t existentially-typed. There has to be a way to
(statically) retrieve the correct typeclass instance when constructing the list.&lt;/p&gt;
&lt;p&gt;The second example is, fortunately, the one that is always used as a benchmark
in the litterature: a tree structure where each node is a data class instance.&lt;/p&gt;
&lt;p&gt;This example is easier because it is possible to inject type information while
building the tree — something that is not possible with plain lists, but is
exactly what we&amp;#39;re doing when we&amp;#39;re building an existentially-typed list.&lt;/p&gt;
&lt;h2 id=&quot;the-benchmark-problem&quot;&gt;The Benchmark Problem&lt;/h2&gt;
&lt;p&gt;In particular, the typical example uses trees that represent arithmetic
expressions.&lt;/p&gt;
&lt;p&gt;This benchmark example was there since the beginning, and is certainly partially
responsible for the name of the &lt;em&gt;expression&lt;/em&gt; problem.&lt;/p&gt;
&lt;p&gt;Our datatype is an &lt;code&gt;Exp&lt;/code&gt; type.&lt;/p&gt;
&lt;p&gt;The cases for the datatype are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Lit&lt;/code&gt;: an integer literal&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Add&lt;/code&gt;: addition of two expression&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Neg&lt;/code&gt;: negation of an expression — which is added as an extension&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Initially, we&amp;#39;ll have a single operation: &lt;code&gt;Print&lt;/code&gt; which prints a string
representation of the expression to standard output. Later we&amp;#39;ll add &lt;code&gt;Eval&lt;/code&gt;,
which evaluates the expression.&lt;/p&gt;
&lt;h2 id=&quot;norswaps-solution&quot;&gt;Norswap&amp;#39;s Solution&lt;/h2&gt;
&lt;p&gt;To ease us into the problem, let&amp;#39;s see a type-unsafe solution to the problem
using my formulation of the &lt;a href=&quot;/java-visitor-pattern&quot;&gt;visitor pattern&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://gist.github.com/norswap/9d4dd9ae5c0fd2ef652a1f41778467ea#file-norswapep-java&quot;&gt;Norswap&amp;#39;s Solution Code&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Compared to the previous post, the solution has been simplified/crippled a
little bit for the sake of brevity and better comparison. We no longer use
&lt;em&gt;implementation interfaces&lt;/em&gt;, which allow the composition of independently
developped extensions (i.e. new data classes or operations).&lt;/p&gt;
&lt;p&gt;None of Torgersen&amp;#39;s solutions can handle composition. This is excusable, as our
trick (using &lt;code&gt;default&lt;/code&gt; methods in interfaces) wasn&amp;#39;t available at the time the
paper was written.&lt;/p&gt;
&lt;h2 id=&quot;the-choice-for-data-structure-solutions&quot;&gt;The Choice for Data-Structure Solutions&lt;/h2&gt;
&lt;p&gt;The nature of the expression problem is that each time we add a new data class,
we need to add corresponding implementations for the existing operations.
Conversely, each time we add a new operation, we need to implement it for all
existing data classes.&lt;/p&gt;
&lt;p&gt;Unfortunately, it&amp;#39;s not as simple as just writing them. The &amp;quot;compiler&amp;quot; solution
that neatly composes everything for us isn&amp;#39;t available. Therefore, we will have
to take care of the plumbing ourselves.&lt;/p&gt;
&lt;p&gt;As long as we keep one dimension fixed, everything is easy. If we have a fixed
set of operations, they can be encoded as an interface which we can just
implement. If we have a fixed set of data classes, the simple visitor pattern
suffices, and we can just implement the visitor interface to add new operations.&lt;/p&gt;
&lt;p&gt;Things become tricky when we need to add both new operations and new data
classes.&lt;/p&gt;
&lt;p&gt;There are fundamentally two ways to do this.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Option 1&lt;/strong&gt;: replacing the data classes. Each time we add a new operation, we
need to extend all data classes so that they may handle the new operation.
Operation&amp;#39;s implementation will live inside the data classes.&lt;/p&gt;
&lt;p&gt;This option means we need to control/parameterize the creation of our data
structure. Whenever we add a new operation, we need to swap the classes that are
being instantiated!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Option 2&lt;/strong&gt;: replacing the operations. Each time we add a new data class, we
need to extend all existing operations so that they may handle the new data
class. Operation&amp;#39;s implementation will typically live in some kind of visitor
implementation.&lt;/p&gt;
&lt;p&gt;This options means we need to control/parameterized the operation&amp;#39;s call sites.
Whenever we add a new data class, we need to swap the object that holds the
operation&amp;#39;s implementations, lest it doesn&amp;#39;t work for the new data class.&lt;/p&gt;
&lt;p&gt;My solution uses option 2.&lt;/p&gt;
&lt;h2 id=&quot;torgersens-1st-solution-data-centered&quot;&gt;Torgersen&amp;#39;s 1st Solution: Data-Centered&lt;/h2&gt;
&lt;p&gt;This is the first solution in the &amp;quot;&lt;em&gt;The Expression Problem Revisited: Four new
solutions using generics&lt;/em&gt;&amp;quot; (&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.85.2323&quot;&gt;link&lt;/a&gt;) paper by Mads Torgersen. Discussion of
the other three solutions will follow.&lt;/p&gt;
&lt;p&gt;This is a solution that takes &lt;em&gt;option 1&lt;/em&gt; from the last section: replacing the
data classes. When adding a new operation, we subclass all existing data
classes. The code that create data strutures needs to be parameterized.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://gist.github.com/norswap/9d4dd9ae5c0fd2ef652a1f41778467ea#file-torgersendataep-java&quot;&gt;Torgersen&amp;#39;s Data-Centered Solution Code&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are two difficulties in this solution that not readily apparent when
&lt;em&gt;option 1&lt;/em&gt; is stated briefly.&lt;/p&gt;
&lt;p&gt;First, in order to make the solution type-safe, it is necessary to know which
operations the nodes in the expression tree implement. This means there needs to
be someway to &amp;quot;carry the type&amp;quot; to the nodes that are down in the tree. &lt;/p&gt;
&lt;p&gt;In this solution, this is done via generics, and in particular the use of a
F-bound: &lt;code&gt;C extends Exp&amp;lt;C&amp;gt;&lt;/code&gt;. F-bounds are a crude way to encode &amp;quot;self-types&amp;quot; in
Java. Basically it lets us use &lt;code&gt;C&lt;/code&gt; as though it meant &amp;quot;the type of this class&amp;quot;
(or, like here, the type of one of its superclasses or superinterfaces).
However, to use an F-bound, you need to &amp;quot;fix&amp;quot; &lt;code&gt;C&lt;/code&gt;. This is the role of all the
classes whose name end with &lt;code&gt;F&lt;/code&gt;, such as &lt;code&gt;class LitF extends Lit&amp;lt;ExpF&amp;gt;
implements ExpF&lt;/code&gt;. Unfortunately, that makes the solution more verbose as we need
to actually add in all of these &lt;code&gt;F&lt;/code&gt; classes.&lt;/p&gt;
&lt;p&gt;The second difficulty — which is only hinted at in the paper — is the need to
carry the node creation logic to the places where you would normally call a data
class constructor. Since there may be a lot of different types of nodes, it
makes sense to collect the creators in a factory.&lt;/p&gt;
&lt;p&gt;The issue with that is that each time you add a new data case you need to extend
the existing factory. Each time you add a new operation, you not only need to
extend every data class, but also to create a whole new factory that return
instances of these new classes.&lt;/p&gt;
&lt;p&gt;So this works, but it&amp;#39;s quite verbose and it&amp;#39;s relatively annoying that we
actually need to change the data classes being used when we add new operations.&lt;/p&gt;
&lt;h2 id=&quot;torgersens-2nd-solution-operation-centered&quot;&gt;Torgersen&amp;#39;s 2nd Solution: Operation-Centered&lt;/h2&gt;
&lt;p&gt;This solution takes &lt;em&gt;option 2&lt;/em&gt; outlined above. Each time we add a new data
class, we need to extend all existing operations so that they may handle the new
data class. Operation&amp;#39;s implementation live in a visitor implementation.&lt;/p&gt;
&lt;p&gt;This is also what my own solution does, I will explain the difference below.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://gist.github.com/norswap/9d4dd9ae5c0fd2ef652a1f41778467ea#file-torgersenoperationep-java&quot;&gt;Torgersen&amp;#39;s Operation-Centered Solution Code&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;However, there is a big pitfall that comes from the need to be type-safe. For
the initial data classes, there are no issues. But when a new data class is
added, it is necessary to add a new visitor interface. This is as expected.&lt;/p&gt;
&lt;p&gt;However, each data class instance has to know the requirements on the visitors
it can handle. To use our previous examples, a &lt;code&gt;Neg&lt;/code&gt; node can only handle
visitors that implement &lt;code&gt;NegVisitor&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But it doesn&amp;#39;t stop there. If an &lt;code&gt;Add&lt;/code&gt; node has a &lt;code&gt;Neg&lt;/code&gt; child, it too should
only accept visitors that implement &lt;code&gt;NegVisitor&lt;/code&gt; — since they can invoke the
visitor on their children.&lt;/p&gt;
&lt;p&gt;Again, generics come to the rescue: we parameterize all data classes with &lt;code&gt;&amp;lt;V
extends Visitor&amp;gt;&lt;/code&gt; (for the initial data classes) or &lt;code&gt;&amp;lt;V extends NegVisitor&amp;gt;&lt;/code&gt;
(for &lt;code&gt;Neg&lt;/code&gt; — same principle would apply if we added new data classes).&lt;/p&gt;
&lt;p&gt;This doesn&amp;#39;t entirely fix the problem. In the &lt;code&gt;visit&lt;/code&gt; methods, it wouldnt work
to call, for instance, &lt;code&gt;add.left.accept(this)&lt;/code&gt;. Why? Because there is no
guarantee that &lt;code&gt;this&lt;/code&gt; has type &lt;code&gt;V&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Torgersen comes up with a really neat trick to solve this issue, which is to let
the visitor accept itself as an extra parameter of type &lt;code&gt;V&lt;/code&gt;. This parameter will
be supplied by the &lt;code&gt;accept&lt;/code&gt; methods: &lt;code&gt;visitor.visit(visitor, this)&lt;/code&gt; (where
&lt;code&gt;this&lt;/code&gt; is a an instance of a data class such as &lt;code&gt;Add&amp;lt;V&amp;gt;&lt;/code&gt;). Since &lt;code&gt;visitor&lt;/code&gt; has
type &lt;code&gt;V&lt;/code&gt; there, this type-checks ok.&lt;/p&gt;
&lt;p&gt;The cost? Once again, we can&amp;#39;t reuse our expression trees. They now have to be
parameterized differently depending on added data classes. So creation logic has
to be parameterized by the proper visitor interface (note you can&amp;#39;t really see
this is our simplistic demo code). At least, we don&amp;#39;t need verbose factories
this time.&lt;/p&gt;
&lt;h2 id=&quot;torgersens-3rd-solution-operation-centered-with-object-level-extensibility&quot;&gt;Torgersen&amp;#39;s 3rd Solution: Operation-Centered with Object-Level Extensibility&lt;/h2&gt;
&lt;p&gt;This solution is an extension of the second solution. The goal is to relax the
requirement on the control of all instantiation sites.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://gist.github.com/norswap/9d4dd9ae5c0fd2ef652a1f41778467ea#file-torgersenoperationep-java&quot;&gt;Torgersen&amp;#39;s Operation-Centered with Object-Level Extensibility Solution Code&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;From the perspective of the previous solution, the goal here is to make it
possible to reuse old &lt;code&gt;Add&amp;lt;Visitor&amp;gt;&lt;/code&gt; and &lt;code&gt;Lit&amp;lt;Visitor&amp;gt;&lt;/code&gt; trees that were
instantiated without knowing that &lt;code&gt;Neg&lt;/code&gt; existed. These node will still work if
passed a &lt;code&gt;NegVisitor&lt;/code&gt; (which extends &lt;code&gt;Visitor&lt;/code&gt;)!&lt;/p&gt;
&lt;p&gt;The author calls this ability to reuse old trees &lt;em&gt;object-level extensibility&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;And since the old trees were created before we added &lt;code&gt;Neg&lt;/code&gt;, they couldn&amp;#39;t
contain &lt;code&gt;Neg&lt;/code&gt; nodes, and so using plain &lt;code&gt;Visitor&lt;/code&gt; implementations is fine as
well.&lt;/p&gt;
&lt;p&gt;Achieving object-level extensibility is actually pretty easy. In the data
classes, just change the node&amp;#39;s children type to &lt;code&gt;Exp&amp;lt;? super V&amp;gt;&lt;/code&gt;. Without
entering into the details, this means that &lt;code&gt;Add&amp;lt;NegVisitor&amp;gt;&lt;/code&gt; may have children
that with type &lt;code&gt;Exp&amp;lt;Visitor&amp;gt;&lt;/code&gt; or &lt;code&gt;Exp&amp;lt;NegVisitor&amp;gt;&lt;/code&gt;. On the other hand
&lt;code&gt;Add&amp;lt;Visitor&amp;gt;&lt;/code&gt; may not have a child of type &lt;code&gt;Exp&amp;lt;NegVisitor&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This effectively enables reusing old trees in newer trees. &lt;/p&gt;
&lt;p&gt;There is only one catch: your ability to rewrite the trees becomes limited.
Since &lt;code&gt;Add&amp;lt;Visitor&amp;gt;&lt;/code&gt; may not have children of type &lt;code&gt;Exp&amp;lt;NegVisitor&amp;gt;&lt;/code&gt; this may
hamper your ability to write involved tree rewrite logic that would need to
assign a newer tree as a child of an older tree.&lt;/p&gt;
&lt;p&gt;However, as the author correctly notes, there are plenty of use-cases (maybe
even most of them) that do not involve such kind of tree rewriting.&lt;/p&gt;
&lt;p&gt;If type-safety is a must-have for you and you don&amp;#39;t need tree rewrites, this is
pretty good. You&amp;#39;ll still pay a cost of sorts by having to carry these annoyings
type parameters everywhere.&lt;/p&gt;
&lt;h2 id=&quot;torgersens-4th-solution-type-unsafe-hybrid&quot;&gt;Torgersen&amp;#39;s 4th Solution: Type-Unsafe Hybrid&lt;/h2&gt;
&lt;p&gt;This one is interesting too.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://gist.github.com/norswap/9d4dd9ae5c0fd2ef652a1f41778467ea#file-torgersenhybridep-java&quot;&gt;Torgersen&amp;#39;s Hybrid Solution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gist.github.com/norswap/9d4dd9ae5c0fd2ef652a1f41778467ea#file-torgersenbetterhybridep-java&quot;&gt;Torgersen&amp;#39;s Hybrid Solution, Without Generics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Torgersen starts from the an operation-centered visitor solution (much like his
second solution) but pairs each operation (i.e. visitor implementation) with an
interface that defines the signature of the operation. Data classes can choose
to implement this interface. If they do so, the operation will notice (via an
&lt;code&gt;instanceof&lt;/code&gt; check) and call the implementation — otherwise it falls back on the
visitor pattern.&lt;/p&gt;
&lt;p&gt;The solution isn&amp;#39;t type-safe because Torgersen opts not to force the children of
each data class node to encode their visitor interface. So instead of being
typed as &lt;code&gt;Exp&amp;lt;V&amp;gt;&lt;/code&gt; or &lt;code&gt;Exp&amp;lt;? extends V&amp;gt;&lt;/code&gt; as in solution 2 and 3 respectively,
they are simply typed as &lt;code&gt;Exp&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The payload of foregoing type-safety here is that control over the creation
logic is no longer necessary. You can finally have data classes whose types and
implementations don&amp;#39;t change depending on subsequent extensions. In that, it is
similar to my solution.&lt;/p&gt;
&lt;p&gt;If you know in advance all operations you need to implement, you can also avoid
extending existing operations when you introduce a new data class, by having the
data class implement the operations&amp;#39; associated interfaces.&lt;/p&gt;
&lt;p&gt;Because the lack of type safety, when an expression accepts a visitor, it must
verify that this visitor actually can handle the expression&amp;#39;s data class or fall
back on some general behaviour (at worse, throw a runtime exception, which is
what my solution does).&lt;/p&gt;
&lt;p&gt;To make all of this work, the solution involves some helper super-classes, which
can be slightly confusing.&lt;/p&gt;
&lt;p&gt;I&amp;#39;d also argue that the most use of generics in this solution is woefully
unecessary — it just saves on inlining two lines of logic into every visitor,
which you sort of have to do &lt;em&gt;anyway&lt;/em&gt; because Java doesn&amp;#39;t support &lt;code&gt;instanceof&lt;/code&gt;
on generic type arguments (which are &lt;a href=&quot;https://www.baeldung.com/java-type-erasure&quot;&gt;erased&lt;/a&gt;). Hence I made a &lt;a href=&quot;https://gist.github.com/norswap/9d4dd9ae5c0fd2ef652a1f41778467ea#file-torgersenbetterhybridep-java&quot;&gt;simplified
solution&lt;/a&gt; that eliminates non-essential generics use, and
simplifies the scaffolding considerably, making it &lt;strong&gt;much&lt;/strong&gt; easier to
understand, in my humble opinion.&lt;/p&gt;
&lt;p&gt;Compared to my solution, this one is more complicated, but has the important
benefit that data classes can be added without extending all operations
individually, greatly reducing verbosity in that scenario.&lt;/p&gt;
&lt;h2 id=&quot;object-algebras&quot;&gt;Object Algebras&lt;/h2&gt;
&lt;p&gt;We now discussion the solution from the &amp;quot;Extensibility for the Masses: Practical
Extensibility with Object Algebras&amp;quot; paper (&lt;a href=&quot;https://i.cs.hku.hk/~bruno/oa/&quot;&gt;link&lt;/a&gt;). This one is quite
different from those we discussed previously, and conforms to neither of our two
options — because it doesn&amp;#39;t encode data as a data structure at all!&lt;/p&gt;
&lt;p&gt;Instead, data is encoded as a tree of method calls. Here is an example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;interface Algebra&amp;lt;E&amp;gt; {
    E lit (int value);
    E add (E left, E right);
}

public static &amp;lt;E&amp;gt; E expression (Algebra&amp;lt;E&amp;gt; a) {
    return a.add(a.lit(1), a.lit(2)); // 1 + 2
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;expression&lt;/code&gt; method encodes the expression tree &lt;code&gt;1 + 2&lt;/code&gt; made of an &amp;quot;add
node&amp;quot; with two &amp;quot;literal node&amp;quot; child. Of course, there are no such nodes — it&amp;#39;s
just a method!&lt;/p&gt;
&lt;p&gt;To do anything useful with &lt;code&gt;expression&lt;/code&gt;, we need to supply an &lt;code&gt;Algebra&amp;lt;E&amp;gt;&lt;/code&gt; where
&lt;code&gt;E&lt;/code&gt; is an (unconstrainted) type used to represent the result of an operation on
one of our &amp;quot;nodes&amp;quot;. So for instance, &lt;code&gt;a.lit(1)&lt;/code&gt; will return a value of type &lt;code&gt;E&lt;/code&gt;.
The &lt;code&gt;add&lt;/code&gt; method returns a value of type &lt;code&gt;E&lt;/code&gt;, but also takes as parameter two
values of type &lt;code&gt;E&lt;/code&gt;, corresponding to the result of &amp;quot;evaluating&amp;quot; its two
operands.&lt;/p&gt;
&lt;p&gt;To define an operation, we need to implement &lt;code&gt;Algebra&amp;lt;E&amp;gt;&lt;/code&gt;. Here is a full
implementation that uses the same example as previously:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://gist.github.com/norswap/9d4dd9ae5c0fd2ef652a1f41778467ea#file-objectalgebraep-java&quot;&gt;Object Algebra Solution&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So there our operations are printing and evaluation. We actually use two
different techniques for these two operations.&lt;/p&gt;
&lt;p&gt;In the case of &lt;code&gt;PrintAlgebra&lt;/code&gt;, we implement &lt;code&gt;Algebra&amp;lt;Print&amp;gt;&lt;/code&gt; where &lt;code&gt;Print&lt;/code&gt; is a
functional interface we defined with a &lt;code&gt;print()&lt;/code&gt; method. Therefore, calling
&lt;code&gt;expression(new PrintAlgebra())&lt;/code&gt; will return an object that can be used to print
the expression.&lt;/p&gt;
&lt;p&gt;This is not the most direct avenue — we could have opted to implement
&lt;code&gt;Algebra&amp;lt;String&amp;gt;&lt;/code&gt; instead and have &lt;code&gt;lit&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt; return their string
representation directly. In fact, we take this approach with &lt;code&gt;EvalAlgebra&lt;/code&gt; which
implements &lt;code&gt;Algebra&amp;lt;Integer&amp;gt;&lt;/code&gt; — there, &lt;code&gt;lit&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt; directly return the
integer they evaluate to.&lt;/p&gt;
&lt;p&gt;Finally, a really neat trick not mentionned in the paper is that we can build an
actual data structure from the functional encoding. For this, simply make an
algebra that implements &lt;code&gt;Algebra&amp;lt;Exp&amp;gt;&lt;/code&gt; or &lt;code&gt;NegAlgebra&amp;lt;Exp&amp;gt;&lt;/code&gt; (depending on your
needs, and assuming &lt;code&gt;Exp&lt;/code&gt; is the parent class) and have each method return the
node it corresponds to.&lt;/p&gt;
&lt;p&gt;Turning these data structures back into an algebra encoding is unfortunately not
possible. One could imagine that &lt;code&gt;Exp&lt;/code&gt; has a &lt;code&gt;E visit(Algebra&amp;lt;E&amp;gt;)&lt;/code&gt; method that
is overriden in data classes to simply call the corresponding algebra method.
The problem happens when you have introduced new data cases. If you added a
&lt;code&gt;neg&lt;/code&gt; method in &lt;code&gt;NegAlgebra&amp;lt;E&amp;gt;&lt;/code&gt;, now you need the signature to be &lt;code&gt;E
visit(NegAlgebra&amp;lt;E&amp;gt;)&lt;/code&gt;. This is &lt;em&gt;almost&lt;/em&gt; feasible, supposing we could
parameterize &lt;code&gt;Exp&lt;/code&gt; as follow: &lt;code&gt;Exp&amp;lt;A extends Algebra&amp;gt;&lt;/code&gt; and then define the
method &lt;code&gt;E visit (A&amp;lt;E&amp;gt;)&lt;/code&gt;. Unfortunately that would make &lt;code&gt;A&lt;/code&gt; a &lt;a href=&quot;https://en.wikipedia.org/wiki/Type_constructor&quot;&gt;higher-order type&lt;/a&gt;
(i.e. a type that takes a parameter, here &lt;code&gt;E&lt;/code&gt;) and Java doesn&amp;#39;t have those.&lt;/p&gt;
&lt;p&gt;Of course, you could just use &lt;code&gt;Algebra&amp;lt;E&amp;gt;&lt;/code&gt; as a bound and add a cast in there,
type-unsafe but effective.&lt;/p&gt;
&lt;p&gt;When dealing with object algebra, one may be concerned that it&amp;#39;s no longer
possible to &amp;quot;build a data structure dynamically&amp;quot;, i.e. that all data must be
statically defined like in our &lt;code&gt;expression&lt;/code&gt; method.&lt;/p&gt;
&lt;p&gt;That is fortunately not the case. Since the algebra encoding of an expression is
just method calls, any execution flow that calls algebra methods can yield
expressions. And execution can contain conditions, loops, etc. One potential
pitfall is that the whole construction logic needs to be re-run each time we
want to run an operation of our data. If the construction logic is expensive,
this can be a problem. Fortunately there is a solution: simply return a function
object that encodes the expression:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;
public E expr1 (NegAlgebra&amp;lt;E&amp;gt; a) {
    return expensive_predicate()
        ? a.add(a.lit(1), a.lit(2))
        : a.add(a.lit(1), a.neg(a.lit(2)));
}

// use: expr1(my_algebra);
// slow!

public E Function&amp;lt;NegAlgebra&amp;lt;E&amp;gt;, E&amp;gt; expr2() {
    return expensive_predicate()
        ? a -&amp;gt; a.add(a.lit(1), a.lit(2))
        : a -&amp;gt; a.add(a.lit(1), a.neg(a.lit(2)));
}

// use: expr2.apply(my_algebra);
// fast!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we pass an algebra to &lt;code&gt;expr2&lt;/code&gt;, &lt;code&gt;expensive_predicate()&lt;/code&gt; is not run — it is
only run once when the &lt;code&gt;expr2&lt;/code&gt; is created.&lt;/p&gt;
&lt;p&gt;Finally, object algebra make &amp;quot;tree reuse&amp;quot; easy. You can compose an expression
built with an &lt;code&gt;Algebra&amp;lt;E&amp;gt;&lt;/code&gt; and one built with a &lt;code&gt;NegAlgebra&amp;lt;E&amp;gt;&lt;/code&gt; pretty easily:
the trick is that they only interface using &lt;code&gt;E&lt;/code&gt;, so as long as &lt;code&gt;E&lt;/code&gt; is the same,
anything goes. Of course, this means you have to use &lt;em&gt;compatible&lt;/em&gt; algebras. It
could be argued that is not type-safe (or that it is another advantage): nothing
prevents you from using two algebra with different semantics together, passing
the result of one to the other... as long as &lt;code&gt;E&lt;/code&gt; is the same.&lt;/p&gt;
&lt;p&gt;The paper mentions other interesting possibilities: multi-parameter algebra
(mimicking &lt;a href=&quot;https://en.wikipedia.org/wiki/Type_family&quot;&gt;type families&lt;/a&gt;), combinators for automatic combination of multiple
algebra, as well as allowing extension of the &lt;code&gt;E&lt;/code&gt; parameter (e.g. &lt;code&gt;Eval&amp;lt;E
extends Number&amp;gt; implements Algebra&amp;lt;E&amp;gt;&lt;/code&gt;), ...&lt;/p&gt;
&lt;p&gt;There is a lot to like about object algebra, it&amp;#39;s a really elegant technique —
in fact it&amp;#39;s the shortest implementation, and one of the most readable. It has
many advantages, from the possibility of building a real data structure to &amp;quot;tree
reuse&amp;quot;. Perhaps its main weakness is being a bit &lt;em&gt;too&lt;/em&gt; alien to be integrated in
many code bases, where one will &lt;em&gt;need&lt;/em&gt; to have actual data structures. For
instance, in my &lt;a href=&quot;https://github.com/norswap/autumn&quot;&gt;Autumn&lt;/a&gt; parsing library, the parser combinators can&amp;#39;t be
canonically represented as function calls — while it is possible to implement
parsing that way (by using objects similar to &lt;code&gt;Print&lt;/code&gt; in our example), it would
be incredibly slow. However it is possible to use an object algebra to build the
parser combinator graph, and to reuse the encoding for visiting it. However,
this is only possible because this graph is immutable (and so will always stay
in sync with its functional encoding).&lt;/p&gt;
&lt;p&gt;It&amp;#39;s definitely a technique to keep in the back of your mind.&lt;/p&gt;
&lt;h2 id=&quot;covariant-return-types&quot;&gt;Covariant Return Types&lt;/h2&gt;
&lt;p&gt;Finally, we look at our last solution, from the paper &amp;quot;The Expression Problem,
Trivially!&amp;quot; (&lt;a href=&quot;https://i.cs.hku.hk/~bruno/papers/Modularity2016.pdf&quot;&gt;link&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;This solution is very very close to Torgersen&amp;#39;s &lt;a href=&quot;https://gist.github.com/norswap/9d4dd9ae5c0fd2ef652a1f41778467ea#file-torgersendataep-java&quot;&gt;first (data-driven) solution&lt;/a&gt;,
but the essential differences between both is that this solution foregoes the
use of generics in favor of covariant return types. What are covariant return
types? In Java, you can override a method by a method with a different return
type, but only if that type is a subtype of the original return type, for
instance:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;abstract class A {
    abstract Object foo();
}

abstract class B extends A {
    @Override String foo();
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This works because &lt;code&gt;String&lt;/code&gt; is a subclass of &lt;code&gt;Object&lt;/code&gt;. And if you didn&amp;#39;t know,
yes you can override an abstract method without implementing it — that&amp;#39;s an
essential feature needed in the covariant solution.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s have a look at the solution:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://gist.github.com/norswap/9d4dd9ae5c0fd2ef652a1f41778467ea#file-covariantep-java&quot;&gt;Covariant Return Type Solution&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Whereas Torgersen&amp;#39;s solution encodes the expression type as an F-shape bounded
generic type parameter (&lt;code&gt;C extends Exp&amp;lt;C&amp;gt;&lt;/code&gt;), and subsequently types children
using this type (e.g. &lt;code&gt;C left, right;&lt;/code&gt; in the &lt;code&gt;Add&lt;/code&gt; class; the covariant
solution defines the children as abstract method whose return type is &lt;code&gt;Exp&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Both solution need a &amp;quot;fix class&amp;quot;: in Torgersen&amp;#39;s solution, the class fixes &lt;code&gt;C&lt;/code&gt;:
&lt;code&gt;AddF extends Add&amp;lt;ExpF&amp;gt;&lt;/code&gt; and later &lt;code&gt;EvalAddF extends EvalAdd&amp;lt;EvalExpF&amp;gt;&lt;/code&gt;. In the
covariant solution, the methods are overriden with the actual expression type:
simply &lt;code&gt;Exp&lt;/code&gt; in the base case, but &lt;code&gt;EvalExp&lt;/code&gt; in the &amp;quot;eval&amp;quot; extension.&lt;/p&gt;
&lt;p&gt;This is rather neat, and absent some issue I didn&amp;#39;t think of, seems strictly
superior Torgersen&amp;#39;s solution. It does however come with that solution&amp;#39;s other
pitfalls, including the need to parameterize the construction logic. You&amp;#39;ll note
we didn&amp;#39;t include factories in our code for this solution, but we did in
Torgersen&amp;#39;s solution. Don&amp;#39;t let this fool you: they are equally needed (or can
equally be dispensed with) in both cases.&lt;/p&gt;
&lt;h2 id=&quot;discussion--recommendations&quot;&gt;Discussion &amp;amp; Recommendations&lt;/h2&gt;
&lt;p&gt;I came out of this article having learned a lot more than I expected going in.
The impetus for this article was that I couldn&amp;#39;t clearly articulate how the
different solutions worked and how they related to each other.&lt;/p&gt;
&lt;p&gt;I also wanted to make the point that they were needlessly complex and that my
solution was better. Having done the research, I wouldn&amp;#39;t say that this is
necessarily true. Hence the little discussion now to be had about what should be
used when.&lt;/p&gt;
&lt;p&gt;First off, you should try to determine your requirements as precisely as
possible. In particular:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Do you need strict type safety? How do you define that? (What is not allowed
to happen?)&lt;/li&gt;
&lt;li&gt;Do you care about independent extensibility: if two different developers
extend the base framework and redistribute their exensions, can a third
developer come along and compose their extensions without resorting to
modifying the code written by the two first developers?&lt;/li&gt;
&lt;li&gt;Who is going to use the solution? What is its area of surface?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With that in mind...&lt;/p&gt;
&lt;p&gt;First off, if you care about independent extensibility, you have no choice but
to use my solution. The others &lt;em&gt;might&lt;/em&gt; be modified to accomodate it, by using
Java 8&amp;#39;s &lt;code&gt;default&lt;/code&gt; interface methods — but you&amp;#39;ll have to figure that yourself.
Do keep in mind that this aspect of it wasn&amp;#39;t shown in &lt;a href=&quot;https://gist.github.com/norswap/9d4dd9ae5c0fd2ef652a1f41778467ea#file-norswapep-java&quot;&gt;the example
code&lt;/a&gt; but is explained in &lt;a href=&quot;/java-visitor-pattern&quot;&gt;the previous post&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Beware that independent extensibility does add a lot of boilerplate, and likely
will in other solutions too. And remember my solution isn&amp;#39;t type-safe.&lt;/p&gt;
&lt;p&gt;If you need perfect type safety (do you really?) &lt;strong&gt;and&lt;/strong&gt; you&amp;#39;re using immutable
trees, I would go for Torgensen&amp;#39;s 3rd solution (operation-centered with
object-level extensibility).&lt;/p&gt;
&lt;p&gt;In general, I would try to think hard about whether object algebras can be used
in your use case. In a sense, they&amp;#39;re the most elegant solution. One big caveat:
I would think twice about using them to build a data structure — now you have
two representations to keep in sync, and double duties.&lt;/p&gt;
&lt;p&gt;In general, I feel like the sweet spot for them is either small localized
things, or a central paradigm around which everything revolves. I&amp;#39;d be uneasy
about making an object algebra one of many big moving parts in a program. My
programmer&amp;#39;s intuition say this way lay clunky mixed-metaphors.&lt;/p&gt;
&lt;p&gt;I would avoid using the data-centered solutions (Torgersen&amp;#39;s 1st and the
covariant solution) &lt;strong&gt;unless&lt;/strong&gt; object instantiation is very tightly controlled
or centralized in your program. Playing with factories is not super fun.&lt;/p&gt;
&lt;p&gt;A few more observations:&lt;/p&gt;
&lt;p&gt;My solution and Torgersen&amp;#39;s 4th (hybrid) solution are pretty much tied. Mine is
guaranteed to work with independent extensibility (with the proper boilerplate),
but Torgersen&amp;#39;s will also work fairly often. But for instance, it won&amp;#39;t work if
two people introduce new data classes and implement an old visitor for these
classes — there is no easy/safe way to &amp;quot;merge&amp;quot; the two implementations. However,
it would more natural to implement the operations directly into the data class
in this case! Torgersen&amp;#39;s solution can also lead to less boilerplate in the case
where you never have to deal with independent extensibility.&lt;/p&gt;
&lt;p&gt;The covariant solution strictly dominates Torgersen&amp;#39;s 1st (data-centered)
solution.&lt;/p&gt;
      </description>
      <pubDate>2019-08-20T22:00:00.000Z</pubDate>
      <link>http://norswap.com/expression-problem-java</link>
      <guid isPermaLink="true">http://norswap.com/expression-problem-java</guid>
    </item>
    <item>
      <title>The Intuition For React</title>
      <description>
&lt;p&gt;The other day, I found &lt;a href=&quot;https://svelte.dev/blog/virtual-dom-is-pure-overhead&quot;&gt;this article&lt;/a&gt; (&amp;quot;Virtual DOM is pure overhead&amp;quot;) on
&lt;a href=&quot;https://news.ycombinator.com/item?id=19950253&quot;&gt;Hacker News&lt;/a&gt; and started reading it. Halfway through, &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt; finally clicked
for me.&lt;/p&gt;
&lt;p&gt;See, I don&amp;#39;t do web programming, but I keep abreast of tech news, notably via
hacker news and web frameworks always feature heavily. If you had asked me
before what React was I could have given a generic answer (&amp;quot;something something
fronted framework something something state&amp;quot;), but I couldn&amp;#39;t have explaine why
we actually needed React, what it improved compared to using vanilla Javascript.&lt;/p&gt;
&lt;p&gt;Well, basically, the idea is that when some event occurs (e.g. the user performs
some input) the state of the page/application is going to change (probably
through the effect of an event listener). When that happens, you might have to
redraw part of the page layout.&lt;/p&gt;
&lt;p&gt;That&amp;#39;s when things can start to become hairy. If your application is complex,
there might many possible configurations for the layout, and so many ways in
which the layout could change.&lt;/p&gt;
&lt;p&gt;A common approach to these kind of problems is to model the application as a
state machine, with each state change represented as a state transition. This
approach works, but doesn&amp;#39;t scale too well to complex applications — the state
machine gets too complex, it doesn&amp;#39;t fit into your head anymore.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The idea behind React then is&lt;/strong&gt;: stop &lt;em&gt;changing&lt;/em&gt; the layout. Instead,
re-render the whole layout from the state each time the state changes.&lt;/p&gt;
&lt;p&gt;That way, you don&amp;#39;t have to worry about handling each possible change in each
possible application state: instead you just write component that know how to
render themselves given the state they are given.&lt;/p&gt;
&lt;p&gt;Of course, re-rendering on every change would be pretty slow, so React uses a
&amp;quot;Virtual DOM&amp;quot; (just a tree mimicking the real &lt;a href=&quot;https://www.w3.org/TR/WD-DOM/introduction.html&quot;&gt;DOM&lt;/a&gt;) and compares that to the
real DOM, only replacing parts of the layout that have actually changed.&lt;/p&gt;
&lt;p&gt;That&amp;#39;s pretty simple. I thought: well isn&amp;#39;t that explained on &lt;a href=&quot;https://reactjs.org/&quot;&gt;the official
website&lt;/a&gt;?&lt;/p&gt;
&lt;p&gt;Well actually it does a pretty good job:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Declarative&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;React makes it painless to create interactive UIs. Design simple views for
each state in your application, and React will efficiently update and render
just the right components when your data changes.&lt;/p&gt;
&lt;p&gt;Declarative views make your code more predictable and easier to debug.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Component-Based&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Build encapsulated components that manage their own state, then compose them
to make complex UIs.&lt;/p&gt;
&lt;p&gt;Since component logic is written in JavaScript instead of templates, you can
easily pass rich data through your app and keep state out of the DOM.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;But it doesn&amp;#39;t explain that the purpose of this &amp;quot;efficient re-rendering&amp;quot; is to
avoid having to keep track of the current layout yourself and change it in a
legitimate way, which quickly becomes error prone.&lt;/p&gt;
&lt;p&gt;And that&amp;#39;s it for today!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Post Scriptum&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The topic of the &lt;a href=&quot;https://svelte.dev/blog/virtual-dom-is-pure-overhead&quot;&gt;article&lt;/a&gt; itself is pretty interesting in its
own right. So is the discussion at &lt;a href=&quot;https://news.ycombinator.com/item?id=19950253&quot;&gt;Hacker News&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In reeeal condensed, the article says that because the optimal manual change to
the DOM is going to be faster than diffing + a sub-optimal DOM change performed
by React, the virtual DOM is pure overhead. It&amp;#39;s right, but leaves out the fact
that all that is done for managing complexity.&lt;/p&gt;
&lt;p&gt;The article is written by Rich Harris, the author of &lt;a href=&quot;https://svelte.dev/&quot;&gt;the Svelte
framework&lt;/a&gt; — and sell Svelte&amp;#39;s ability to basically manage complexity
but at the same time generate the optimal change at build-time.&lt;/p&gt;
&lt;p&gt;The discussion makes other interesting points regarding the genesis of React.
Because the algorithm is fickle I&amp;#39;m gonna be quoting the discussion here:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;oraphalous&lt;/em&gt;:&lt;/p&gt;
&lt;p&gt;I think this article - and many of the comments on this thread are forgetting
the context of how DOM manipulation was typically done when the virtual DOM
approach was introduced.&lt;/p&gt;
&lt;p&gt;Here&amp;#39;s the gist of how folks would often update an element. You&amp;#39;d subscribe to
events on the root element of your component. And if your component is of any
complexity at all - first thing you&amp;#39;d probably do is ask jQuery to go find any
child elements that need updating - inspecting the DOM in various ways so as
to determine the component&amp;#39;s current state.&lt;/p&gt;
&lt;p&gt;If your component needed to affect components higher up, or sibling to the
current instance - then your application is often doing a search of the DOM to
find the nodes.. and yes if you architect things well then you could avoid a
lot of these - but let&amp;#39;s face it, front end developers weren&amp;#39;t typically
renown for their application architecture skills.&lt;/p&gt;
&lt;p&gt;In short - the DOM was often used to store state. And this just isn&amp;#39;t a very
efficient approach.&lt;/p&gt;
&lt;p&gt;This is what I understood the claim that VDOMs are faster than the real DOM
meant - and the article is pretty much eliding this detail.&lt;/p&gt;
&lt;p&gt;As far as I&amp;#39;m aware React and its VDOM approach was the framework that
deserves the credit for changing the culture of how we thought about state
management on the frontend. That newer frameworks have been able to build upon
this core insight - in ways that are even more efficient than the VDOM
approach is great - but they should pay homage to that original insight and
change in perspective React made possible.&lt;/p&gt;
&lt;p&gt;I feel this article and many of the comments here so far - fail to do that -
and worse, seem to be trying to present React&amp;#39;s claim of the VDOM faster than
the DOM as some kind of toddler mistake.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;jasonkester:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;the DOM was often used to store state.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Every once in a while I&amp;#39;m reminded that I&amp;#39;m mostly disconnected from the way
&amp;quot;most&amp;quot; people build things. Thanks for this insight. It finally explains why I
hear people talking down about &amp;quot;jQuery developers&amp;quot;, if that was something that
people actually did.&lt;/p&gt;
&lt;p&gt;But wow. I&amp;#39;ve been building javascript-heavy web stuff since the mid 90&amp;#39;s and it
had never occurred to me to do that. You have your object model, and each thing
had a reference back to its DOM node and some methods to update itself if
necessary. All jQuery did was make it less typing to initially grab the DOM node
(or create it), and give you some shorthand for setting classes on them.&lt;/p&gt;
&lt;p&gt;It also explains why people liked React, which has always seemed completely
overcomplicated to me, but which probably simplified things a lot if you didn&amp;#39;t
ever have a proper place to keep your data model.&lt;/p&gt;
&lt;p&gt;I can&amp;#39;t imagine I was the only one who had things figured out back then,
though. The idea you&amp;#39;re talking about sounds pretty terrible.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;onion2k:&lt;/p&gt;
&lt;p&gt;Bare in mind that most people using jQuery weren&amp;#39;t writing JavaScript
applications. They were writing backend-driven applications with jQuery
enhancements, so there was no real concept of frontend &amp;#39;state&amp;#39; that was
separate to the DOM itself. If your frontend code needed to work with &amp;#39;state&amp;#39;
like form values or element attributes you had to read them, and because there
could be multiple separate bits of code working with the same form or element
you had to write values back to the DOM so the next bit of code had the
correct &amp;#39;state&amp;#39;.&lt;/p&gt;
&lt;p&gt;The thing that changed to make frontend development improve dramatically was
hash based routing with ajax, and later the introduction of the history API.
That caused frontend development to have a need to retain state between
&amp;#39;pages&amp;#39;, so then was a need to find a better way to store it than using DOM
attributes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Udik:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;the thing that changed to make frontend development improve
dramatically was hash based routing with ajax...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I think that what&amp;#39;s changed is simply that people realized that it&amp;#39;s way less
messy to use the backend only as a data source (with ajax calls), and leave
everything else to the frontend. The cognitive overhead of having the server
producing html with some implicit state, then updating that state interactively,
and then losing everything again by posting the whole page to the server, was
simply unbearable.&lt;/p&gt;
&lt;p&gt;When I started building web applications in 2004 I had some experience in
writing desktop apps: I simply created a js library to create and destroy UI
elements, and wrote &amp;quot;desktop&amp;quot; apps running in the browser.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Isn&amp;#39;t all that positively enlightening?&lt;/p&gt;
      </description>
      <pubDate>2019-05-31T22:00:00.000Z</pubDate>
      <link>http://norswap.com/react-intuition</link>
      <guid isPermaLink="true">http://norswap.com/react-intuition</guid>
    </item>
    <item>
      <title>The Visitor Pattern in Java 8</title>
      <description>
&lt;p&gt;The visitor pattern is probably one of the most (in)famous design patterns.&lt;/p&gt;
&lt;p&gt;The problem it solves is fairly simple. In most object-oriented languages, it&amp;#39;s
easy to add new &lt;em&gt;data-type variants&lt;/em&gt;, i.e. new sub-classes. These classes can
naturally override the methods in the super-class/interface. However, we can&amp;#39;t
add methods to an existing super-class without modifying it — which is not
possible if it belongs to a library. The visitor pattern is a way to achieve
something similar.&lt;/p&gt;
&lt;p&gt;Imagine you want to add a &lt;code&gt;print()&lt;/code&gt; method to an existing interface called
&lt;code&gt;Base&lt;/code&gt; that has implementations &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;. If we could add &lt;code&gt;print()&lt;/code&gt; to
&lt;code&gt;Base&lt;/code&gt;, we could call &lt;code&gt;new A().print()&lt;/code&gt;. The visitor pattern will allow us to do
&lt;code&gt;new A().accept(new PrintVisitor())&lt;/code&gt; to achieve the same thing.&lt;/p&gt;
&lt;p&gt;For this to work, &lt;code&gt;Base&lt;/code&gt; needs to have been conceived with the visitor pattern
in mind. It needs to declare an abstract &lt;code&gt;accept(Visitor)&lt;/code&gt; method and all its
implementations need to implement it according to the pattern.&lt;/p&gt;
&lt;p&gt;With this interface and requirements in mind, let&amp;#39;s see some code.&lt;/p&gt;
&lt;h2 id=&quot;basic-example&quot;&gt;Basic Example&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;interface Visitor {
    void visit (A object);
    void visit (B object);
}

interface Base {
    void accept (Visitor visitor);
}

class A implements Base {
    @Override public void accept (Visitor visitor) {
        visitor.visit(this); // calls visit(A)
    }
}

class B implements Base {
    @Override public void accept (Visitor visitor) {
        visitor.visit(this); // calls visit(B)
    }
}

class PrintVisitor implements Visitor
{
    @Override public void visit (A object) {
        System.out.println(&amp;quot;printing an A&amp;quot;);
    }
    @Override public void visit (B object) {
        System.out.println(&amp;quot;printing a B&amp;quot;);
    }
}

public class Example
{
    public static void print (Base object) {
        object.accept(new PrintVisitor());
    }
    public static void main (String[] args) {
        print(new A());
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What happens is that the &lt;code&gt;accept()&lt;/code&gt; method declared in &lt;code&gt;Base&lt;/code&gt; must be overriden
in all of its implementations (&lt;code&gt;Base&lt;/code&gt; could have been a class as well). The role
of the overriden method is to redirect the execution to the correct
&lt;code&gt;Visitor#visit&lt;/code&gt; overload. This is possible (and type-safe) because the static
type of &lt;code&gt;this&lt;/code&gt; corresponds to its dynamic type (&lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;) in the overriden
method.&lt;/p&gt;
&lt;p&gt;And honestly, that&amp;#39;s all there is to the common formulation of the visitor
pattern. Explanations tend to contrive the point.&lt;/p&gt;
&lt;p&gt;However, the pattern can be taken much further to supply a solution to the
&lt;em&gt;expression problem&lt;/em&gt;. Basically, what if we have our visitor defined like above
but then we add a new implementation of &lt;code&gt;Base&lt;/code&gt;? Currently, all implementations
have to be known in advance, because they are hardcoded into &lt;code&gt;Visitor&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But first, let&amp;#39;s solve a small practical issue.&lt;/p&gt;
&lt;h2 id=&quot;handling-different-signatures&quot;&gt;Handling Different Signatures&lt;/h2&gt;
&lt;p&gt;There is an easily solvable issue with the design I presented above: both
&lt;code&gt;accept&lt;/code&gt; and &lt;code&gt;visit&lt;/code&gt; don&amp;#39;t admit extra parameters, nor do they have return
values.&lt;/p&gt;
&lt;p&gt;One solution is to rewrite these methods to include the required parameters and
return type. But doing this means that you need one &lt;code&gt;Visitor&lt;/code&gt;-like class and one
&lt;code&gt;accept&lt;/code&gt; overload for each signature of interest.&lt;/p&gt;
&lt;p&gt;A better solution is to use the &lt;code&gt;Visitor&lt;/code&gt; implementation to pass data around.
Here is an example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class AddRankVisitor extends Visitor
{
    public int result;
    public final int base;

    public AddRankVisitor (int base) {
        this.base = base;
    }

    @Override public void visit (A object) { set_result(base + 1); }
    @Override public void visit (B object) { set_result(base + 2); }
}

public class Example
{
    public static void add_rank (Base object, int base)
    {
        Visitor visitor = new AddRankVisitor(base);
        object.accept(visitor);
        return visitor.result;
    }

    public static void main (String[] args) {
        System.out.println(add_rank(new A(), 5)); // prints 6
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We use &lt;code&gt;result&lt;/code&gt; to represent the return value, and &lt;code&gt;base&lt;/code&gt; as a parameter. Pretty
easy, isn&amp;#39;t it?&lt;/p&gt;
&lt;h2 id=&quot;the-expression-problem&quot;&gt;The Expression Problem&lt;/h2&gt;
&lt;p&gt;The original formulation of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Expression_problem&quot;&gt;expression problem&lt;/a&gt; is as follow:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The goal is to define a datatype by cases, where one can add new cases to the
datatype and new functions over the datatype, without recompiling existing
code, and while retaining static type safety (e.g., no casts).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If you consider it in the context of object-oriented programming, a &lt;em&gt;datatype&lt;/em&gt;
corresponds to a parent class or interface. &lt;em&gt;New datatype cases&lt;/em&gt; are new classes
extending the parent class or interface. &lt;em&gt;New functions&lt;/em&gt; are as thought you
could add an abstract method to the parent class or interface, along with
overrides for the implementing classes.&lt;/p&gt;
&lt;p&gt;Adding a new case is simply sub-classing/implementation. Adding new functions
can be done via the visitor pattern as seen above. But can we do both?&lt;/p&gt;
&lt;p&gt;If you defined visitors as we did above, then if you add a new implementation of
&lt;code&gt;Base&lt;/code&gt;, it won&amp;#39;t be handled by our &lt;code&gt;print&lt;/code&gt; and &lt;code&gt;add_rank&lt;/code&gt; methods. Like we said
before, &lt;code&gt;Visitor&lt;/code&gt; needs to list all the implementations.&lt;/p&gt;
&lt;p&gt;In theory, there is nothing that prevents solving the expression problem at the
language level. In an ideal world, we&amp;#39;d just be able to add abstract extension
methods that have to be implemented for all classes implementing the interface.
The &lt;a href=&quot;https://en.wikipedia.org/wiki/Linker_(computing)&quot;&gt;linker&lt;/a&gt; would then verify that these methods were implemented for all such
classes, and generate the proper &lt;a href=&quot;https://en.wikipedia.org/wiki/Virtual_method_table&quot;&gt;virtual method tables&lt;/a&gt;. But no such
object-oriented language exists.&lt;/p&gt;
&lt;p&gt;Perhaps a more well-understood way to do this is through statically-typed
&lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;multi-methods&lt;/a&gt;. But I don&amp;#39;t know any actual practical language (i.e. something
used in production) that has them, though there are academic papers on the
subject. &lt;a href=&quot;https://nim-lang.org/docs/tut2.html#object-oriented-programming-dynamic-dispatch&quot;&gt;Nim&lt;/a&gt; has statically-typed multi-methods but you must include a default
implementation. &lt;a href=&quot;https://blogs.msdn.microsoft.com/laurionb/2009/08/13/multimethods-in-c-4-0-with-dynamic/&quot;&gt;C# 4&lt;/a&gt; has a &lt;code&gt;dynamic&lt;/code&gt; keyword that enables multi-methods but
without compile-time checking.&lt;/p&gt;
&lt;p&gt;There are languages that solve the expression problem however. The foremost
solution is &lt;a href=&quot;https://en.wikipedia.org/wiki/Type_class&quot;&gt;typeclasses&lt;/a&gt;, notably in Haskell (also read &lt;a href=&quot;/typeclass-scheme&quot;&gt;here&lt;/a&gt;
for my thoughts on a potential typeclass system).&lt;/p&gt;
&lt;p&gt;Basically, you can add new methods over existing types by writing new
typeclasses and their implementations for the given types. Compared to our
object-oriented scenario, there is no notion of inheritance, so no way to say
that a group of types should implement the typeclass — the expectation is that
this will be caught statically when you try to require a typeclass
implementation for such a type.&lt;/p&gt;
&lt;p&gt;But back to Java-land. Let&amp;#39;s see how we can approach a solution by building on
top of the visitor pattern.&lt;/p&gt;
&lt;h2 id=&quot;adding-a-class-to-an-existing-visitor&quot;&gt;Adding a Class to an Existing Visitor&lt;/h2&gt;
&lt;p&gt;Let&amp;#39;s add a new implementation of &lt;code&gt;Base&lt;/code&gt; called &lt;code&gt;C&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;interface VisitorC extends Visitor {
    void visit (C object);
}

class C implements Base {
    @Override public void accept (Visitor visitor) {
        ((VisitorC) visitor).visit(this);
    }
}

class PrintVisitorC extends PrintVisitor implements VisitorC {
    @Override public void visit (C object) {
        System.out.println(&amp;quot;printing a C&amp;quot;);
    }
}

class AddRankVisitorC extends AddRankVisitor implements VisitorC
{
    public AddRankVisitorC (int base) { super(base); }
    @Override public void visit (C object) { set_result(base + 3); }
}

public class Example
{
    public static void print (Base object) {
        object.accept(new PrintVisitorC());
    }

    public static void add_rank (Base object, int base)
    {
        VisitorC visitor = new AddRankVisitorC(base);
        object.accept(visitor);
        return visitor.result;
    }

    public static void main (String[] args) {
        print(new A());
        print(new C());
        System.out.println(add_rank(new A(), 5)); // prints 6
        System.out.println(add_rank(new C(), 5)); // prints 8
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since &lt;code&gt;Visitor&lt;/code&gt; doesn&amp;#39;t have an overload for &lt;code&gt;C&lt;/code&gt;, we add this overload in an
extension of &lt;code&gt;Visitor&lt;/code&gt; called &lt;code&gt;VisitorC&lt;/code&gt;. The only worry: &lt;code&gt;accept&lt;/code&gt; takes
&lt;code&gt;Visitor&lt;/code&gt;, not &lt;code&gt;VisitorC&lt;/code&gt;, so we have to perform a cast.&lt;/p&gt;
&lt;p&gt;We similarly extends &lt;code&gt;PrintVisitor&lt;/code&gt; and &lt;code&gt;AddRankVisitor&lt;/code&gt; to add an
implementation for the &lt;code&gt;visit(C)&lt;/code&gt; overload.&lt;/p&gt;
&lt;p&gt;Also notice how we do not need to reimplement the storage for &lt;code&gt;AddRankVisitorC&lt;/code&gt;
if we extend &lt;code&gt;AddRankVisitor&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The trick works: we can use a &lt;code&gt;PrintVisitorC&lt;/code&gt; and &lt;code&gt;AddRankVisitorC&lt;/code&gt; to visit
both the previous &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; classes but also the new &lt;code&gt;C&lt;/code&gt; class.&lt;/p&gt;
&lt;p&gt;In the process however, we&amp;#39;ve jeopardized type safety. We could write: &lt;code&gt;new
C().accept(new PrintVisitor())&lt;/code&gt; and the code would compile but crash at run-time
with a &lt;code&gt;ClassCastException&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There actually is a pretty rich literature on how to solve the expression
problem in Java with proper statical type safety. So it &lt;em&gt;is&lt;/em&gt; possible. However,
all these solutions have other pitfalls (in my humble opinion, worse pitfalls).
A followup article will discuss the limitations of these solutions and why I
feel my solution is better.&lt;/p&gt;
&lt;p&gt;But before... we are not entirely done yet!&lt;/p&gt;
&lt;h2 id=&quot;composing-independent-extensions&quot;&gt;Composing Independent Extensions&lt;/h2&gt;
&lt;p&gt;The last section deals with extending our system with a new class. But what if
you use two libraries, both of which have independently extended the visitor.
Can you compose them back into a single usable visitor?&lt;/p&gt;
&lt;p&gt;If the library authors have followed a couple of simple guidlines, you can!&lt;/p&gt;
&lt;p&gt;The key idea is as follow: each time we implement / extend a visitor, we will do
it in an interface instead of a class. We will add a corresponding class only to
make the interface instanciable and supply the necessary storage.&lt;/p&gt;
&lt;p&gt;With that in mind, let us revise what we have done above. First for what we had
before adding &lt;code&gt;C&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;interface _PrintVisitor extends Visitor
{
    @Override default void visit (A object) {
        System.out.println(&amp;quot;printing an A&amp;quot;);
    }
    @Override default void visit (B object) {
        System.out.println(&amp;quot;printing a B&amp;quot;);
    }
}

class PrintVisitor implements _PrintVisitor {}&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;interface _AddRankVisitor extends Visitor
{
    int result();
    void set_result (int result);
    int base();

    @Override default void visit (A object) { set_result(base() + 1); }
    @Override default void visit (B object) { set_result(base() + 2); }
}

class AddRankVisitor implements _AddRankVisitor
{
    private int result;
    private int base;

    @Override public int result() { return result; }

    @Override public void set_result (int result) {
        this.result = result;
    }

    @Override int base() { return base; }

    public AddRankVisitor (int base) {
        this.base = base;
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For &lt;code&gt;PrintVisitor&lt;/code&gt;, the class becomes an interface with a prefix &lt;code&gt;_&lt;/code&gt; and we add
a class with an empty body — no extra work required.&lt;/p&gt;
&lt;p&gt;For &lt;code&gt;AddRankVisitor&lt;/code&gt;, our fields are replaced with getter/setters in the
interface and we have to implement the storage for those in the class.&lt;/p&gt;
&lt;p&gt;Notice that with this setup, our former &lt;code&gt;Example.main&lt;/code&gt; methods (from before
adding &lt;code&gt;C&lt;/code&gt;) still work unmodified.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s then add back &lt;code&gt;C&lt;/code&gt;, which will constitute the first of two independent
extensions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;// `VisitorC` and `C` remain unchanged from above!

interface _PrintVisitorC extends _PrintVisitor, VisitorC
{
    @Override default void visit (C object) {
        System.out.println(&amp;quot;printing a C&amp;quot;);
    }
}

class PrintVisitorC implements _PrintVisitorC {}

interface _AddRankVisitorC extends AddRankVisitor, VisitorC
{
    @Override default void visit (C object) { set_result(base + 3); }
}

class AddRankVisitorC extends AddRankVistor
    implements _AddRankVisitorC
{
    public AddRankVisitorC (int base) { super(base); }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a lot like what we just did for the base visitors. Like before, we don&amp;#39;t
need to reimplement the storage for &lt;code&gt;AddRankVisitorC&lt;/code&gt; if we extend
&lt;code&gt;AddRankVisitor&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s do another similar extension, called &lt;code&gt;D&lt;/code&gt;. This is almost the same code by
a different name:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;interface VisitorD extends Visitor {
    void visit (D object);
}

class D implements Base
{
    @Override public void accept (Visitor visitor) {
        ((VisitorD) visitor).visit(this);
    }
}

interface _PrintVisitorD extends _PrintVisitor, VisitorD
{
    @Override default void visit (D object) {
        System.out.println(&amp;quot;printing a D&amp;quot;);
    }
}

class PrintVisitorD implements _PrintVisitorD {}

interface _AddRankVisitorD extends AddRankVisitor, VisitorD
{
    @Override default void visit (D object) { set_result(base + 4); }
}

class AddRankVisitorD extends AddRankVistor
    implements _AddRankVisitorD
{
    public AddRankVisitorD (int base) { super(base); }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have our two independant extensions setup properly with interfaces,
let&amp;#39;s compose them into a single one.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;interface VisitorCD
    extends VisitorC, VisitorD {}

interface _PrintVisitorCD
    extends VisitorCD, _PrintVisitorC, _PrintVisitorD {}

class PrintVisitorCD
    implements _PrintVisitorCD {}

interface _AddRankVisitorCD
    extends VisitorCD, _AddRankVisitorC, _AddRankVisitorD {}

class AddRankVisitorCD extends AddRankVistor
    implements _AddRankVisitorCD
{
    public AddRankVisitorCD (int base) { super(base); }
}

public class Example
{
    public static void print (Base object) {
        object.accept(new PrintVisitorCD());
    }

    public static void add_rank (Base object, int base)
    {
        VisitorCD visitor = new AddRankVisitorCD(base);
        object.accept(visitor);
        return visitor.result;
    }

    public static void main (String[] args) {
        print(new A());
        print(new C());
        print(new D());
        System.out.println(add_rank(new A(), 5)); // prints 6
        System.out.println(add_rank(new C(), 5)); // prints 8
        System.out.println(add_rank(new D(), 5)); // prints 9
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That&amp;#39;s it? Yep that&amp;#39;s it! And that&amp;#39;s actually the long version — which you
should use when you expose the visitor as part of a library. Even then
&lt;code&gt;VisitorCD&lt;/code&gt; is not capital and just helps add a tiny bit of type safety.&lt;/p&gt;
&lt;p&gt;If you write client code and nobody is supposed to extend your visitor, you
could just write:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class PrintVisitorCD
    implements _PrintVisitorC, _PrintVisitorD {}

class AddRankVisitorCD
    extends AddRankVisitor
    implements, _AddRankVisitorC, _AddRankVisitorD
{
    public AddRankVisitorCD (int base) { super(base); }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Isn&amp;#39;t life beautiful?&lt;/p&gt;
&lt;p&gt;You can consult the full final example (with &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, &lt;code&gt;PrintVisitor&lt;/code&gt;
and &lt;code&gt;AddRankVisitor&lt;/code&gt;) on &lt;a href=&quot;https://gist.github.com/norswap/7f3d40adb85491d440bdf026b738890a&quot;&gt;this page&lt;/a&gt;.&lt;/p&gt;
      </description>
      <pubDate>2019-05-24T22:00:00.000Z</pubDate>
      <link>http://norswap.com/java-visitor-pattern</link>
      <guid isPermaLink="true">http://norswap.com/java-visitor-pattern</guid>
    </item>
    <item>
      <title>The Zizek Peterson Debate</title>
      <description>
&lt;p&gt;Having previously enjoyed and written about both &lt;a href=&quot;/zizek-ideology/&quot;&gt;Slavoj Zizek&lt;/a&gt; and &lt;a href=&quot;/12-rules/&quot;&gt;Jordan
Peterson&lt;/a&gt;, I was interested to learn they&amp;#39;d have a debate. Billed as &amp;quot;The Debate
of the Century&amp;quot;, its official title was &amp;quot;Happiness: Capitalism vs. Marxism&amp;quot;.&lt;/p&gt;
&lt;p&gt;Having watched it (&lt;a href=&quot;https://www.youtube.com/watch?v=lsWndfzuOc4&quot;&gt;video&lt;/a&gt;), I regret to inform you it was neither of those
things. But I nonetheless found it interesting.&lt;/p&gt;
&lt;p&gt;The debate can best be seen as a collection of interesting ideas from both
authors with occasional bridges being thrown accross.&lt;/p&gt;
&lt;h2 id=&quot;peteresons-opening-statement&quot;&gt;Petereson&amp;#39;s Opening Statement&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=lsWndfzuOc4&amp;amp;t=899s&quot;&gt;(Video Timestamp)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Peterson opens with a 30-minutes speech where he criticizes the communist
manifesto, which he&amp;#39;d re-read for the occasion. I&amp;#39;d say his criticism is
essentially well-placed, &lt;em&gt;but&lt;/em&gt; as many are &lt;a href=&quot;http://archive.is/l1kc9&quot;&gt;quick to point out&lt;/a&gt;,
attacking the manifesto isn&amp;#39;t perhaps attacking Communism or even Marxism as its
strongest point. Still, that criticism would be salutary for most &amp;quot;communists&amp;quot;
I&amp;#39;ve talked to (which, unfortunately were more fanboys than rigorous
intellectuals). Another issue is that it&amp;#39;s hard to pin down what communism &lt;em&gt;is&lt;/em&gt;
with its constellation of thinkers. At least Marxism is closed off now that Marx
is dead and he never amended his manifesto that I know of.&lt;/p&gt;
&lt;p&gt;I was surprised (and a bit disappointed) that Peterson didn&amp;#39;t seem more
knowledgeable about communism. He makes a big deal out of how he obsessed about
the cold war, and it would seem to me that understanding the ideological roots
of the Soviet Union would be pretty important. Similarly, he&amp;#39;s crusading against
&amp;quot;post-modern neo-marxists&amp;quot; and it&amp;#39;s strange not to understand or at least know
your opponent&amp;#39;s ideas.&lt;/p&gt;
&lt;p&gt;The statement has some interesting ideas though, including the statement that
&amp;quot;almost all ideas are wrong&amp;quot;.&lt;/p&gt;
&lt;h2 id=&quot;zizeks-opening-statement&quot;&gt;Zizek&amp;#39;s Opening Statement&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=lsWndfzuOc4&amp;amp;t=2776s&quot;&gt;(Video Timestamp)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Zizek&amp;#39;s opening statement is probably the most interesting part of the debate.
You can find a transcript of it &lt;a href=&quot;http://archive.is/2XONl&quot;&gt;here&lt;/a&gt;. In typical Zizek fashion,
it&amp;#39;s made of many idea nuggets only tenuously linked to one other — although
there is a link, all the more difficult to follow in the spoken form.&lt;/p&gt;
&lt;p&gt;Zizek makes many interesting points. First, on how happiness is often the wrong
yardstick:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In our daily lives, we pretend to desire things which we do not really desire,
so that ultimately the worst thing that can happen is to get what we
officially desire. So, I agree that human life of freedom and dignity does not
consist just in searching for happiness, no matter how much we spiritualise
it, or in the effort to actualise our inner potentials. We have to find some
meaningful cause beyond the mere struggle for pleasurable survival.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Second on how modernity is characterized by the absence of authority (and
divinity) that could impose meaning from above, and how it&amp;#39;s impossible to go
back to this pre-modern state of affairs.&lt;/p&gt;
&lt;p&gt;He sees the rejections of some systemic failures of capitalism onto external
causes (from Donald Trump to migrants).&lt;/p&gt;
&lt;p&gt;His thoughts on social constructionism vs evolutionary psychology (comparing
them, of all things, to French cuisine) are also worth a listen/read.&lt;/p&gt;
&lt;p&gt;What&amp;#39;s perhaps most surprising is that Zizek doesn&amp;#39;t defend Marxism, which he
squarely throws under the bus as failed. He doesn&amp;#39;t do much to defend Communism
either, but points a problem with capitalism on what Marx called &amp;quot;commons&amp;quot; (I
wrote &lt;a href=&quot;/commons/&quot;&gt;about commons&lt;/a&gt; before). Capitalism threatens the commons due to its
self-reproducing nature, though he points out that communism had this
self-reproducing nature to (&amp;quot;the historical necessity of progress towards
communism&amp;quot;, though — fittingly — this drive was much more centralized).&lt;/p&gt;
&lt;p&gt;In fact, this was a surprise for many, but both men tended to agree a whole lot,
with only surface differences (some, though not all, could be chalked to their
vastly different backgrounds). The tone of the debate was also noted to be very
cordial and respectful, something I really appreciated.&lt;/p&gt;
&lt;p&gt;Zizek&amp;#39;s conclusion is, in his words &amp;quot;pessimistic&amp;quot;: we will continue to slide
towards disaster, maybe some catastrophes can shake us out of our ruts.&lt;/p&gt;
&lt;p&gt;I encourage you to &lt;a href=&quot;https://www.youtube.com/watch?v=lsWndfzuOc4&quot;&gt;watch the video&lt;/a&gt; or &lt;a href=&quot;http://archive.is/2XONl&quot;&gt;read the transcript&lt;/a&gt;
(or both), this part is the most interesting.&lt;/p&gt;
&lt;p&gt;I&amp;#39;d say this reminds me a lot of what I&amp;#39;ve &lt;a href=&quot;/zizek-ideology/&quot;&gt;seen from him&lt;/a&gt;
already. Some idea make a reappearance, other are newly developed, but it&amp;#39;s
clear these are coherent thoughts from the same thinker.&lt;/p&gt;
&lt;h2 id=&quot;further-comments&quot;&gt;Further Comments&lt;/h2&gt;
&lt;p&gt;The rest of the debate was (if memory serves) also interesting, but it gets even
more disjointed. Zizek was hard to follow in his prepared statement, he becomes
increasingly erratic in the rest of the debates. It&amp;#39;s funny to see Peterson
almost sweating from concentration trying to discern a thread.&lt;/p&gt;
&lt;p&gt;Like I said before, I appreciated immensely that both men seemed pretty much on
agreement (as well they should, adopting neither deluded far-left or far-right
opinions), and that the debate was cordial, even mutually admirative at times.&lt;/p&gt;
&lt;p&gt;It&amp;#39;s also &lt;em&gt;entertaining&lt;/em&gt; to watch, and I suspect this was the mode in which most
people consumed the debate.&lt;/p&gt;
&lt;p&gt;Peterson is his usual intensely-driven professorial self, which I personally
enjoy — while Zizek is his tick-ridden idiosyncratic self. He&amp;#39;s also quite
semi-intentionally quite funny. It&amp;#39;s hard not to crack up when — out of time for
his remarks, he starts telling a Slovenian joke, then after the first sentence
interrupts himself to add &amp;quot;I will finish immediately&amp;quot; before finishing the joke.&lt;/p&gt;
&lt;p&gt;If you&amp;#39;re curious, here&amp;#39;s &lt;a href=&quot;https://www.youtube.com/watch?v=lsWndfzuOc4&amp;amp;feature=youtu.be&amp;amp;t=6336&quot;&gt;the timestamp for the joke&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Regarding how the debate was receiving, judging from Twitter and some quick
google, pretty well on the center-right, and pretty badly on the left (broadly).&lt;/p&gt;
&lt;p&gt;A good criticism is the one made &lt;a href=&quot;http://archive.is/l1kc9&quot;&gt;by Benjamin Studebaker&lt;/a&gt;. His
argument abbreviated:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There are three necessary features which distinguish a bad Marx paper:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The paper contains a close reading of the Manifesto.&lt;/li&gt;
&lt;li&gt;The paper contains almost no references to any other texts, either by Marx or by other socialist thinkers.&lt;/li&gt;
&lt;li&gt;The paper contains a long digression about all the reasons the Soviet Union was terrible. I call this the “tankie-bashing” bit.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://archive.is/l1kc9&quot;&gt;The article&lt;/a&gt; also has a nice summary of Peterson&amp;#39;s opening
statement.&lt;/p&gt;
&lt;p&gt;His charge against Peterson&amp;#39;s argument is followed with how he thinks Zizek
should have replied to defend communism. It&amp;#39;s quite interesting, but it&amp;#39;s not
what the debate ended up being.&lt;/p&gt;
&lt;p&gt;Other commentators &lt;a href=&quot;http://archive.is/IkI0e&quot;&gt;opted for snide&lt;/a&gt;, which I think is sad — although the linked
live commentary &lt;em&gt;is&lt;/em&gt; quite funny.&lt;/p&gt;
&lt;p&gt;Other than that, multiple commentators (&lt;a href=&quot;http://archive.is/PHLu5&quot;&gt;one&lt;/a&gt;, &lt;a href=&quot;http://archive.is/MY9q5&quot;&gt;two&lt;/a&gt;) pointed that the &amp;quot;Debate
of the Century&amp;quot; was overhyped (overmarketed, really), and seemed poorly prepared
by its protagonists. And I must agree. Zizek is particularly culpable here, for
talking about wherever he felt like that was tenuously related rather than
sticking to &amp;quot;his camp&amp;quot;, but I feel like the resulting discussing ended up more
interesting because of it.&lt;/p&gt;
&lt;p&gt;And sure, the level of the discussion might have been unappealing to all the
critcial theorists that were widely read. But precisely due to the marketing,
this event had the possibility to reach a much wider audience. And if you think
something wrong was said therein, you ought to engage the content rather than
ridiculing the form.&lt;/p&gt;
&lt;p&gt;Ultimately, &lt;a href=&quot;https://www.youtube.com/watch?v=lsWndfzuOc4&quot;&gt;make your own opinion&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Bonus: &lt;a href=&quot;https://www.iep.utm.edu/zizek/&quot;&gt;Zizek on the Internet Encyclopedia of Philosophy&lt;/a&gt;&lt;/p&gt;
&lt;!-- original: https://pastebin.com/SNsDQ5SF --&gt;
&lt;!-- https://www.currentaffairs.org/2019/04/how-zizek-should-have-replied-to-jordan-peterson --&gt;
&lt;!-- https://nowtoronto.com/culture/books/jordan-peterson-slavoj-zizek-debate/ --&gt;
&lt;!-- https://www.theguardian.com/world/2019/apr/20/jordan-peterson-slavoj-zizek-happiness-capitalism-marxism --&gt;
&lt;!-- https://www.currentaffairs.org/2019/04/live-commentary-on-the-zizek-peterson-debate --&gt;
      </description>
      <pubDate>2019-05-17T22:00:00.000Z</pubDate>
      <link>http://norswap.com/zizek-peterson</link>
      <guid isPermaLink="true">http://norswap.com/zizek-peterson</guid>
    </item>
    <item>
      <title>One Year of Weightlifting</title>
      <description>
&lt;p&gt;Previously: &lt;a href=&quot;/weight-training&quot;&gt;Starting Weight Training&lt;/a&gt;, &lt;a href=&quot;/weight-training-2&quot;&gt;More Weightlifting
Observations&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Been lifting for more than one year now! So what&amp;#39;s new compared to last time?&lt;/p&gt;
&lt;p&gt;The last post ended in me saying training got me tired and switching to training
only twice a week instead of three. This ended up lasting a bit less than three
months until early-January, and in retrospect, it was a mistake. I probably
should have done some kind of &lt;a href=&quot;https://builtwithscience.com/deload-week/&quot;&gt;deload week&lt;/a&gt; instead and (a) eaten more, (b)
slept more. More on this later. It&amp;#39;s not entirely borne out in the data, but
that period felt like a slog in terms of progress.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;progress.png&quot; alt=&quot;Graph of weight lifted over time.&quot;&gt;&lt;/p&gt;
&lt;p&gt;There is about two weeks of data missing between that graph and &lt;a href=&quot;/weight-training-2#progression&quot;&gt;the
last&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;What else can be seen there? The 160kg squat is my new elusive nemesis. My max
is once 2x157.5kg currently. Deadlift stalled at 160kg for a bit, but then took
off. I finally broke 100kg on the bench press.&lt;/p&gt;
&lt;h1 id=&quot;revamped-program&quot;&gt;Revamped Program&lt;/h1&gt;
&lt;p&gt;I finally changed my program! Or more properly, extended it. Previously, I&amp;#39;d
been running classical &lt;a href=&quot;https://stronglifts.com/5x5/&quot;&gt;Stronglifts&lt;/a&gt; which had two workouts: squat, bench press
and barbell row for workout A; squat again, overhead press and deadlift for
workout B. What I did was drop the barbell row altogether (I described my
frustration with it &lt;a href=&quot;/weight-training-2&quot;&gt;last time&lt;/a&gt; and it did return), and drop the squat from
workout B.&lt;/p&gt;
&lt;p&gt;To supplement this, I integrated exercises from Jeremy Ethier&amp;#39;s &lt;a href=&quot;https://builtwithscience.com/best-full-body-workout/&quot;&gt;full body
workout&lt;/a&gt;, excepted the &amp;quot;High to Low Cable Flies&amp;quot; — couldn&amp;#39;t fit it in
the schedule and this requires two cables systems, which tend to be fairly busy
machines.&lt;/p&gt;
&lt;p&gt;I effected this change at around the start of March, as you can see from the row
disappearing from the graph above. There is also a correlation with the deadlift
finally taking off.&lt;/p&gt;
&lt;p&gt;To track the new workout, I&amp;#39;m using (in addition to the Stronglifts app) an app
called &lt;a href=&quot;https://play.google.com/store/apps/details?id=com.selahsoft.workoutlog&quot;&gt;Simple Workout Log&lt;/a&gt;. I&amp;#39;m afraid it doesn&amp;#39;t generate a graph for all
exercises, and generating one per exercise would be unwieldy however.&lt;/p&gt;
&lt;p&gt;The workout is more body-building oriented than my previous strictly
power-lifting routine. Except for the barbell row, all the Stronglifts lifts
(the &amp;quot;big lifts&amp;quot;) also appear in the new workout. For them I kept the
Stronglifts progression and the focus on lifting heavy. For the other exercises
however I used Jeremy&amp;#39;s guideline.&lt;/p&gt;
&lt;p&gt;The result was increased volume. I finally look somewhat obviously muscular.
Although a lot of that had to do with nutrition.&lt;/p&gt;
&lt;h1 id=&quot;nutrition--measurements&quot;&gt;Nutrition &amp;amp; Measurements&lt;/h1&gt;
&lt;p&gt;In January, I started actively tracking both my calorie expenditure (with a
&lt;a href=&quot;https://www.fitbit.com/be/charge2&quot;&gt;Fitbit Charge 2&lt;/a&gt; that was actually loaned to me by my colleague Sana for
data-mining purposes) and my calorie expenses (using the &lt;a href=&quot;https://play.google.com/store/apps/details?id=com.myfitnesspal.android&quot;&gt;MyFitnessPal&lt;/a&gt; app,
just like about everybody).&lt;/p&gt;
&lt;p&gt;The goal was to eat more to enable gains. My objective was to try to reach 3200
calories every day, and 3600 up to 4000 on workout days.&lt;/p&gt;
&lt;p&gt;That (later and the workout change outlined above) worked nicely in enabling
some further mass gains.&lt;/p&gt;
&lt;p&gt;I also bought a smart scale, but I&amp;#39;m not that happy with it. It&amp;#39;s accurate on
weight, but the bodyfat percentage given is wildly off: it has me at 13% which
would have me quite ripped — a more accurate scale gives 17%, which is in line
with picture references. Still, it can tell you if you&amp;#39;re trending up or down
and some indication of the magnitude. Here&amp;#39;s &lt;a href=&quot;https://www.amazon.fr/gp/product/B07GWCC412/&quot;&gt;what I bought&lt;/a&gt; so you can avoid
it. The more accurate scale is a big one at the gym. Apparently you have to look
for &amp;quot;dual frequencies&amp;quot; scales, but I couldn&amp;#39;t find any.&lt;/p&gt;
&lt;p&gt;I did get a lot of mileage out of a &lt;a href=&quot;https://www.amazon.fr/gp/product/B07BMNDW7F&quot;&gt;kitchen scale&lt;/a&gt; however, in order to get
more correct inputs into MyFitnessPal.&lt;/p&gt;
&lt;h1 id=&quot;next-up-cutting&quot;&gt;Next Up: Cutting&lt;/h1&gt;
&lt;p&gt;The next step is already underway: I&amp;#39;m going to &amp;quot;cut&amp;quot; to reduce bodyfat and
obtain the sacro-sanct six pack.&lt;/p&gt;
&lt;p&gt;I probably could have gained some more, but now feels like a nice time to try to
achieve this milestone, while I&amp;#39;m finishing my PhD and still have flexibility in
my schedule. It&amp;#39;s always harder to do something on the first go, as there are
things to figure out, and mistakes will necessarily be made.&lt;/p&gt;
&lt;p&gt;I&amp;#39;ve been easing into it for three weeks, and early signs are encouraging.
However, a full discussion will have to wait for later!&lt;/p&gt;
      </description>
      <pubDate>2019-05-11T22:00:00.000Z</pubDate>
      <link>http://norswap.com/weight-training-3</link>
      <guid isPermaLink="true">http://norswap.com/weight-training-3</guid>
    </item>
    <item>
      <title>Getting Youtube Transcripts</title>
      <description>
&lt;p&gt;Here&amp;#39;s a neat trick I just found out about: You can &lt;a href=&quot;https://ccm.net/faq/40644-how-to-get-the-transcript-of-a-youtube-video&quot;&gt;request the transcript&lt;/a&gt; of a
YouTube video that has captions by going to More &amp;gt; Transcript.&lt;/p&gt;
&lt;p&gt;Reading the transcript is often a nice alternative to sitting through a video of
someone talking, even in x2.&lt;/p&gt;
&lt;p&gt;Unfortunately, it&amp;#39;s still impossible to request automatic captionning for videos
where the author didn&amp;#39;t enable it. I wish they&amp;#39;d change that.&lt;/p&gt;
      </description>
      <pubDate>2019-05-11T22:00:00.000Z</pubDate>
      <link>http://norswap.com/youtube-transcripts</link>
      <guid isPermaLink="true">http://norswap.com/youtube-transcripts</guid>
    </item>
    <item>
      <title>Streaming Music From Phone to Computer</title>
      <description>
&lt;p&gt;I keep my full music library (50+ GB of music) synced with the external SD card
on my (Android) phone. Occasionaly, it is handy to stream music to a computer.
Notably, my work laptop only has a 256GB of disk, so streaming lets me save
space, not to mention avoid syncing pains.&lt;/p&gt;
&lt;p&gt;It&amp;#39;s not incredibly obvious how to do this however, even after some quick
googling. Hence this post.&lt;/p&gt;
&lt;h2 id=&quot;the-simple-solution&quot;&gt;The Simple Solution&lt;/h2&gt;
&lt;p&gt;This works well on home wifi networks.&lt;/p&gt;
&lt;p&gt;We&amp;#39;re going to use the DLNA/UPnP protocols to stream from our phone to a computer.&lt;/p&gt;
&lt;p&gt;On my (Android) phone, I use the &lt;a href=&quot;https://play.google.com/store/apps/details?id=com.findhdmusic.app.upnpcast&quot;&gt;Hi-Fi Cast&lt;/a&gt; app. It&amp;#39;s basically a music player
with the ability to stream to media servers (including &lt;a href=&quot;https://en.wikipedia.org/wiki/Chromecast&quot;&gt;Chromecast&lt;/a&gt;, which is
also handy to stream to TVs).&lt;/p&gt;
&lt;p&gt;On the computer, you&amp;#39;ll need to install &lt;a href=&quot;https://kodi.tv/&quot;&gt;Kodi&lt;/a&gt;. Normally, Kodi is used more to
stream from the computer to other devices (typically a Smart TV) but here we
want to stream &lt;strong&gt;to&lt;/strong&gt; Kodi. This is going to take some simple configuration.&lt;/p&gt;
&lt;p&gt;We&amp;#39;re going to follow the instructions from &lt;a href=&quot;https://kodi.wiki/view/UPnP/Client&quot;&gt;here&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;To turn on XBMC&amp;#39;s UPnP client, in Kodi go to Settings -&amp;gt; Services -&amp;gt; UPnP and
enable &amp;quot;Allow control of Kodi via UPnP&amp;quot;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Note you need to be at least in &amp;quot;Standard&amp;quot; configuration mode (not &amp;quot;Basic&amp;quot;) to
do this, and enabling UPnP (on the same page) is a pre-requisite.&lt;/p&gt;
&lt;p&gt;Aside: If you&amp;#39;d like to stream from your computer to your phone &lt;em&gt;while picking what to
play from your phone&lt;/em&gt;, you can enable &amp;quot;Share my libraries&amp;quot; (you need to import
some media into Kodi, otherwise this is useless).&lt;/p&gt;
&lt;p&gt;Now, in Hi-Fi cast go to the menu -&amp;gt; Playback Devices. Your computer should
appear with the name &amp;quot;Kodi (&amp;lt;computer name&amp;gt;)&amp;quot;. Select it and enjoy streaming
to your computer.&lt;/p&gt;
&lt;p&gt;What if it doesn&amp;#39;t work? There might be some OS configuration options to set.
In particular, on Windows, &amp;quot;Control Panel -&amp;gt; Network and Sharing Center -&amp;gt;
Advanced sharing settings -&amp;gt; Media Streaming&amp;quot; might be relevant.&lt;/p&gt;
&lt;p&gt;Another class of issues relate to the network you&amp;#39;re on. If you have control of
the network configuration (i.e. the configuration of your internet router) and
are technically literate, you can try to see if there is anything fishy going on
there.&lt;/p&gt;
&lt;p&gt;I wanted to stream my music not only at home, but also at work, where this naive
setup didn&amp;#39;t work. Making it work there is the object of the next section.&lt;/p&gt;
&lt;h2 id=&quot;streaming-on-restricted-networks&quot;&gt;Streaming on Restricted Networks&lt;/h2&gt;
&lt;p&gt;I wanted to stream my music at work (I work at a University). The simple
solution didn&amp;#39;t work. Obviously, the network had some kind of restriction on
protocols or ports being used.&lt;/p&gt;
&lt;p&gt;After &lt;a href=&quot;https://forum.kodi.tv/showthread.php?tid=341162&quot;&gt;some advanced investigation foo&lt;/a&gt;, I managed to figure out
the problem.&lt;/p&gt;
&lt;p&gt;Basically, the auto-discovery protocol was blocked on the campus network. Which
is quite understanble really — I can imagine some kind of broadcasting is
involved, which isn&amp;#39;t optimal when you&amp;#39;re tight on bandwidth.&lt;/p&gt;
&lt;p&gt;The solution is then to directly input the address of the playback device (the
computer&amp;#39;s IP address + the port on which Kodi listens for incoming streams),
which is supported by Hi-Fi cast (under &amp;quot;Playback Devices&amp;quot;, select the drop-down
(&amp;quot;...&amp;quot;) menu and then &amp;quot;Add UPnP Renderer&amp;quot;).&lt;/p&gt;
&lt;p&gt;But what is this address? That&amp;#39;s where I had to &lt;a href=&quot;https://forum.kodi.tv/showthread.php?tid=341162&quot;&gt;investigate&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Ultimately I ended up scanning my machine (a Mac) for listening ports by running
the command &lt;code&gt;sudo lsof -i -n -P | grep TCP&lt;/code&gt;. This turned out that Kodi was
listening on 1912, 1655, and 9090, with 1655 being the one we are interested in.&lt;/p&gt;
&lt;p&gt;The renderer address to add to Hi-Fi Cast is thus &lt;code&gt;http://&amp;lt;ip&amp;gt;:1655/&lt;/code&gt;. The IP
address should be the local one (on campus we actually have public IPs!).&lt;/p&gt;
&lt;p&gt;You can find your local IP (probably you want IPv4 — something like
&amp;quot;192.168.0.42&amp;quot;) by running &lt;code&gt;ifconfig&lt;/code&gt; on Mac and looking for &amp;quot;en0&amp;quot;. On Windows,
run &lt;code&gt;ipconfig /all&lt;/code&gt; and look for &amp;quot;Local Area Connection&amp;quot;.&lt;/p&gt;
&lt;h2 id=&quot;alternatives&quot;&gt;Alternatives&lt;/h2&gt;
&lt;p&gt;If that doesn&amp;#39;t work, an alternative is to set up some kind of server on your
phone to serve files, and to connect to it with your computer.&lt;/p&gt;
&lt;p&gt;I used the excellent &lt;a href=&quot;https://play.google.com/store/apps/details?id=com.icecoldapps.serversultimate&amp;amp;hl=en&quot;&gt;Servers Ultimate&lt;/a&gt; app for this (it&amp;#39;s a trial and costs 9€
after that — it&amp;#39;s probably possible to fish for alternatives though!).&lt;/p&gt;
&lt;p&gt;Two kind of servers that work are &amp;quot;FTP Server&amp;quot; (not native nor proxy!) and
&amp;quot;WebDAV Server&amp;quot;. I ran them with the default options, on ports 2121 and 8484
(respectively). Of the two, FTP worked on both Windows and Mac while I couldn&amp;#39;t
get WebDAV to work on Windows.&lt;/p&gt;
&lt;p&gt;(In case you&amp;#39;d be tempted to try an SMB server, don&amp;#39;t. Unless your device is
rooted, you can&amp;#39;t select the default port (455) because Android forbids
listening on ports in the 0-1024 range. Windows (and apparently, Linux?) won&amp;#39;t
be able to connect to it. Mac is reported to work, but it didn&amp;#39;t work for me
with Servers Ultimate... It did work with &lt;a href=&quot;https://play.google.com/store/apps/details?id=fr.webrox.landrive&quot;&gt;another app&lt;/a&gt; though, but I still had
issues. I think I had to create user accounts, and the Mac wouldn&amp;#39;t disconnect
the network share, I had to issue a &lt;a href=&quot;https://apple.stackexchange.com/questions/256209/&quot;&gt;&lt;code&gt;umount&lt;/code&gt; command&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;Don&amp;#39;t forget to change the directory you want to share — you probably don&amp;#39;t want
to make your whole phone accessible, esp. if you&amp;#39;re not gonna set a password.&lt;/p&gt;
&lt;p&gt;I wanted to share a directory on my SD card, and for that I had to find its
exact path (which you can do using a disk usage application like &lt;a href=&quot;https://play.google.com/store/apps/details?id=com.mobile_infographics_tools.mydrive&quot;&gt;this
one&lt;/a&gt;). For me the SD card was at &lt;code&gt;/storage/0000-0000&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Once the server is running you can access it by typing its address + port in the
Explorer address bar. e.g. &lt;code&gt;ftp://192.168.0.101:2121/&lt;/code&gt; for FTP. On Mac, in the
Finder you need to do &amp;quot;Go &amp;gt; Connect to Server...&amp;quot; and enter the same thing.&lt;/p&gt;
&lt;p&gt;For WebDav, on Mac you use &lt;code&gt;http&lt;/code&gt; (or &lt;code&gt;https&lt;/code&gt; if you use SSL): e.g.
&lt;code&gt;http://192.168.0.101:8484/&lt;/code&gt;. I couldn&amp;#39;t make it work on Windows, but in theory
you&amp;#39;d type &lt;code&gt;\\192.168.0.101@8484\DavWWWRoot\&lt;/code&gt; (the last part is important and is
a special Windows keyword). If you use SSL, you need to write
&lt;code&gt;\\192.168.0.101@SLL@8484\DavWWWRoot\&lt;/code&gt; instead. &lt;a href=&quot;https://www.webdavsystem.com/server/access/windows/&quot;&gt;More instructions
here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;And that&amp;#39;s it — happy listening!&lt;/p&gt;
      </description>
      <pubDate>2019-04-28T22:00:00.000Z</pubDate>
      <link>http://norswap.com/stream-from-phone</link>
      <guid isPermaLink="true">http://norswap.com/stream-from-phone</guid>
    </item>
    <item>
      <title>Even More Anime</title>
      <description>
&lt;p&gt;Previously: &lt;a href=&quot;/every-anime/&quot;&gt;Every Anime I Ever Watch&lt;/a&gt;, &lt;a href=&quot;/more-anime/&quot;&gt;More Anime I Watched&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This time: even more anime. And actually, one or two live-action TV shows that
have nothing to do with anime. And two animated movies.&lt;/p&gt;
&lt;h2 id=&quot;gurren-lagann-the-movie-childhoods-end&quot;&gt;Gurren Lagann The Movie: Childhood&amp;#39;s End&lt;/h2&gt;
&lt;p&gt;Gurren Lagann is &lt;a href=&quot;/gurren-lagann-reaction/&quot;&gt;GREAT&lt;/a&gt;, however I see no reason to watch this movie instead of
the show, who does a much better job of conveying the emotions and the
characters.&lt;/p&gt;
&lt;p&gt;This first movie covers episodes 1-14 of the show (out of 27, the 16th  being a
compilation episode). Maybe it&amp;#39;s too much to squish in a 1 hour 50 movie.&lt;/p&gt;
&lt;p&gt;Time is saved in two major ways. First by eliding everything that happens
between Gurren Lagann&amp;#39;s first fight and the fights against Lordgenome&amp;#39;s
generals. This is when most of the companions are met and introduced. In
particular, I found it questionable to leave out the part about Rossiu&amp;#39;s
village, which is important background for an important character later down the
line. It makes the character and by extension the story slightly less
interesting.&lt;/p&gt;
&lt;p&gt;Similarly, it&amp;#39;s hard to relate to — or even get to enjoy — most characters when
there are so many of them and they have so little screen time in the movie. Even
regarding the main characters, the transition from key event to key event feels
jarring. The stitching shows.&lt;/p&gt;
&lt;p&gt;Second, the different general fights have been merged into one big fight. While
it&amp;#39;s quite well done, I kind of like the slower pacing of the show here. Simon&amp;#39;s
recovery was more subtle, and the next few fight see him really come into his
own, culminating in his fight against Lordgenome... which is not shown in this
movie. Like, WHAT? Why? Seeing as there is a multiple years time-leap after this
fight, wouldn&amp;#39;t it have been perfect to end on it. It is the culmination of the
journey after all.&lt;/p&gt;
&lt;p&gt;Seeing this, I didn&amp;#39;t bother with the second movie.&lt;/p&gt;
&lt;p&gt;So yeah. Watch the show instead.&lt;/p&gt;
&lt;h2 id=&quot;my-hero-academia-season-3&quot;&gt;My Hero Academia Season 3&lt;/h2&gt;
&lt;p&gt;As &lt;a href=&quot;/more-anime/#my-hero-academia&quot;&gt;previously reviewed&lt;/a&gt;, this is as great as ever. The quality is consistent.
The All Might fight in particular is fantastic. The season doesn&amp;#39;t end on a very
high beat moment, but the ride was great.&lt;/p&gt;
&lt;h2 id=&quot;my-hero-academia-two-heroes&quot;&gt;My Hero Academia: Two Heroes&lt;/h2&gt;
&lt;p&gt;This is a movie that came out during the airing of season 3.&lt;/p&gt;
&lt;p&gt;I really have nothing special to say here. It&amp;#39;s Hero Academia, it&amp;#39;s great. Of
course it is.&lt;/p&gt;
&lt;h2 id=&quot;attack-on-titans-season-3-part-1&quot;&gt;Attack on Titans Season 3 (Part 1)&lt;/h2&gt;
&lt;p&gt;Previously: &lt;a href=&quot;/every-anime/#attack-on-titan&quot;&gt;Season 1&lt;/a&gt; and &lt;a href=&quot;/more-anime/#attack-on-titan-season-2&quot;&gt;Season 2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Haven&amp;#39;t much to add. Season 3 diggs even deeper in the story and shed light on
some of the mysteries in the series. I did perceive it to be less
entertaining/gripping than the first two season, but it&amp;#39;s high quality all the
same.&lt;/p&gt;
&lt;p&gt;I enjoyed that we get to know more and more about the titans, the universe, and
how it came to be this way. Looks like we&amp;#39;ll learn even more in the second part
of the season, which starts airing at the end of the month.&lt;/p&gt;
&lt;h2 id=&quot;steinsgate-0&quot;&gt;Steins;Gate 0&lt;/h2&gt;
&lt;p&gt;Steins;Gate 0 explore an alternative timeline starting near the end of
&lt;a href=&quot;/more-anime/#steins-gate&quot;&gt;Steins;Gate&lt;/a&gt;. What if things didn&amp;#39;t go down the way they did?&lt;/p&gt;
&lt;p&gt;It&amp;#39;s less good than the original in my estimation, but nonetheless great. I was
very touched by how ragged Okabe becomes, how his decisions weigh on him.&lt;/p&gt;
&lt;p&gt;My problem with the season is that there is comparatively less &amp;quot;plot&amp;quot; going on,
with a lot being crammed towards the end, which feels less alive with emotion by
virtue of being more dense. On the other hand, the emotions really have time to
breathe at the start and that&amp;#39;s where the series shines, but more could be
happening.&lt;/p&gt;
&lt;p&gt;That being said, if you liked the original, you&amp;#39;ll probably like this one too.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=jyODPI_hTRE&amp;amp;lc=UgxN9D23nHdNNHKMghR4AaABAg&quot;&gt;Digi hates it, I disagree&lt;/a&gt; (scroll to see my comment).&lt;/p&gt;
&lt;p&gt;If you don&amp;#39;t remember what happened in the original Steins;Gate (it gets
confusing), &lt;a href=&quot;https://www.youtube.com/watch?v=EIDKmhzjD_Y&quot;&gt;this video&lt;/a&gt; will explain everything you need to know.&lt;/p&gt;
&lt;h2 id=&quot;rezero&quot;&gt;Re:Zero&lt;/h2&gt;
&lt;p&gt;Another Isekai. This time the protagonist comes back to life some time in the
past when he dies.&lt;/p&gt;
&lt;p&gt;The first episode is a two-parter, and the first part meanders a bit, but a few
episodes in and it really gets kicking.&lt;/p&gt;
&lt;p&gt;I ended up enjoying the show immensely. I liked being surprised by the
directions things took - and was thankful that the relative strength of the
power wasn&amp;#39;t abused via loads of scheming and computations.&lt;/p&gt;
&lt;p&gt;The show has a large and colorful cast, but unlike Overlord, the characters feel
like they have a place in the plot, something to do, to say, and a more distinct
personality. The villains are also particularly cool.&lt;/p&gt;
&lt;p&gt;I also found the struggles of the protagonist touching, despite his motivations
being somewhat surprising.&lt;/p&gt;
&lt;p&gt;I wouldn&amp;#39;t call this a masterpiece, but it&amp;#39;s still japanimation at its best:
weird, entertaining, yet relatable and occasionally touching.&lt;/p&gt;
&lt;h2 id=&quot;overlord-season-3&quot;&gt;Overlord Season 3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/more-anime#overlord&quot;&gt;First two seasons reviewed here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I was far from enthused by the start of the season. Againt we&amp;#39;re in the less
relevant arcs, this time with extra goblins. There is at least one episode that
is a full-on awful conversation/exposition dump with not even so much useful
info. Ugh. So I dropped it after 5 or 6 episodes.&lt;/p&gt;
&lt;p&gt;But then my brother nagged me that I became awesome, and boy was he right. But
not in the conventional way. I have two words for you: bad CG. Really really
really bad CG. Copy pasted animations. Actual goat sounds.&lt;/p&gt;
&lt;p&gt;Overlord sorts of jumps the shark, and its great entertainment. I certainly
don&amp;#39;t care about the plot in a first-degree manner anymore, however.&lt;/p&gt;
&lt;p&gt;Speaking of plot, there is more than CG and just bad storytelling all-around to
murder it. The final nail in its coffin is what I feel is a complete reversal of
personality from the lead character Ainz Ooal Gown. In the past, he was
&amp;quot;officially&amp;quot; evil but actually never does anything really bad, and often does go
the extra mile to help people. But suddently, he&amp;#39;s gleefully murdering everyone
without so much as the hint of a reason for the change.&lt;/p&gt;
&lt;p&gt;I&amp;#39;ll watch the next season, and I hope the WTF will keep rolling in.&lt;/p&gt;
&lt;h2 id=&quot;the-darling-in-the-franxx&quot;&gt;The Darling in the Franxx&lt;/h2&gt;
&lt;p&gt;What if Evangelion and Gurren Lagann had a love child? I think it would look a
lot like this.&lt;/p&gt;
&lt;p&gt;The basic pitch: in the future, kids are being raised to pilot mechas in
male-female pairs, in order to defend against &lt;em&gt;Klaxosaurs&lt;/em&gt;, a sort of
mecha-aliens emerging from the center of the earth. The story follows squad 13,
and Zero Two, an elite mecha pilot with a very special background, who develops
a very special bond to Hiro, a member of the squad. One of the main theme of the
show is puberty, in a society where it (along with sexuality) has disappeared.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Darling_in_the_Franxx&quot;&gt;More here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I thought it was great.&lt;/p&gt;
&lt;p&gt;The show is not perfect however. It&amp;#39;s not subtle for one, and all the character
development is pretty much on the nose. Yet it works nicely. There is tremendous
character development for one, accross the whole cast for two.&lt;/p&gt;
&lt;p&gt;The cast is large but I liked how the show spent time on all its main
characters. There is also some planning done so that character development
doesn&amp;#39;t happen in one episode but the seeds are planted earlier done. You do see
it coming from far away, but it&amp;#39;s solid.&lt;/p&gt;
&lt;p&gt;I&amp;#39;m gonna veer into very very slightly spoilery territory now (no plot points
are revealed, but the general tendency of the story to e.g. go well, go bad, etc
is).&lt;/p&gt;
&lt;p&gt;I liked how there was no &amp;quot;ping-ponging&amp;quot; in character development, something I
was really expecting, especially regarding Zero Two. This kind of ping-pong is
so overused it feels like a cliche, and it&amp;#39;s difficult to employ it well. Even
places where it is used interestingly, it&amp;#39;s not always enjoyable: for instance
in Evangelion, it&amp;#39;s thoughtful (because depression), but it did diminish my
enjoyment of the show.&lt;/p&gt;
&lt;p&gt;My friend Gorby told me the show was great until the last three episodes that
ruined it. And I had read the show &amp;quot;nuked the fridge&amp;quot; at some point. This
actually made me more curious. Well, from my perspective, this didn&amp;#39;t happen at
all. Sure, the end broadens the stakes (in a way reminiscent of a certain other
show...), but thematically, it stays consistent and I wasn&amp;#39;t disappointed.&lt;/p&gt;
&lt;h2 id=&quot;the-man-in-the-high-castle-season-3&quot;&gt;The Man in The High Castle Season 3&lt;/h2&gt;
&lt;p&gt;Ah, our first non anime-show review!&lt;/p&gt;
&lt;p&gt;The Man in The High Castle isn&amp;#39;t my all-time top-pick for a TV show. In fact,
I&amp;#39;m a bit of two minds about it, but I will say that its strength are enough to
carry it.&lt;/p&gt;
&lt;p&gt;The premise is very strong: the story takes place in the 60s, but in a parralel
universe where Germany and Japan won World War 2 and are now the only two global
powers. They also split the United States (because who cares about the rest of
the world, lol) in two, with the Japanese inheriting the west coast and the
German everything east of the rockies. The rockies themselves are in a &amp;quot;neutral
zone&amp;quot; which I assume exists for reasons of extreme plot convenience.&lt;/p&gt;
&lt;p&gt;The Man in The High Castle is a weird show in that it is its antagonists that
are actually the star of the show. With a few exceptions, I really couldn&amp;#39;t
really care less about the &amp;quot;good guys&amp;quot; (who come at odds with Japanese and
Nazis, including a resistance movement), who are at times antipathic, and most
of the time pathetic.&lt;/p&gt;
&lt;p&gt;It&amp;#39;s &amp;quot;villains&amp;quot; however, are fascinating. The first, trade minister Tagomi,
isn&amp;#39;t really a villain so much as a good guy in a government that has
questionable ethical practices. But he does advocate for doing what we&amp;#39;d call
&amp;quot;the right thing&amp;quot; whenever he has the chance.&lt;/p&gt;
&lt;p&gt;The second, chief inspector Kido, is almost Tagomi&amp;#39;s polar opposite. He&amp;#39;s almost
ruthless to a fault, yet the show still manages to give him a human figure. Joel
de la Fuentes&amp;#39; peformance is incredible here, from his clippy delivery to the
skin-deep tension he exudes.&lt;/p&gt;
&lt;p&gt;The third baddie however, is the show&amp;#39;s crowning jewel: SS chief John Smith,
played by a Rufus Sewell at the top of his art (if you haven&amp;#39;t seen &lt;a href=&quot;https://en.wikipedia.org/wiki/Dark_City_(1998_film)&quot;&gt;Dark City&lt;/a&gt;
— a sci-fi movie where he stars — I highly recommend it).&lt;/p&gt;
&lt;p&gt;This is the mosts interesting character of the show, and also the most
conflicted. A former American military man, he changes sides when it&amp;#39;s clear the
Germans cannot be stopped (they invented nuclear weapons first and wiped out
Washington). While never really overjoyed with Nazi policy, he nevertheless goes
up the ranks as a competent man who&amp;#39;ll do whatever it takes to preserve order.
However the show showcases a series of events (notably with regards to his son)
that causes him to question the orthodoxy.&lt;/p&gt;
&lt;p&gt;This could easily go trite, but it doesn&amp;#39;t. John Smith doesn&amp;#39;t have a sudden
change of heart. He&amp;#39;s lost, but continues to do what he knows. He&amp;#39;s definitely a
bad guy, but at the same time, he&amp;#39;s human too.&lt;/p&gt;
&lt;p&gt;So far, I&amp;#39;d say that each season has been better than the previous one. In
particular, the last (third) season finally seems to embrace the aforementioned
character as the interesting locus of the story. I&amp;#39;m eager to see what will
happen next...&lt;/p&gt;
&lt;h2 id=&quot;goblin-slayer&quot;&gt;Goblin Slayer&lt;/h2&gt;
&lt;p&gt;Goblin Slayer was a surprise. The show was being hyped as extremely edgy, and
the first episode made a strong impression in that sense, featuring a jarring
(by anime standards) rape scene.&lt;/p&gt;
&lt;p&gt;But after, it calmed a whole lot — I&amp;#39;m not easily shocked and found it all
mostly tame. Even in anime, Devilman Crybaby (which I haven&amp;#39;t watched (yet?))
does seems to be much much more graphic. To be sure, this is still not a cute
slice of life anime, but you&amp;#39;ve been to the movies before, haven&amp;#39;t you? If
splurging blood bothers you, then this is definitely not for you though.&lt;/p&gt;
&lt;p&gt;Nevertheless, the surprise was that the story actually held up. The premise — a
hero with a cold demeanor that focuses on slaying gobling because of a personal
grudge — was looking more like an excuse for exposition than anything else.&lt;/p&gt;
&lt;p&gt;There isn&amp;#39;t a huge overarching narrative in this first season, but you get to
learn about the characters in an interesting way. The small arcs are engaging,
tension being built in the right place. The combat is dynamic, and you&amp;#39;ll
hopefully appreciate the imagination deployed in the task of slaying goblins.&lt;/p&gt;
&lt;p&gt;In a certain sense, Gobling Slayer did everything right that the third season of
Sword Art Online did wrong, but we&amp;#39;ll talk about that later.&lt;/p&gt;
&lt;h2 id=&quot;psycho-pass&quot;&gt;Psycho-Pass&lt;/h2&gt;
&lt;p&gt;I watched the two seasons of Psycho-Pass. It came highly recommend, but the word
I come from multiple people was that the first season was much better. I
actually thought the second season held up pretty well, even if the first still
has my preference. But more about that later.&lt;/p&gt;
&lt;p&gt;The premise of Psycho-Pass is that in modern-day Japan, people have their
psychological score (a &amp;quot;hue&amp;quot;) and &amp;quot;crime coefficient&amp;quot; monitored. The hue
determines potential in society (along with other psychological assessments),
and the police simply prosecutes people whose crime coefficient crosses a
certain threshold. The show follows a newly minted inspector — Akane Tsunemori —
as she, you guessed it, comes to grapple with the ethics of this dystopian
system.&lt;/p&gt;
&lt;p&gt;The show is wonderful, and you simply have to watch it if you like both sci-fi
and anime. The mood veers slightly Noir and reminded me of Cowboy Bebop a bit
(however, less stylish, but — blessedly — without the slapstick comedy). The
show also has some more philosophical undertones, with big questions being
discussed by the protagonists and many books and philosophers being referenced
throughout the series.&lt;/p&gt;
&lt;p&gt;Regarding the second season, I felt the absence of one of the protagonists of
the first season made quite a bit of difference to the overall mood, and a new
protagonist tends to be too annoying for too long with very little in terms of
closure offered. The villain is also less well-matched to our heros, which makes
the dynamic slightly less interesting.&lt;/p&gt;
&lt;p&gt;On the other hand, the story and the action holds up pretty well. It&amp;#39;s still
really good, but there&amp;#39;s always a cost of following something really great.&lt;/p&gt;
&lt;p&gt;Personally, I really enjoyed seeing the evolution of Akane as a character, and
the second season certainly has something to contribute in that story, somewhat
similarly to Okabe in Steins;Gate 0.&lt;/p&gt;
&lt;h2 id=&quot;briefly-zombie-land-saga--sakamoto-desu-ga&quot;&gt;Briefly: Zombie Land Saga &amp;amp; Sakamoto Desu Ga&lt;/h2&gt;
&lt;p&gt;Here are two shows I watched briefly but dropped after 3 or 4 episodes each.&lt;/p&gt;
&lt;p&gt;Zombie Land Saga is about a guy that resurrect a motley crew of zombie girl in
order to make an idol group to revitalize the Japanese region of Saga. The idea
ain&amp;#39;t bad and there are some funny moments, but I personally found it less
amusing than most (I think I&amp;#39;m maybe just not into anime comedy?). Some really
bad immersion-breaking CG and some boilerplate bullshit anime drama convinced me
to call it quits fairly early.&lt;/p&gt;
&lt;p&gt;I liked Sakamoto Desu Ga (english: &amp;quot;Haven&amp;#39;t you heard? I&amp;#39;m Sakamoto&amp;quot;) much
better. It&amp;#39;s about Sakamoto, a dude that does everything &amp;quot;stylishly&amp;quot;. As the
recurring opening skit will tell you, he&amp;#39;s &lt;a href=&quot;https://www.youtube.com/watch?v=wP2kwMRNMNo&quot;&gt;cool, cooler, coolest&lt;/a&gt; (I&amp;#39;m sad I
couldn&amp;#39;t find the whole sequence, it&amp;#39;s well worth a watch).&lt;/p&gt;
&lt;p&gt;The gags are just so over the top, I think it really works. It didn&amp;#39;t really
hold my attention, but I&amp;#39;m probably going to go back and watch the remainder of
the episodes at some point, when I need something to empty my brain.&lt;/p&gt;
&lt;p&gt;As a teaser, here are two fun compilations of some fun sequences:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=p-RFry9i2Yo&quot;&gt;Sakamoto vs Teacher&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=7a_fSRahE88&quot;&gt;Sakamoto in America&lt;/a&gt; (probably
some kind of bonus)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;net-juu-no-susume-recovery-of-an-mmo-junkie&quot;&gt;Net-juu no Susume (Recovery of an MMO Junkie)&lt;/h2&gt;
&lt;p&gt;This anime is about a girl &lt;a href=&quot;https://en.wikipedia.org/wiki/NEET#Japan&quot;&gt;NEET&lt;/a&gt; who leaves her work to dedicate herself to
videogames. Romance happens.&lt;/p&gt;
&lt;p&gt;I&amp;#39;m surprised at how little I have to say about Net-juu no Susume... I really
enjoyed watching it. It&amp;#39;s not a masterpiece but it was a very comfortable anime
to me, and I don&amp;#39;t have much criticism to offer.&lt;/p&gt;
&lt;p&gt;Although... It was too short, probably. I would have liked seeing plotlines that
involves the actual game more. And there were just a tad too much happenstances.
Still recommended.&lt;/p&gt;
&lt;h2 id=&quot;sword-art-online-season-3-part-1&quot;&gt;Sword Art Online Season 3 (Part 1)&lt;/h2&gt;
&lt;p&gt;Sword Art Online has a special spot in my heart as the anime that rekindled my
interest in anime after I&amp;#39;d unfairly dismissed it in the past.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/every-anime/#sword-art-online&quot;&gt;Read my revious review of season 1 and 2.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The anime, is not perfect, and I can forgive much.&lt;/p&gt;
&lt;p&gt;That being said, this season is just plain and irremediably bad.&lt;/p&gt;
&lt;p&gt;Very mild spoilers beyond this point!&lt;/p&gt;
&lt;p&gt;I was on board with the premise: Kirito is once again in a virtual world he
can&amp;#39;t escape, except this time it&amp;#39;s an accelerated simulation and the people
he&amp;#39;s interacting with are actually advanced AIs. The world has grown a magic
system, where incantations are actually game system commands.&lt;/p&gt;
&lt;p&gt;This is cool. But then the anime starts slowly. So slowly. Then it finally hits
its strive somewhere towards the middle (the academy), where, if it doesn&amp;#39;t
manage to be amazing, it&amp;#39;s still failry SAO-esque and showcases interesting
drama.&lt;/p&gt;
&lt;p&gt;The last part is dogshit. The protagonists fight boss after boss in a series of
uninspired fights. It&amp;#39;s like Saint Seya&amp;#39;s golden knight arcs... except much much
worse.&lt;/p&gt;
&lt;p&gt;Consistency goes through the window. The ties/relevance to the system commands
and other system introduced is dubious if not forgotten entirely. Powers (and
power-ups) just happen as &amp;quot;fits&amp;quot; the story... which isn&amp;#39;t even that good.&lt;/p&gt;
&lt;p&gt;The animation is great... but damn, the timing of the scenes doesn&amp;#39;t make sense!
Characters, both heroes and villains, just say standing and talking when
fighting would offer them an overwhelming tactical advantage. Just spouting
inane nonsense besides.&lt;/p&gt;
&lt;p&gt;Kirito actually spends a few (two?) years in the simulation... you&amp;#39;d think it
would be great to showcase how he experiences this, misses his friends and
Asuna? But no. Instead it&amp;#39;s about how noble he is and wants to save all the AIs.&lt;/p&gt;
&lt;p&gt;Anyway, by the end of the show (well, it&amp;#39;s only part one of this season) I was
thoroughly checked out. Even &amp;lt;&lt;em&gt;big emotional moment&lt;/em&gt;&amp;gt; didn&amp;#39;t affect me. I was
just really curious about whether it was a bluff or not.&lt;/p&gt;
&lt;p&gt;So yeah. Hopefully the second half is better, but I have doubts.&lt;/p&gt;
&lt;h2 id=&quot;that-time-i-got-reincarnated-as-a-slime&quot;&gt;That Time I Got Reincarnated as a Slime&lt;/h2&gt;
&lt;p&gt;This is an isekai in which the protoganist dies and gets reincarnated as a slime
(later christened Rimuru) in a game-like universe. But don&amp;#39;t worry — he&amp;#39;s actually
overpowered. He&amp;#39;s about as OP as Ainz Ooal Gown in Overlord.&lt;/p&gt;
&lt;p&gt;In fact, the comparison to Overlord is interesting. Both anime have a large cast
of unique characters, an overpowered leader, and are — narratively — not very
good.&lt;/p&gt;
&lt;p&gt;They&amp;#39;re different though. Overlord is sometimes quite interesting, sometimes
so-bad-it&amp;#39;s-good, and sometimes plain boring. Slime is much more consistent. It
is never &lt;em&gt;boring&lt;/em&gt; per se, but it is never &lt;em&gt;great&lt;/em&gt; either. It feels like as
though what should have been 3 or 4 episodes of setup was copied over 5 times
with different antagonists and called a season. The show mismanages its tension
by having only traces amount of it.&lt;/p&gt;
&lt;p&gt;I&amp;#39;m a story guy, and so I can only be critical of this.&lt;/p&gt;
&lt;p&gt;On the other hand, it&amp;#39;s not &lt;em&gt;bad&lt;/em&gt;. It certainly less bad than the last season of
Sword Art Online. It&amp;#39;s pretty. The characters are well designed and
good-natured. You can almost (almost) see it as a slice-of-life in a fantasy
world, where &amp;quot;life&amp;quot; is fighting the threat du jour (then making an ally out of
it).&lt;/p&gt;
&lt;p&gt;Another thing I got out of this one (and, it must be said, many of the anime on
this list) was dicussing it with good friends who were watching it as well.&lt;/p&gt;
&lt;p&gt;I&amp;#39;ll watch season 2 with curiosity, to see whether the show is set in its way or
if it can evolve into something more interesting. We sure have had enough setup
by now.&lt;/p&gt;
&lt;h2 id=&quot;the-promised-neverland&quot;&gt;The Promised Neverland&lt;/h2&gt;
&lt;p&gt;(This will spoil the premise, which is episode one!)&lt;/p&gt;
&lt;p&gt;An interesting show about a bunch of kids in an orphanage, which realize that
they&amp;#39;re being raised to feed some sort of demons living on the outside. The show
follow them planning their escape attempt.&lt;/p&gt;
&lt;p&gt;It&amp;#39;s a &amp;quot;battle of minds&amp;quot; show (think Death Note or Code Geass) but less
ludicrous than these two (at least, so far) and with also much less action (no
fancy mechas here).&lt;/p&gt;
&lt;p&gt;The anime also features a number of twists. Those are well done in the sense
that they don&amp;#39;t invalidate your prior expectations. You do sense something is
off and there will be something unexpected, you just don&amp;#39;t know what yet.&lt;/p&gt;
&lt;p&gt;It was well worth watching, but I wonder about rewatchability. I think on the
second way around the show must necessarily be somewhat boring, as the plot is
known and the show doesn&amp;#39;t really deliver strong emotion, action or beautiful
animation to compensate. In fact, I&amp;#39;d read the frist volume of the manga before
and as such, the first few episodes were somewhat boring to watch.&lt;/p&gt;
      </description>
      <pubDate>2019-04-21T22:00:00.000Z</pubDate>
      <link>http://norswap.com/even-more-anime</link>
      <guid isPermaLink="true">http://norswap.com/even-more-anime</guid>
    </item>
    <item>
      <title>Language Design Notes 1: A Precise Typeclass Scheme</title>
      <description>
&lt;p&gt;This is the second post in my &lt;strong&gt;&lt;a href=&quot;/language-design-notes/&quot;&gt;Language Design Notes&lt;/a&gt;&lt;/strong&gt; series.&lt;/p&gt;
&lt;p&gt;This instalment is a bit particular, as it outlines pretty precisely (though not
formally) a way to implement &lt;a href=&quot;https://en.wikipedia.org/wiki/Type_class&quot;&gt;typeclasses&lt;/a&gt; in an imaginary (and for the most
part, unspecified) language. Nothing much is assumed about the language — it
isn&amp;#39;t assumed to be purely functional for instance. The syntax is taken to look
a bit like Python (using significant indentation).&lt;/p&gt;
&lt;p&gt;Some context about why I wrote this, lifted from the the &lt;a href=&quot;/language-design-notes/&quot;&gt;series
index&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As I started thinking about typeclasses more, I found the need to write down
some form of specification of the system I was imagining, so that I could
refer to other parts of the design, and see if it was consistent.&lt;/p&gt;
&lt;p&gt;I found the need to be fairly precise. Or maybe I just got carried away... but
I think the precision really helps throw in relief the small details that
threaten the consistency and elegance of the whole. Anyhow, this ended up
looking more like a specification than a nice explanative article, although I
tried to include enough examples.&lt;/p&gt;
&lt;p&gt;It&amp;#39;s not perfect, but as &lt;a href=&quot;/more-content/&quot;&gt;discussed earlier&lt;/a&gt;, I want thing to move forward, so
here it is!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And that being said, let&amp;#39;s dive right in!&lt;/p&gt;
&lt;h2 id=&quot;declaring-typeclasses-and-instances&quot;&gt;Declaring Typeclasses and Instances&lt;/h2&gt;
&lt;p&gt;This is how you declare a single-parameter typeclass:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Serializable $T
    fun serialize (it: $T): String
    fun deserialize (str: String): $T&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;$T&lt;/code&gt; is a generic type. Generic types all start with a dollar sign. This makes
them easy to pick out and avoids namespace clashes with regular types. It also
dispenses us from declaring which types are generic separately. This is not a
problem for typeclass declarations, but it is for function declaration, where
generic types may be mingled with normal types.&lt;/p&gt;
&lt;p&gt;For instance, java lists the generic types before the function signature:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;T&amp;gt; String serialize (T it);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Haskell uses the scheme we propose, but with lowercase letters for generic
types. We&amp;#39;d like to keep lowercase letters for things in the domain of values,
while things in the domain of types are capitalized. (That being said, types
will also be first-class values in our language.)&lt;/p&gt;
&lt;p&gt;This is how you create an instance of a single-parameter typeclass for a type
called &lt;code&gt;Point&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;instance Serializable Point
    fun serialize (it: Point): String
        return it.x + &amp;quot;,&amp;quot; + it.y
    fun deserialize (str: String): Point
        val strs = str.split(&amp;quot;,&amp;quot;)
        return Point(parse_int(strs[0]), parse_int(strs[1]))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is how you declare a multiple-parameter typeclass:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;enum Order { BIGGER, EQUAL, SMALLER }

class Orderable $X $Y
    fun order (x: $X, y: $Y): Order&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is how you create an instance of a multiple-parameter typeclass for types
&lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Char&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;instance Orderable String Char
    fun order (x: String, y: Char): Order
        if x.size == 0
            return SMALLER
        if x[0] == y
            return x.size == 1 ? EQUAL : BIGGER
        else
            return x[0] &amp;gt; y ? BIGGER : SMALLER&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that both type parameters of &lt;code&gt;Orderable&lt;/code&gt; can be the same type:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;instance Orderable Int Int
    fun order (x: Int, y: Int): Order
        if (x &amp;gt; y) return BIGGER
        if (x &amp;lt; y) return SMALLER
        return EQUAL&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;instances-names&quot;&gt;Instances Names&lt;/h2&gt;
&lt;p&gt;Every instance must have a name. A subsequent section (&lt;a href=&quot;#picking-instances&quot;&gt;Picking
Instances&lt;/a&gt;) will explain why names are needed, but for the
moment bear with me.&lt;/p&gt;
&lt;p&gt;If a name is not given explicitly, it will be generated automatically. For
instance, our &lt;code&gt;Serializable&lt;/code&gt; instance for &lt;code&gt;Point&lt;/code&gt; will be called
&lt;code&gt;Serializable_Point&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can also give a name explicitly. Imagine we want to serialize points using
slashes (/) because of an obscure data format we use:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;instance PointSlash: Serializable Point
    fun serialize (it: Point): String
        return it.x + &amp;quot;/&amp;quot; + it.y
    fun deserialize (str: String): Point
        val strs = str.split(&amp;quot;/&amp;quot;)
        return Point(parse_int(strs[0]), parse_int(strs[1]))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(The definition is the same as &lt;code&gt;Serializable_Point&lt;/code&gt;, except the comma has been replaced by a
slash.)&lt;/p&gt;
&lt;p&gt;This instance will be called &lt;code&gt;PointSlash&lt;/code&gt;. It will not receive an automatically
generated name.&lt;/p&gt;
&lt;p&gt;The scheme to build automatic names for multiple-parameter typeclasses is what
you&amp;#39;d expect , e.g. &lt;code&gt;Orderable_Int_Int&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;deriving-typeclasses-automatically&quot;&gt;Deriving Typeclasses Automatically&lt;/h2&gt;
&lt;p&gt;We can derive a typeclass instance from the existence of another typeclass as
follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;derive instance Orderable $X $Y
        from Reverse: Orderable $Y $X

    fun order (x: $X, y: $Y): Order
        val rev = Reverse.order(y, x)
        if (rev == BIGGER)  return SMALLER
        if (rev == SMALLER) return BIGGER
        return EQUAL&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We call this declaration an &lt;em&gt;instance derivation&lt;/em&gt;. The instance that will
fullfill the from-clause is called the &lt;em&gt;source instance&lt;/em&gt;. The instance derived
from a specific source instance is simply known as a &lt;em&gt;derived instance&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Instance selection will always prefer an explicit instance rather than a derived
instance when both are in the same scope. So our derived &lt;code&gt;Orderable&lt;/code&gt; instance
does not cause issues when &lt;code&gt;$X&lt;/code&gt; and &lt;code&gt;$Y&lt;/code&gt; are the same type. We&amp;#39;ll talk about
this more in the &lt;a href=&quot;#type-derivations-and-instance-selection&quot;&gt;Type Derivations and Instance
Selection&lt;/a&gt; section.&lt;/p&gt;
&lt;p&gt;Just like instances, instance derivations have names. Similarly, they can have
explicit names:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;derive instance Reversed: Orderable $X $Y
        from Reverse: Orderable $Y $X
    // ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But otherwise an automatic name is attributed. For our example, the name would
be &lt;code&gt;Orderable_$X_$Y_from_Orderable_$Y_$X&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A single derivation can yield many different instances. There will of course be
instances with different type arguments, but also instances using a different
source instance.&lt;/p&gt;
&lt;p&gt;Source instances can be given a name (&lt;code&gt;Reverse&lt;/code&gt; in our example) or have a name
assigned automatically — it would be &lt;code&gt;Orderable_$X_$Y&lt;/code&gt; in our example). This,
however, is not the true name of the source instance — which is simply the name
of whatever instance is selected to fullfill the role of the source instance.
Rather it&amp;#39;s an alias that can be used within the definition of the type
derivation. It may happens that this name clashes with previously declared
names. In this case, this name shadows the previous declaration, for the
duration of the type derivation definition. It will be possible to access
file-levels and imported names by prefixing them with a module name — see next
section.&lt;/p&gt;
&lt;p&gt;While we don&amp;#39;t declare derived instances explicitly, they also have names! These
are derived by treating the name of the derivation as a function of the source
instance, e.g. &lt;code&gt;Reversed(Orderable_Int_Int)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;importing-typeclasses-and-instances&quot;&gt;Importing Typeclasses and Instances&lt;/h2&gt;
&lt;p&gt;In this imaginary language, I&amp;#39;ve decided not to specify explicitly how things
can become imported.&lt;/p&gt;
&lt;p&gt;Having nevertheless given it some thought, it appears clear that importing all
instances explicitly would be cumbersome. One could therefore suppose that
typeclass instances will get imported &lt;em&gt;implicitly&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;For instance, we could &lt;strong&gt;imagine&lt;/strong&gt; that if we import a set of types from a file,
then all typeclass instances in the file for that set of types would get
imported implicitly.&lt;/p&gt;
&lt;p&gt;An instance is said to be &lt;em&gt;in scope&lt;/em&gt; of some code if they&amp;#39;re declared in the
same file, or if they&amp;#39;ve been imported (explicitly or implicitly).&lt;/p&gt;
&lt;p&gt;I imagine that this system will rely on a notion of &lt;em&gt;module&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;As such, it will be possible to prefix of an instance or type derivation by the
name of its defining module — with the special keyword &lt;code&gt;self&lt;/code&gt; designating the
current module. e.g. &lt;code&gt;self.Serializable_Point&lt;/code&gt; or
&lt;code&gt;my_module.Serializable_Point&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;default-functions&quot;&gt;Default Functions&lt;/h2&gt;
&lt;p&gt;Typeclass definitions are free to provide default implementations for the
functions they declare. Such a default definition can always be overidden in the
typeclass instances — otherwise it should just be a normal function and not a
typeclass function!&lt;/p&gt;
&lt;p&gt;For instance, the following class includes a default implementation for
&lt;code&gt;receive_all&lt;/code&gt; in terms of its other function &lt;code&gt;receive&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Receiver $T $X
    fun receive (it: $T, item: $X)
    fun receive_all (it: $T, items: List[$T])
        for item in items:
            receive(it, item)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It&amp;#39;s even possible to have two functions in terms of one another — the user
implementing the instance will have to override at least one of them.&lt;/p&gt;
&lt;p&gt;(It would be possible to add language-level support to defining such sets of
functions, at least one of which needs to be overriden, but I&amp;#39;m not sure the
benefits are worth the conceptual overhead.)&lt;/p&gt;
&lt;p&gt;There are essentially two ways to implement default methods. The first is for
them to be some kind of template, specialized for and copied into each instance
that does not override them. The second is to use a late binding mechanism,
which can be especially interesting if the implementation targets supports it
(e.g. the JVM).&lt;/p&gt;
&lt;h2 id=&quot;typeclass-constraints&quot;&gt;Typeclass Constraints&lt;/h2&gt;
&lt;p&gt;There are two places where it&amp;#39;s possible to constrain types based on whether
they possess a typeclass instance: method definition and typeclass declarations.&lt;/p&gt;
&lt;p&gt;Here is a method with a typeclass constraint:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun foo (it: $T) where Serializable $T
    output(serialize(it))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And here is a typeclass with a constraint:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Reducible $T $X
        where Sequential: Sequence $T $X

    fun reduce (it: $T): $X&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The function&amp;#39;s constraint prevents us from calling &lt;code&gt;foo&lt;/code&gt; with a type &lt;code&gt;$T&lt;/code&gt; that
does not have a corresponding &lt;code&gt;Serializable $T&lt;/code&gt; instance.&lt;/p&gt;
&lt;p&gt;Similarly, the typeclass&amp;#39; constraint prevents us from instanciating &lt;code&gt;Reducible&lt;/code&gt;
for pair of types that do not have a corresponding &lt;code&gt;Sequence $T $X&lt;/code&gt; instance.&lt;/p&gt;
&lt;p&gt;We call instances that satisfy a function&amp;#39;s constraints &lt;em&gt;the call instances&lt;/em&gt;,
and the instances that satisfy a typeclass&amp;#39;s constraint the &lt;em&gt;required
instances&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Sometimes, a typeclass with a type constraint can be very close to a type
derivation, especially when the typeclass defines default implementations for
all its functions. The big difference is that a class must still be implemented
explicitly — an implementation has to be requested even if no functions have to
be implemented. A derivation, on the other hand, is always &amp;quot;active&amp;quot;.&lt;/p&gt;
&lt;p&gt;Just like for source instances in type derivations (cf. the &lt;a href=&quot;#deriving-typeclasses-automatically&quot;&gt;Deriving
Typeclasses Automatically&lt;/a&gt; section), the
required instances may be named and have otherwise an automatically generated
name. This is not the &amp;quot;true&amp;quot; instance name, but a local alias that may shadow
previous declarations.&lt;/p&gt;
&lt;p&gt;The other big difference between typeclass declarations with type constraints
and type derivations is &lt;strong&gt;when&lt;/strong&gt; instance selection occurs. We&amp;#39;ll come back to
it in the &lt;a href=&quot;#type-constraints-vs-type-derivations&quot;&gt;Type Constraints vs Type
Derivations&lt;/a&gt; section.&lt;/p&gt;
&lt;h2 id=&quot;picking-instances&quot;&gt;Picking Instances&lt;/h2&gt;
&lt;p&gt;During the execution of our program, there are a couple times when instances
will need to be picked. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Direct instance selection&lt;/em&gt; — when we call a function that belong to a
typeclass, we need to decide which instance will provide the implementation.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Call instance selection&lt;/em&gt; — selecting the instance that satisfies a typeclass
constraint in a function (cf. last section).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Required instance selection&lt;/em&gt; — selecting the instance that satisfies a
typeclass constraint in a typeclass (cf. last section).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Source instance selection&lt;/em&gt; — select the instances used as source for instance
derivations.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Fortunately, all types of instance selections are similar, and follow the same
rules. In each case, we know the typeclass we want to provide an instance for,
and we have to select that instance from those that are in scope and fit the
bill (or emit an error if no instance will do).&lt;/p&gt;
&lt;p&gt;If there is only one instance that works, the language will know to pick it. But
if there are ambiguities, it needs to decide on a particular instance, based on
hints supplied by the programmer.&lt;/p&gt;
&lt;p&gt;We&amp;#39;ll explain the instance selection rules using &lt;em&gt;direct instance selection&lt;/em&gt;,
and add precisions for other types of selections later, as required.&lt;/p&gt;
&lt;h2 id=&quot;direct-instance-selection&quot;&gt;Direct Instance Selection&lt;/h2&gt;
&lt;p&gt;Imagine that we import &lt;code&gt;Serializable_Point&lt;/code&gt; and &lt;code&gt;PointSlash&lt;/code&gt; from before, two
instances of &lt;code&gt;Serializable Point&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;u&gt;Small aside&lt;/u&gt;: it would be more proper to say &amp;quot;two instances of &lt;code&gt;Serializable&lt;/code&gt;
for the type &lt;code&gt;Point&lt;/code&gt;&amp;quot; — but that&amp;#39;s tedious. And what category does &lt;code&gt;Serializable
Point&lt;/code&gt; even belong to? It&amp;#39;s not a typeclass (&lt;code&gt;Serializable&lt;/code&gt; is) nor an instance
(&lt;code&gt;Serializable_Point&lt;/code&gt; is). If we really need a name, we could could this a
&lt;em&gt;typeclass specification&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun foo (it: Point)
    output(serialize(it))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Which instance should this code use?&lt;/p&gt;
&lt;p&gt;We can select the proper instance in two ways:&lt;/p&gt;
&lt;p&gt;1) Specify the instance to use at the instance selection site:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun foo (it: Point)
    output(Serializable_Point.serialize(it))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2) Specify the instance to use in a certain scope (e.g. file or function) with
   an &lt;code&gt;use&lt;/code&gt; declaration.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun foo (it: Point)
    use PointSlash
    output(serialize(it))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Of course, you could do &lt;code&gt;PointSlash.serialize(it)&lt;/code&gt; and &lt;code&gt;use Serializable_Point&lt;/code&gt;
as well.&lt;/p&gt;
&lt;p&gt;When your two instances have automatically generated names which therefore clash
(i.e. both are named &lt;code&gt;Serializable_Point&lt;/code&gt;), you can prefix with module names to
disambiguate them (e.g. &lt;code&gt;self.Serializable_Point&lt;/code&gt; or
&lt;code&gt;my_module.Serializable_Point&lt;/code&gt;) — see the &lt;a href=&quot;#importing-typeclasses-and-instances&quot;&gt;Importing Typeclasses and
Instances&lt;/a&gt; section.&lt;/p&gt;
&lt;p&gt;Regarding &lt;code&gt;use&lt;/code&gt;, the current plan is that it will be possible to override an
&lt;code&gt;use&lt;/code&gt; declaration with another, even in the same scope. For instance:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun foo (it: Point)
    use PointSlash
    output(serialize(it))
    use Serializable_Point
    output(serialize(it))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Nevertheless, &lt;code&gt;use&lt;/code&gt; remains a &lt;em&gt;declaration&lt;/em&gt; whose scope is purely static. It is
not a &lt;em&gt;statement&lt;/em&gt; (and so cannot be guarded by an if statement, etc).&lt;/p&gt;
&lt;h2 id=&quot;type-derivations-and-instance-selection&quot;&gt;Type Derivations and Instance Selection&lt;/h2&gt;
&lt;p&gt;Derived instances do complicate the instance selection mechanism somewhat.&lt;/p&gt;
&lt;p&gt;The basic issue is relatively simple. If there is a conflict between two
instances, and both of these instances can serve as base for the creation of
derived instance, then you&amp;#39;ll have a conflict there as well.&lt;/p&gt;
&lt;p&gt;Consider the following example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Named $T
    fun name (it: $T): String

instance UserFirst: Named User
    fun name (it: User): String
        return it.first_name

instance UserLast: Named User
    fun name (it: User): String
        return it.last_name

class Stringifiable $T
    fun to_string (it: $T): String

derive instance Stringifiable $T from Named $T
    fun to_string (it: $T): String
        return name(it)

fun foo (usr: User)
    output(to_string(usr))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Should &lt;code&gt;foo&lt;/code&gt; output the users&amp;#39;s first or last name? Say we want the last name.&lt;/p&gt;
&lt;p&gt;There is an easy ways to fix that conflict, should write &lt;code&gt;use UserLast&lt;/code&gt;. This
will have the effect of disambiguating the &lt;em&gt;source instance selection&lt;/em&gt; of the
type derivation, hence &lt;code&gt;foo&lt;/code&gt; will use the &lt;code&gt;Stringifiable&lt;/code&gt; instance derived from
&lt;code&gt;UserLast&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But what if we add the following?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;derive instance ThingNamed: Stringifiable $T
        from Named $T
    fun to_string (it: $T): String
        return &amp;quot;the thing named &amp;#39;&amp;quot; + name(it) + &amp;quot;&amp;#39;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we also need to specify which derivation we want. We can do this in a couple
ways:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;use ThingNamed&lt;/code&gt; — always use the &lt;code&gt;ThingNamed&lt;/code&gt; derivation to supply a
&lt;code&gt;Stringifiable&lt;/code&gt; when a &lt;code&gt;Named&lt;/code&gt; instance exists.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ThingNamed.to_string(usr)&lt;/code&gt; — specifying the derivation to use explicitly at
the use site.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;use ThingNamed(UserLast)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ThingNamed(UserLast).to_string(usr)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first solution is a new form of &lt;code&gt;use&lt;/code&gt; which does not specify an instance but
an instance derivation!&lt;/p&gt;
&lt;p&gt;The second solution is symmetric to the first, we use the derivation instead of
an instance at the instance selection site.&lt;/p&gt;
&lt;p&gt;The third and fourth solution have nothing novel: we just specify the full
instance explicitly.&lt;/p&gt;
&lt;p&gt;The first two solutions, however, do require us to have specified &lt;code&gt;use UserLast&lt;/code&gt;
before! Otherwise, we know to use &lt;code&gt;ThingNamed&lt;/code&gt;, but should it use the the
&lt;code&gt;UserFirst&lt;/code&gt; or &lt;code&gt;UserLast&lt;/code&gt; instance?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Using&lt;/strong&gt; an instance derivation demands &lt;em&gt;source instance selection&lt;/em&gt;. This
selection may be done manually (as in &lt;code&gt;use ThingNamed(UserLast)&lt;/code&gt;) or
automatically — if there is no ambiguity or the proper &lt;code&gt;use&lt;/code&gt; statements have
been made.&lt;/p&gt;
&lt;p&gt;Automatic source instance selection may entail a recursion problem when an
instance derivation creates a instance of the same kind as its pre-requisite. We
already saw a derivation like that:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;instance Orderable Int Int
    // ...

// assume we imported this
derive instance Reversed: Orderable $X $Y
        from Reverse: Orderable $Y $X
    // ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I said earlier:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Instance selection will always prefer an explicit instance rather than a
derived instance when both are in the same scope.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;That&amp;#39;s because I assume that within a single file, you&amp;#39;re aware when an explicit
and derived instance clash.&lt;/p&gt;
&lt;p&gt;But it doesn&amp;#39;t work like that when importing one of the two instances. In that
case, the policy is to let them clash to bring awareness to the conflict.&lt;/p&gt;
&lt;p&gt;If you want the base behaviour, you can do &lt;code&gt;use Orderable_Int_Int&lt;/code&gt; and all is
well. But if you want the derived behaviour, you &lt;strong&gt;can&amp;#39;t&lt;/strong&gt; do &lt;code&gt;use Reversed&lt;/code&gt;.
Because that would mean the derivation would use itself as &lt;code&gt;Reverse&lt;/code&gt; — an
infinite recursion. It is therefore a compile-time error.&lt;/p&gt;
&lt;p&gt;The solution in this case is simply to do manual source instance selection, i.e.
specify the full instance name: &lt;code&gt;use Reversed(Orderable_Int_Int)&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;implicit-use&quot;&gt;Implicit &lt;code&gt;use&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;We need to add an important precision to what precedes.&lt;/p&gt;
&lt;p&gt;Whenever there is a typeclass constraint, the constraint acts like an implicit
&lt;code&gt;use&lt;/code&gt; statement!&lt;/p&gt;
&lt;p&gt;So the following pair of functions are always equivalent:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun foo1 (it: $T) where Serializable $T
    output(serialize(it))n

fun foo2 (it: $T) where Serializable $T
    use Serializable_$T
    output(serialize(it))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The same principle applies for typeclass&amp;#39; constraints.&lt;/p&gt;
&lt;h2 id=&quot;type-constraints-vs-type-derivations&quot;&gt;Type Constraints vs Type Derivations&lt;/h2&gt;
&lt;p&gt;When we introduced typeclass&amp;#39; constraints in the &lt;a href=&quot;#typeclass-constraints&quot;&gt;Typeclass
Constraints&lt;/a&gt; section, we said that a big difference
between typeclasses with constraints on the one hand, and type derivations on
the other hand, was that one must always request a typeclass instances, whereas
type derivation are always &amp;quot;active&amp;quot; to generate instances on a by-need basis.&lt;/p&gt;
&lt;p&gt;Now we can introduce another big difference that directly falls out from that
first difference, namely &lt;em&gt;when&lt;/em&gt; instance selection occurs.&lt;/p&gt;
&lt;p&gt;Instances that implement a typeclass with type constraints cause the required
instances to be &lt;em&gt;captured&lt;/em&gt;. This means they&amp;#39;re essentially stored inside the
instance, and their usage is not dependent on the context in which the instance
functions are used.&lt;/p&gt;
&lt;p&gt;For type derivations, it&amp;#39;s some other instance selection that triggers the
source instance selection!&lt;/p&gt;
&lt;p&gt;Just like other forms of instance selection, required instance selection is
affected by &lt;code&gt;use&lt;/code&gt; statements. Manual disambiguation is also possible with the
&lt;code&gt;using&lt;/code&gt; clause.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Foo $T requires Named $T
    // ...

instance FooUser User using LastName
    // ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;On occasions, the capture of required instances, might lead to situations that
are very slightly unintuitive:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Reducible $T $X
        where Sequential: Sequence $T $X

    fun reduce (it: $T): $X

// ...

fun foo (seq: $T) where Reducible $T Point, Sequence $T Point
    reduce(seq)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the above example, there is not guarantee that the instance selected for the
function&amp;#39;s &lt;code&gt;Sequence $T Point&lt;/code&gt; constraint will be the same as the instance
selected for the typeclass&amp;#39; constraint!&lt;/p&gt;
&lt;p&gt;The first one is selected when the instance satisfying &lt;code&gt;Reducible $T Point&lt;/code&gt; is
defined, whereas the second is selected when the function &lt;code&gt;foo&lt;/code&gt; is called.&lt;/p&gt;
&lt;h2 id=&quot;shortcut-notation-for-parameter-types&quot;&gt;Shortcut Notation For Parameter Types&lt;/h2&gt;
&lt;p&gt;We admit a shortcut notation for uses of unary typeclasses, so thoses two
snippets are equivalent:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun foo (mk_string: $A) where Stringifiable $A
    // ...&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;fun foo (mk_string: Stringifiable)
    // ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The second one sure looks nicer!&lt;/p&gt;
&lt;p&gt;There are a few reason not to use the shorthand though:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When you need to express other constraints on the actual type.&lt;/li&gt;
&lt;li&gt;When you need to reuse the actual type for other parameters.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For instance, these two snippets are equivalent:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun foo (mk_string1: $A, mk_string2 $B)
        where Stringifiable $A, Stringifiable $B
    // ...&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;fun foo (mk_string1: Stringifiable, mk_string2: Stringifiable)
    // ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In practice, names will likely need to be attributed to the underlying generic
type when using the shortcut notation. The current plan is to use simple
sequential identifiers preceded by a reserved string (something like &lt;code&gt;__$A&lt;/code&gt;,
&lt;code&gt;__$B&lt;/code&gt;, ...).&lt;/p&gt;
&lt;p&gt;The shortcut notation can also be used for multi-parameter typeclasses, for
instance the two following snippets are equivalent:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun foo (seq: $A) where Sequence $A String
    // ...&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;fun foo (seq: Sequence[String])
    // ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If there are more than two parameters to the typeclass, supplemental parameters
are separated by a comma:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun foo (graph: Graph[Node, Edge]) // Graph $A Node Edge
    // ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is an example notation anyway, but I&amp;#39;m wondering if using &lt;code&gt;Sequence String&lt;/code&gt;
and &lt;code&gt;Graph Node Edge&lt;/code&gt; wouldn&amp;#39;t be more pleasant? If I don&amp;#39;t type need type-level
operators, maybe I&amp;#39;ll do just that.&lt;/p&gt;
&lt;h2 id=&quot;empty-typeclasses&quot;&gt;Empty Typeclasses&lt;/h2&gt;
&lt;p&gt;One may imagine that we will end up with a lot of typeclasses that define
fine-grained behaviours. Some of those will be related by type constraints. It&amp;#39;s
probably a good idea to make it possible to access required instances from the
instance that requires them.&lt;/p&gt;
&lt;p&gt;Sometimes, we would like to bundle a couple of instances together, to compose a
more precise behaviour contract (which is what a typeclass essentially is) from
a bunch of smaller ones.&lt;/p&gt;
&lt;p&gt;In that case, a common pattern would be to use an empty typeclass with a list of
requirements:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class List $T $X where
    Sequential $T $X,
    Indexable $T $X,
    Iterable $T $X&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Assuming we have an instance of this class, we can access the required instances
by dot references: &lt;code&gt;ListInstance.Sequential_$T_$X&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can also bring required instances in scope via some local import statement:
&lt;code&gt;import ListInstance.Sequential_$T_$X&lt;/code&gt;. Or if we want all of them: &lt;code&gt;import
ListInstance.*&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note that importing the instances brings them in scope. It pointedly &lt;em&gt;does not&lt;/em&gt;
resolve ambiguities. It is not an &lt;code&gt;use&lt;/code&gt; statement! (But you can also supply
required instances to &lt;code&gt;use&lt;/code&gt;, of course.)&lt;/p&gt;
&lt;h2 id=&quot;aliases&quot;&gt;Aliases&lt;/h2&gt;
&lt;p&gt;What if you import an instance and the original author hasn&amp;#39;t given it a nice
name? Fortunately for you, the &lt;code&gt;alias&lt;/code&gt; declaration has you covered:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alias PointComma = Serializable_Point&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;alias&lt;/code&gt; work for any kind of names: typeclass derivations, constructed instance
names, ...&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alias Reversed = Orderable_$X_$Y_from_Orderable_$Y_$X
alias ReversedIntComp = Orderable_$X_$Y_from_Orderable_$Y_$X(Orderable_Int_Int)
// or, using the first allias:
alias ReversedIntComp = Reversed(Orderable_Int_Int)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;An alias makes its left and right part interchangeable for code in which the
&lt;code&gt;alias&lt;/code&gt; is in scope. It&amp;#39;s not the same as giving a name to the instance when
it&amp;#39;s declared: in that case, no automatically generated name is attributed!&lt;/p&gt;
&lt;h2 id=&quot;what-remains-to-be-done&quot;&gt;What Remains to be Done&lt;/h2&gt;
&lt;p&gt;This post is long enough as it is (and a dry read besides), so I thought it wise
to stop myself here.&lt;/p&gt;
&lt;p&gt;There are however a few topics that still need consideration to make for a
truly great typeclass system.&lt;/p&gt;
&lt;p&gt;First, what in Haskell are called &lt;em&gt;existentials&lt;/em&gt;, basically a way to have a type
&lt;code&gt;R exists Serializable R&lt;/code&gt; meaning that there exists some type X such that an
instance of &lt;code&gt;Serializable X&lt;/code&gt; exists, but X is not fixed, so that variables of
type &lt;code&gt;R&lt;/code&gt; can take values with different underlying types.&lt;/p&gt;
&lt;p&gt;A value of such a type is a pair of a value and a typeclass (or potentially, a
tuple of multiple values and typeclass instances).&lt;/p&gt;
&lt;p&gt;Most notably, existentials are necessary to implemented &lt;em&gt;heterogeneous
collections&lt;/em&gt; as you can be had in most language, e.g. &lt;code&gt;List&amp;lt;Serializable&amp;gt;&lt;/code&gt; in
Java. Without existentials, it&amp;#39;s impossible to specify a list of values with
different types who happen to have a corresponding &lt;code&gt;Serializable&lt;/code&gt; instance.&lt;/p&gt;
&lt;p&gt;The second important thing is to add some mechanism that help with code reuse.
In particular, some form of delegation or late binding (e.g. Scala traits) would
be neat. Some would advocate that a benefit of type classes is to get rid of
that aspect of OO, but I disagree. The problem in OO in general is that
permissions are too open by default: non-final clases and methods in Java for
instance. As Joshua Bloch puts it in &lt;a href=&quot;https://books.google.be/books/about/Effective_Java.html?id=ka2VUBqHiWkC&amp;amp;redir_esc=y&quot;&gt;Effective Java&lt;/a&gt;: &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Design and document for inheritance or else prohibit it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Well done late binding is effectively a clean way to specify callbacks,
potentially with a default behaviour in place. These callbacks may themselves
call inside the late bound entity (class or typeclass). Effectively, this saves
a lot of plumbing headaches.&lt;/p&gt;
&lt;p&gt;There are a couple more things that could go in, but they aren&amp;#39;t as essential.&lt;/p&gt;
&lt;p&gt;One particular nicety I can think of is a mechanism for type unions. Not only
boring unions (like &lt;code&gt;int | String&lt;/code&gt; to specify you expect either an integer or a
string), but also being able to specify a type &lt;code&gt;R&lt;/code&gt; such that there is either an
instance of &lt;code&gt;Serializable R&lt;/code&gt; or an instance of &lt;code&gt;Stringifyable R&lt;/code&gt; (or both!).
Similar types intersection are already possible, just by putting multiple
constraints on a type.&lt;/p&gt;
&lt;p&gt;These type unions make some &lt;a href=&quot;/polymorphism/#ad-hoc-polymorphism&quot;&gt;ad-hoc polymorphism&lt;/a&gt; possible, and would be further
well served by some form of pattern matching and &lt;a href=&quot;https://en.wikipedia.org/wiki/Flow-sensitive_typing&quot;&gt;flow typing&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But all this will have to wait for another day!&lt;/p&gt;
      </description>
      <pubDate>2019-03-31T22:00:00.000Z</pubDate>
      <link>http://norswap.com/typeclass-scheme</link>
      <guid isPermaLink="true">http://norswap.com/typeclass-scheme</guid>
    </item>
    <item>
      <title>Language Design Notes 0: A Map of Polymorphism</title>
      <description>
&lt;p&gt;This is the first post in &lt;a href=&quot;/language-design-notes&quot;&gt;a series&lt;/a&gt; where I write my thoughts on some aspects
of language design. This first installment will deal with polymorphism, what it
is, and how it manifests in its three main forms, which we review below.&lt;/p&gt;
&lt;h2 id=&quot;ad-hoc-polymorphism&quot;&gt;Ad-Hoc Polymorphism&lt;/h2&gt;
&lt;p&gt;Basically polymorphism has to do with the ability to reuse the same code for
different types of values.&lt;/p&gt;
&lt;p&gt;Dynamically-typed languages are very polymorphic, since any storage location
(variable, field) can hold any value.&lt;/p&gt;
&lt;p&gt;Functions in dynamically-typed language exhibit &lt;strong&gt;ad-hoc polymorphism&lt;/strong&gt;, which
is to say that functions may work even when supplied arguments of different
types.&lt;/p&gt;
&lt;p&gt;Sometimes you just don&amp;#39;t need to know the type of a value. If you&amp;#39;re just going
to store it in a collection, for instance.&lt;/p&gt;
&lt;p&gt;But sometimes it&amp;#39;s ultimately necessary to separate the behaviour for different
types. This is done either through another kind of polymorphism (often
&lt;em&gt;subtyping polymorphism&lt;/em&gt;), or by checking the type explicitly and branching out
in different execution path on that basis. For instance:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def foo(x):
    if type(x) is Bar:
        foo_bar(x)
    elif type(x) is Baz:
        foo_baz(x)
    else
        raise TypeError(&amp;quot;x is neither Bar nor Baz&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Some people also say that &lt;em&gt;overloading&lt;/em&gt; in statically-typed languages (having
multiple functions with the same name, but differing in the type of their
arguments) counts as polymorphism. I&amp;#39;m not anal about definitions, but
overloading isn&amp;#39;t what I&amp;#39;m talking about here.&lt;/p&gt;
&lt;p&gt;The problem is that (unlike every other types of &amp;quot;polymorphism&amp;quot;), overloading
doesn&amp;#39;t compose. The specific overload that gets called must be determined
statically. As such the type must be fully determined — we can&amp;#39;t use a type
parameter (cf. &lt;em&gt;parametric polymorphism&lt;/em&gt;) and the specific subtype (cf.
&lt;em&gt;subtyping polymorphism&lt;/em&gt;) isn&amp;#39;t taken into account.&lt;/p&gt;
&lt;p&gt;Basically, you can never reuse code that calls an overloaded function for
multiple types. Overloading is ultimately just a naming convenience: you could
give each overload its own name and nothing would change. (There is an exception
to that rule, see the discussion of C++ templates below.)&lt;/p&gt;
&lt;p&gt;Nevertheless, ad-hoc polymorphism can also appear in statically typed languages,
either via a super type (e.g. &lt;code&gt;Object&lt;/code&gt; in Java, but any shared super type will
do) or some other wildcard type that is cast-compatible with the others (e.g.
&lt;code&gt;void *&lt;/code&gt; in C). Using these types essentially brings us back to a &amp;quot;dynamically
typed&amp;quot; scenario, except we can&amp;#39;t directly call functions we know exist: we have
to cast the values to their proper types first.&lt;/p&gt;
&lt;p&gt;In statically-typed languages, &lt;a href=&quot;https://en.wikipedia.org/wiki/Flow-sensitive_typing&quot;&gt;flow typing&lt;/a&gt; and union types (e.g. in
&lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/tour/types/&quot;&gt;Ceylon&lt;/a&gt; or &lt;a href=&quot;http://dotty.epfl.ch/docs/reference/new-types/union-types.html&quot;&gt;Scala&lt;/a&gt;) can help make ad-hoc
polymorphism more palatable.&lt;/p&gt;
&lt;h2 id=&quot;subtypinginclusion-polymorphism&quot;&gt;Subtyping/Inclusion Polymorphism&lt;/h2&gt;
&lt;p&gt;Another popular type of polymorphism is &lt;strong&gt;subtyping (or inclusion)
polymorphism&lt;/strong&gt;. This is your standard object-oriented class and sub-class
scenario, but also includes things like interface implementations, traits, etc.&lt;/p&gt;
&lt;p&gt;This one works for both dynamically- and statically-typed languages. It&amp;#39;s
straightforward in statically-typed languages: you put a type on a parameter,
and the function can also accept any argument that is a subtype of that type.&lt;/p&gt;
&lt;p&gt;Dynamically-typed languages of the OO variety also have inheritance, but in that
case I&amp;#39;m not sure if it should be considered as subtyping or ad-hoc polymorphism
(and it matters little). The thing is that you can have OO polymorphism without
even sharing a superclass. A function can call a method on an object, and has
long as the object does implement a method by that name, it will work.&lt;/p&gt;
&lt;p&gt;Said otherwise, the interfaces can be left implicit, the following method is
polymorphic for any object that has both a &lt;code&gt;bar()&lt;/code&gt; and &lt;code&gt;baz()&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def foo(x):
    x.bar()
    x.baz()&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;parametric-polymorphism&quot;&gt;Parametric Polymorphism&lt;/h2&gt;
&lt;p&gt;Finally, last of the big three, we have &lt;strong&gt;parametric polymorphism&lt;/strong&gt;. There are a
few famous examples of that: generics in Java and C#, templates in C++.
Basically you endow bits of code (typically functions and data structures) with
type parameters that allow specializing the code for the given type.&lt;/p&gt;
&lt;p&gt;At its most basic, parametric polymorphism for functions is the equivalent of
ad-hoc polymorphism for statically-typed languages: it allows you to call the
same code with values different types, but also preserves the specific type
being used.&lt;/p&gt;
&lt;p&gt;Since the parametrized code must range over multiple types, the available
information is limited. At worse, you know nothing, but you can also have a
&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/bounded.html&quot;&gt;type bound&lt;/a&gt; that gives a common supertype (if also using &lt;em&gt;subtyping
polymorphism&lt;/em&gt;) or some other information that constraint the valid type
arguments.&lt;/p&gt;
&lt;p&gt;So, like ad-hoc polymorphism, if you ultimately want to do something specific to
the actual type, you either have to perform a cast, or rely on subtyping polymorphism.&lt;/p&gt;
&lt;p&gt;We can further distinguish different realization of parametric polymorphism.
With Java and C# generics, the same (binary) code is used regardless of the
actual type arguments being used. In C++ templates, the code is automatically
duplicated and specialized for the specific type arguments. This has both pros
and cons. While Java/C# are limited to accepting object types (i.e. pointers) as
type arguments, C++ can accept any pointer, structure or primitive type — even
if they have different size in memory. The downside is that all the duplication
can bloat the binary size, something significantly so.&lt;/p&gt;
&lt;p&gt;C++ templates are essentially a form of (turing-complete!) macro-expansion. They
are compiled using something called &amp;quot;two phase lookup&amp;quot;. The template definition
is checked for basic syntactic errors, but the check for the existence of the
function calls in the template only occurs when the template is instantiated for
particular type arguments. An interesting consequence of this is that templates
can &amp;quot;redeem&amp;quot; overloading: the same source code can now call different overloads
by virtue of being specialized automatically by C++.&lt;/p&gt;
&lt;p&gt;And by the way, yes, C macros can also be regarded as polymorphism. They can
redeem overloading in the same way as templates, though C doesn&amp;#39;t have
overloading — but that can be papered over by using the &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Typeof.html&quot;&gt;&lt;code&gt;typeof&lt;/code&gt; GCC
extension&lt;/a&gt;. A big difference is that C macros cannot be called automatically —
if you write a specializable function with it, you&amp;#39;ll have to instantiated it
yourself for any type you want to use it with! More advanced types of macros
(e.g. Lisp macros) may take things even further.&lt;/p&gt;
&lt;p&gt;Java and C# generics also differ in one different respect: the erasure or
reification of type arguments. C# actually makes the type arguments available to
the user code, which can use it to perform type checks, type casts, type
reflection... Type arguments are essentially converted to additional arguments
of the generic function. Java, on the other hand, &lt;em&gt;erases&lt;/em&gt; the type arguments
form the bytecode it generates, so the aforementioned use cases are not
possible.&lt;/p&gt;
&lt;p&gt;Downsides of reified generics? Apparently, performance. It&amp;#39;s hard to find a good
analysis of that claim, but Gilad Bracha &lt;a href=&quot;https://gbracha.blogspot.com/2018/10/reified-generics-search-for-cure.html&quot;&gt;made it&lt;/a&gt; based on his
work on the Dart VM, and I&amp;#39;m inclined to believe it. Still the statement isn&amp;#39;t
qualified: how bad is it, really?&lt;/p&gt;
      </description>
      <pubDate>2019-03-23T23:00:00.000Z</pubDate>
      <link>http://norswap.com/polymorphism</link>
      <guid isPermaLink="true">http://norswap.com/polymorphism</guid>
    </item>
  </channel>
</rss>
