<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>norswap</title>
    <description></description>      
    <link>http://norswap.com/</link>
    <atom:link href="http://norswap.com/atom.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Even More Anime</title>
      <description>
&lt;p&gt;Previously: &lt;a href=&quot;/every-anime/&quot;&gt;Every Anime I Ever Watch&lt;/a&gt;, &lt;a href=&quot;/more-anime/&quot;&gt;More Anime I Watched&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This time: even more anime. And actually, one or two live-action TV shows that
have nothing to do with anime. And two animated movies.&lt;/p&gt;
&lt;h2 id=&quot;gurren-lagann-the-movie-childhood-s-end&quot;&gt;Gurren Lagann The Movie: Childhood&amp;#39;s End&lt;/h2&gt;
&lt;p&gt;Gurren Lagann is &lt;a href=&quot;/gurren-lagann-reaction/&quot;&gt;GREAT&lt;/a&gt;, however I see no reason to watch this movie instead of
the show, who does a much better job of conveying the emotions and the
characters.&lt;/p&gt;
&lt;p&gt;This first movie covers episodes 1-14 of the show (out of 27, the 16th  being a
compilation episode). Maybe it&amp;#39;s too much to squish in a 1 hour 50 movie.&lt;/p&gt;
&lt;p&gt;Time is saved in two major ways. First by eliding everything that happens
between Gurren Lagann&amp;#39;s first fight and the fights against Lordgenome&amp;#39;s
generals. This is when most of the companions are met and introduced. In
particular, I found it questionable to leave out the part about Rossiu&amp;#39;s
village, which is important background for an important character later down the
line. It makes the character and by extension the story slightly less
interesting.&lt;/p&gt;
&lt;p&gt;Similarly, it&amp;#39;s hard to relate to — or even get to enjoy — most characters when
there are so many of them and they have so little screen time in the movie. Even
regarding the main characters, the transition from key event to key event feels
jarring. The stitching shows.&lt;/p&gt;
&lt;p&gt;Second, the different general fights have been merged into one big fight. While
it&amp;#39;s quite well done, I kind of like the slower pacing of the show here. Simon&amp;#39;s
recovery was more subtle, and the next few fight see him really come into his
own, culminating in his fight against Lordgenome... which is not shown in this
movie. Like, WHAT? Why? Seeing as there is a multiple years time-leap after this
fight, wouldn&amp;#39;t it have been perfect to end on it. It is the culmination of the
journey after all.&lt;/p&gt;
&lt;p&gt;Seeing this, I didn&amp;#39;t bother with the second movie.&lt;/p&gt;
&lt;p&gt;So yeah. Watch the show instead.&lt;/p&gt;
&lt;h2 id=&quot;my-hero-academia-season-3&quot;&gt;My Hero Academia Season 3&lt;/h2&gt;
&lt;p&gt;As &lt;a href=&quot;/more-anime/#my-hero-academia&quot;&gt;previously reviewed&lt;/a&gt;, this is as great as ever. The quality is consistent.
The All Might fight in particular is fantastic. The season doesn&amp;#39;t end on a very
high beat moment, but the ride was great.&lt;/p&gt;
&lt;h2 id=&quot;my-hero-academia-two-heroes&quot;&gt;My Hero Academia: Two Heroes&lt;/h2&gt;
&lt;p&gt;This is a movie that came out during the airing of season 3.&lt;/p&gt;
&lt;p&gt;I really have nothing special to say here. It&amp;#39;s Hero Academia, it&amp;#39;s great. Of
course it is.&lt;/p&gt;
&lt;h2 id=&quot;attack-on-titans-season-3-part-1-&quot;&gt;Attack on Titans Season 3 (Part 1)&lt;/h2&gt;
&lt;p&gt;Previously: &lt;a href=&quot;/every-anime/#attack-on-titan&quot;&gt;Season 1&lt;/a&gt; and &lt;a href=&quot;/more-anime/#attack-on-titan-season-2&quot;&gt;Season 2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Haven&amp;#39;t much to add. Season 3 diggs even deeper in the story and shed light on
some of the mysteries in the series. I did perceive it to be less
entertaining/gripping than the first two season, but it&amp;#39;s high quality all the
same.&lt;/p&gt;
&lt;p&gt;I enjoyed that we get to know more and more about the titans, the universe, and
how it came to be this way. Looks like we&amp;#39;ll learn even more in the second part
of the season, which starts airing at the end of the month.&lt;/p&gt;
&lt;h2 id=&quot;steins-gate-0&quot;&gt;Steins;Gate 0&lt;/h2&gt;
&lt;p&gt;Steins;Gate 0 explore an alternative timeline starting near the end of
&lt;a href=&quot;/more-anime/#steins-gate&quot;&gt;Steins;Gate&lt;/a&gt;. What if things didn&amp;#39;t go down the way they did?&lt;/p&gt;
&lt;p&gt;It&amp;#39;s less good than the original in my estimation, but nonetheless great. I was
very touched by how ragged Okabe becomes, how his decisions weigh on him.&lt;/p&gt;
&lt;p&gt;My problem with the season is that there is comparatively less &amp;quot;plot&amp;quot; going on,
with a lot being crammed towards the end, which feels less alive with emotion by
virtue of being more dense. On the other hand, the emotions really have time to
breathe at the start and that&amp;#39;s where the series shines, but more could be
happening.&lt;/p&gt;
&lt;p&gt;That being said, if you liked the original, you&amp;#39;ll probably like this one too.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=jyODPI_hTRE&amp;amp;lc=UgxN9D23nHdNNHKMghR4AaABAg&quot;&gt;Digi hates it, I disagree&lt;/a&gt; (scroll to see my comment).&lt;/p&gt;
&lt;p&gt;If you don&amp;#39;t remember what happened in the original Steins;Gate (it gets
confusing), &lt;a href=&quot;https://www.youtube.com/watch?v=EIDKmhzjD_Y&quot;&gt;this video&lt;/a&gt; will explain everything you need to know.&lt;/p&gt;
&lt;h2 id=&quot;re-zero&quot;&gt;Re:Zero&lt;/h2&gt;
&lt;p&gt;Another Isekai. This time the protagonist comes back to life some time in the
past when he dies.&lt;/p&gt;
&lt;p&gt;The first episode is a two-parter, and the first part meanders a bit, but a few
episodes in and it really gets kicking.&lt;/p&gt;
&lt;p&gt;I ended up enjoying the show immensely. I liked being surprised by the
directions things took - and was thankful that the relative strength of the
power wasn&amp;#39;t abused via loads of scheming and computations.&lt;/p&gt;
&lt;p&gt;The show has a large and colorful cast, but unlike Overlord, the characters feel
like they have a place in the plot, something to do, to say, and a more distinct
personality. The villains are also particularly cool.&lt;/p&gt;
&lt;p&gt;I also found the struggles of the protagonist touching, despite his motivations
being somewhat surprising.&lt;/p&gt;
&lt;p&gt;I wouldn&amp;#39;t call this a masterpiece, but it&amp;#39;s still japanimation at its best:
weird, entertaining, yet relatable and occasionally touching.&lt;/p&gt;
&lt;h2 id=&quot;overlord-season-3&quot;&gt;Overlord Season 3&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;/more-anime#overlord&quot;&gt;First two seasons reviewed here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I was far from enthused by the start of the season. Againt we&amp;#39;re in the less
relevant arcs, this time with extra goblins. There is at least one episode that
is a full-on awful conversation/exposition dump with not even so much useful
info. Ugh. So I dropped it after 5 or 6 episodes.&lt;/p&gt;
&lt;p&gt;But then my brother nagged me that I became awesome, and boy was he right. But
not in the conventional way. I have two words for you: bad CG. Really really
really bad CG. Copy pasted animations. Actual goat sounds.&lt;/p&gt;
&lt;p&gt;Overlord sorts of jumps the shark, and its great entertainment. I certainly
don&amp;#39;t care about the plot in a first-degree manner anymore, however.&lt;/p&gt;
&lt;p&gt;Speaking of plot, there is more than CG and just bad storytelling all-around to
murder it. The final nail in its coffin is what I feel is a complete reversal of
personality from the lead character Ainz Ooal Gown. In the past, he was
&amp;quot;officially&amp;quot; evil but actually never does anything really bad, and often does go
the extra mile to help people. But suddently, he&amp;#39;s gleefully murdering everyone
without so much as the hint of a reason for the change.&lt;/p&gt;
&lt;p&gt;I&amp;#39;ll watch the next season, and I hope the WTF will keep rolling in.&lt;/p&gt;
&lt;h2 id=&quot;the-darling-in-the-franxx&quot;&gt;The Darling in the Franxx&lt;/h2&gt;
&lt;p&gt;What if Evangelion and Gurren Lagann had a love child? I think it would look a
lot like this.&lt;/p&gt;
&lt;p&gt;The basic pitch: in the future, kids are being raised to pilot mechas in
male-female pairs, in order to defend against &lt;em&gt;Klaxosaurs&lt;/em&gt;, a sort of
mecha-aliens emerging from the center of the earth. The story follows squad 13,
and Zero Two, an elite mecha pilot with a very special background, who develops
a very special bond to Hiro, a member of the squad. One of the main theme of the
show is puberty, in a society where it (along with sexuality) has disappeared.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Darling_in_the_Franxx&quot;&gt;More here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I thought it was great.&lt;/p&gt;
&lt;p&gt;The show is not perfect however. It&amp;#39;s not subtle for one, and all the character
development is pretty much on the nose. Yet it works nicely. There is tremendous
character development for one, accross the whole cast for two.&lt;/p&gt;
&lt;p&gt;The cast is large but I liked how the show spent time on all its main
characters. There is also some planning done so that character development
doesn&amp;#39;t happen in one episode but the seeds are planted earlier done. You do see
it coming from far away, but it&amp;#39;s solid.&lt;/p&gt;
&lt;p&gt;I&amp;#39;m gonna veer into very very slightly spoilery territory now (no plot points
are revealed, but the general tendency of the story to e.g. go well, go bad, etc
is).&lt;/p&gt;
&lt;p&gt;I liked how there was no &amp;quot;ping-ponging&amp;quot; in character development, something I
was really expecting, especially regarding Zero Two. This kind of ping-pong is
so overused it feels like a cliche, and it&amp;#39;s difficult to employ it well. Even
places where it is used interestingly, it&amp;#39;s not always enjoyable: for instance
in Evangelion, it&amp;#39;s thoughtful (because depression), but it did diminish my
enjoyment of the show.&lt;/p&gt;
&lt;p&gt;My friend Gorby told me the show was great until the last three episodes that
ruined it. And I had read the show &amp;quot;nuked the fridge&amp;quot; at some point. This
actually made me more curious. Well, from my perspective, this didn&amp;#39;t happen at
all. Sure, the end broadens the stakes (in a way reminiscent of a certain other
show...), but thematically, it stays consistent and I wasn&amp;#39;t disappointed.&lt;/p&gt;
&lt;h2 id=&quot;the-man-in-the-high-castle-season-3&quot;&gt;The Man in The High Castle Season 3&lt;/h2&gt;
&lt;p&gt;Ah, our first non anime-show review!&lt;/p&gt;
&lt;p&gt;The Man in The High Castle isn&amp;#39;t my all-time top-pick for a TV show. In fact,
I&amp;#39;m a bit of two minds about it, but I will say that its strength are enough to
carry it.&lt;/p&gt;
&lt;p&gt;The premise is very strong: the story takes place in the 60s, but in a parralel
universe where Germany and Japan won World War 2 and are now the only two global
powers. They also split the United States (because who cares about the rest of
the world, lol) in two, with the Japanese inheriting the west coast and the
German everything east of the rockies. The rockies themselves are in a &amp;quot;neutral
zone&amp;quot; which I assume exists for reasons of extreme plot convenience.&lt;/p&gt;
&lt;p&gt;The Man in The High Castle is a weird show in that it is its antagonists that
are actually the star of the show. With a few exceptions, I really couldn&amp;#39;t
really care less about the &amp;quot;good guys&amp;quot; (who come at odds with Japanese and
Nazis, including a resistance movement), who are at times antipathic, and most
of the time pathetic.&lt;/p&gt;
&lt;p&gt;It&amp;#39;s &amp;quot;villains&amp;quot; however, are fascinating. The first, trade minister Tagomi,
isn&amp;#39;t really a villain so much as a good guy in a government that has
questionable ethical practices. But he does advocate for doing what we&amp;#39;d call
&amp;quot;the right thing&amp;quot; whenever he has the chance.&lt;/p&gt;
&lt;p&gt;The second, chief inspector Kido, is almost Tagomi&amp;#39;s polar opposite. He&amp;#39;s almost
ruthless to a fault, yet the show still manages to give him a human figure. Joel
de la Fuentes&amp;#39; peformance is incredible here, from his clippy delivery to the
skin-deep tension he exudes.&lt;/p&gt;
&lt;p&gt;The third baddie however, is the show&amp;#39;s crowning jewel: SS chief John Smith,
played by a Rufus Sewell at the top of his art (if you haven&amp;#39;t seen &lt;a href=&quot;https://en.wikipedia.org/wiki/Dark_City_(1998_film)&quot;&gt;Dark City&lt;/a&gt;
— a sci-fi movie where he stars — I highly recommend it).&lt;/p&gt;
&lt;p&gt;This is the mosts interesting character of the show, and also the most
conflicted. A former American military man, he changes sides when it&amp;#39;s clear the
Germans cannot be stopped (they invented nuclear weapons first and wiped out
Washington). While never really overjoyed with Nazi policy, he nevertheless goes
up the ranks as a competent man who&amp;#39;ll do whatever it takes to preserve order.
However the show showcases a series of events (notably with regards to his son)
that causes him to question the orthodoxy.&lt;/p&gt;
&lt;p&gt;This could easily go trite, but it doesn&amp;#39;t. John Smith doesn&amp;#39;t have a sudden
change of heart. He&amp;#39;s lost, but continues to do what he knows. He&amp;#39;s definitely a
bad guy, but at the same time, he&amp;#39;s human too.&lt;/p&gt;
&lt;p&gt;So far, I&amp;#39;d say that each season has been better than the previous one. In
particular, the last (third) season finally seems to embrace the aforementioned
character as the interesting locus of the story. I&amp;#39;m eager to see what will
happen next...&lt;/p&gt;
&lt;h2 id=&quot;goblin-slayer&quot;&gt;Goblin Slayer&lt;/h2&gt;
&lt;p&gt;Goblin Slayer was a surprise. The show was being hyped as extremely edgy, and
the first episode made a strong impression in that sense, featuring a jarring
(by anime standards) rape scene.&lt;/p&gt;
&lt;p&gt;But after, it calmed a whole lot — I&amp;#39;m not easily shocked and found it all
mostly tame. Even in anime, Devilman Crybaby (which I haven&amp;#39;t watched (yet?))
does seems to be much much more graphic. To be sure, this is still not a cute
slice of life anime, but you&amp;#39;ve been to the movies before, haven&amp;#39;t you? If
splurging blood bothers you, then this is definitely not for you though.&lt;/p&gt;
&lt;p&gt;Nevertheless, the surprise was that the story actually held up. The premise — a
hero with a cold demeanor that focuses on slaying gobling because of a personal
grudge — was looking more like an excuse for exposition than anything else.&lt;/p&gt;
&lt;p&gt;There isn&amp;#39;t a huge overarching narrative in this first season, but you get to
learn about the characters in an interesting way. The small arcs are engaging,
tension being built in the right place. The combat is dynamic, and you&amp;#39;ll
hopefully appreciate the imagination deployed in the task of slaying goblins.&lt;/p&gt;
&lt;p&gt;In a certain sense, Gobling Slayer did everything right that the third season of
Sword Art Online did wrong, but we&amp;#39;ll talk about that later.&lt;/p&gt;
&lt;h2 id=&quot;psycho-pass&quot;&gt;Psycho-Pass&lt;/h2&gt;
&lt;p&gt;I watched the two seasons of Psycho-Pass. It came highly recommend, but the word
I come from multiple people was that the first season was much better. I
actually thought the second season held up pretty well, even if the first still
has my preference. But more about that later.&lt;/p&gt;
&lt;p&gt;The premise of Psycho-Pass is that in modern-day Japan, people have their
psychological score (a &amp;quot;hue&amp;quot;) and &amp;quot;crime coefficient&amp;quot; monitored. The hue
determines potential in society (along with other psychological assessments),
and the police simply prosecutes people whose crime coefficient crosses a
certain threshold. The show follows a newly minted inspector — Akane Tsunemori —
as she, you guessed it, comes to grapple with the ethics of this dystopian
system.&lt;/p&gt;
&lt;p&gt;The show is wonderful, and you simply have to watch it if you like both sci-fi
and anime. The mood veers slightly Noir and reminded me of Cowboy Bebop a bit
(however, less stylish, but — blessedly — without the slapstick comedy). The
show also has some more philosophical undertones, with big questions being
discussed by the protagonists and many books and philosophers being referenced
throughout the series.&lt;/p&gt;
&lt;p&gt;Regarding the second season, I felt the absence of one of the protagonists of
the first season made quite a bit of difference to the overall mood, and a new
protagonist tends to be too annoying for too long with very little in terms of
closure offered. The villain is also less well-matched to our heros, which makes
the dynamic slightly less interesting.&lt;/p&gt;
&lt;p&gt;On the other hand, the story and the action holds up pretty well. It&amp;#39;s still
really good, but there&amp;#39;s always a cost of following something really great.&lt;/p&gt;
&lt;p&gt;Personally, I really enjoyed seeing the evolution of Akane as a character, and
the second season certainly has something to contribute in that story, somewhat
similarly to Okabe in Steins;Gate 0.&lt;/p&gt;
&lt;h2 id=&quot;briefly-zombie-land-saga-sakamoto-desu-ga&quot;&gt;Briefly: Zombie Land Saga &amp;amp; Sakamoto Desu Ga&lt;/h2&gt;
&lt;p&gt;Here are two shows I watched briefly but dropped after 3 or 4 episodes each.&lt;/p&gt;
&lt;p&gt;Zombie Land Saga is about a guy that resurrect a motley crew of zombie girl in
order to make an idol group to revitalize the Japanese region of Saga. The idea
ain&amp;#39;t bad and there are some funny moments, but I personally found it less
amusing than most (I think I&amp;#39;m maybe just not into anime comedy?). Some really
bad immersion-breaking CG and some boilerplate bullshit anime drama convinced me
to call it quits fairly early.&lt;/p&gt;
&lt;p&gt;I liked Sakamoto Desu Ga (english: &amp;quot;Haven&amp;#39;t you heard? I&amp;#39;m Sakamoto&amp;quot;) much
better. It&amp;#39;s about Sakamoto, a dude that does everything &amp;quot;stylishly&amp;quot;. As the
recurring opening skit will tell you, he&amp;#39;s &lt;a href=&quot;https://www.youtube.com/watch?v=wP2kwMRNMNo&quot;&gt;cool, cooler, coolest&lt;/a&gt; (I&amp;#39;m sad I
couldn&amp;#39;t find the whole sequence, it&amp;#39;s well worth a watch).&lt;/p&gt;
&lt;p&gt;The gags are just so over the top, I think it really works. It didn&amp;#39;t really
hold my attention, but I&amp;#39;m probably going to go back and watch the remainder of
the episodes at some point, when I need something to empty my brain.&lt;/p&gt;
&lt;p&gt;As a teaser, here are two fun compilations of some fun sequences:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=p-RFry9i2Yo&quot;&gt;Sakamoto vs Teacher&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=7a_fSRahE88&quot;&gt;Sakamoto in America&lt;/a&gt; (probably
some kind of bonus)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;net-juu-no-susume-recovery-of-an-mmo-junkie-&quot;&gt;Net-juu no Susume (Recovery of an MMO Junkie)&lt;/h2&gt;
&lt;p&gt;This anime is about a girl &lt;a href=&quot;https://en.wikipedia.org/wiki/NEET#Japan&quot;&gt;NEET&lt;/a&gt; who leaves her work to dedicate herself to
videogames. Romance happens.&lt;/p&gt;
&lt;p&gt;I&amp;#39;m surprised at how little I have to say about Net-juu no Susume... I really
enjoyed watching it. It&amp;#39;s not a masterpiece but it was a very comfortable anime
to me, and I don&amp;#39;t have much criticism to offer.&lt;/p&gt;
&lt;p&gt;Although... It was too short, probably. I would have liked seeing plotlines that
involves the actual game more. And there were just a tad too much happenstances.
Still recommended.&lt;/p&gt;
&lt;h2 id=&quot;sword-art-online-season-3-part-1-&quot;&gt;Sword Art Online Season 3 (Part 1)&lt;/h2&gt;
&lt;p&gt;Sword Art Online has a special spot in my heart as the anime that rekindled my
interest in anime after I&amp;#39;d unfairly dismissed it in the past.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/every-anime/#sword-art-online&quot;&gt;Read my revious review of season 1 and 2.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The anime, is not perfect, and I can forgive much.&lt;/p&gt;
&lt;p&gt;That being said, this season is just plain and irremediably bad.&lt;/p&gt;
&lt;p&gt;Very mild spoilers beyond this point!&lt;/p&gt;
&lt;p&gt;I was on board with the premise: Kirito is once again in a virtual world he
can&amp;#39;t escape, except this time it&amp;#39;s an accelerated simulation and the people
he&amp;#39;s interacting with are actually advanced AIs. The world has grown a magic
system, where incantations are actually game system commands.&lt;/p&gt;
&lt;p&gt;This is cool. But then the anime starts slowly. So slowly. Then it finally hits
its strive somewhere towards the middle (the academy), where, if it doesn&amp;#39;t
manage to be amazing, it&amp;#39;s still failry SAO-esque and showcases interesting
drama.&lt;/p&gt;
&lt;p&gt;The last part is dogshit. The protagonists fight boss after boss in a series of
uninspired fights. It&amp;#39;s like Saint Seya&amp;#39;s golden knight arcs... except much much
worse.&lt;/p&gt;
&lt;p&gt;Consistency goes through the window. The ties/relevance to the system commands
and other system introduced is dubious if not forgotten entirely. Powers (and
power-ups) just happen as &amp;quot;fits&amp;quot; the story... which isn&amp;#39;t even that good.&lt;/p&gt;
&lt;p&gt;The animation is great... but damn, the timing of the scenes doesn&amp;#39;t make sense!
Characters, both heroes and villains, just say standing and talking when
fighting would offer them an overwhelming tactical advantage. Just spouting
inane nonsense besides.&lt;/p&gt;
&lt;p&gt;Kirito actually spends a few (two?) years in the simulation... you&amp;#39;d think it
would be great to showcase how he experiences this, misses his friends and
Asuna? But no. Instead it&amp;#39;s about how noble he is and wants to save all the AIs.&lt;/p&gt;
&lt;p&gt;Anyway, by the end of the show (well, it&amp;#39;s only part one of this season) I was
thoroughly checked out. Even &lt;&lt;em&gt;big emotional moment&lt;/em&gt;&gt; didn&amp;#39;t affect me. I was
just really curious about whether it was a bluff or not.&lt;/p&gt;
&lt;p&gt;So yeah. Hopefully the second half is better, but I have doubts.&lt;/p&gt;
&lt;h2 id=&quot;that-time-i-got-reincarnated-as-a-slime&quot;&gt;That Time I Got Reincarnated as a Slime&lt;/h2&gt;
&lt;p&gt;This is an isekai in which the protoganist dies and gets reincarnated as a slime
(later christened Rimuru) in a game-like universe. But don&amp;#39;t worry — he&amp;#39;s actually
overpowered. He&amp;#39;s about as OP as Ainz Ooal Gown in Overlord.&lt;/p&gt;
&lt;p&gt;In fact, the comparison to Overlord is interesting. Both anime have a large cast
of unique characters, an overpowered leader, and are — narratively — not very
good.&lt;/p&gt;
&lt;p&gt;They&amp;#39;re different though. Overlord is sometimes quite interesting, sometimes
so-bad-it&amp;#39;s-good, and sometimes plain boring. Slime is much more consistent. It
is never &lt;em&gt;boring&lt;/em&gt; per se, but it is never &lt;em&gt;great&lt;/em&gt; either. It feels like as
though what should have been 3 or 4 episodes of setup was copied over 5 times
with different antagonists and called a season. The show mismanages its tension
by having only traces amount of it.&lt;/p&gt;
&lt;p&gt;I&amp;#39;m a story guy, and so I can only be critical of this.&lt;/p&gt;
&lt;p&gt;On the other hand, it&amp;#39;s not &lt;em&gt;bad&lt;/em&gt;. It certainly less bad than the last season of
Sword Art Online. It&amp;#39;s pretty. The characters are well designed and
good-natured. You can almost (almost) see it as a slice-of-life in a fantasy
world, where &amp;quot;life&amp;quot; is fighting the threat du jour (then making an ally out of
it).&lt;/p&gt;
&lt;p&gt;Another thing I got out of this one (and, it must be said, many of the anime on
this list) was dicussing it with good friends who were watching it as well.&lt;/p&gt;
&lt;p&gt;I&amp;#39;ll watch season 2 with curiosity, to see whether the show is set in its way or
if it can evolve into something more interesting. We sure have had enough setup
by now.&lt;/p&gt;
&lt;h2 id=&quot;the-promised-neverland&quot;&gt;The Promised Neverland&lt;/h2&gt;
&lt;p&gt;(This will spoil the premise, which is episode one!)&lt;/p&gt;
&lt;p&gt;An interesting show about a bunch of kids in an orphanage, which realize that
they&amp;#39;re being raised to feed some sort of demons living on the outside. The show
follow them planning their escape attempt.&lt;/p&gt;
&lt;p&gt;It&amp;#39;s a &amp;quot;battle of minds&amp;quot; show (think Death Note or Code Geass) but less
ludicrous than these two (at least, so far) and with also much less action (no
fancy mechas here).&lt;/p&gt;
&lt;p&gt;The anime also features a number of twists. Those are well done in the sense
that they don&amp;#39;t invalidate your prior expectations. You do sense something is
off and there will be something unexpected, you just don&amp;#39;t know what yet.&lt;/p&gt;
&lt;p&gt;It was well worth watching, but I wonder about rewatchability. I think on the
second way around the show must necessarily be somewhat boring, as the plot is
known and the show doesn&amp;#39;t really deliver strong emotion, action or beautiful
animation to compensate. In fact, I&amp;#39;d read the frist volume of the manga before
and as such, the first few episodes were somewhat boring to watch.&lt;/p&gt;
      </description>
      <pubDate>2019-04-21T22:00:00.000Z</pubDate>
      <link>http://norswap.com/even-more-anime</link>
      <guid isPermaLink="true">http://norswap.com/even-more-anime</guid>
    </item>
    <item>
      <title>Language Design Notes 1: A Precise Typeclass Scheme</title>
      <description>
&lt;p&gt;This is the second post in my &lt;strong&gt;&lt;a href=&quot;/language-design-notes/&quot;&gt;Language Design Notes&lt;/a&gt;&lt;/strong&gt; series.&lt;/p&gt;
&lt;p&gt;This instalment is a bit particular, as it outlines pretty precisely (though not
formally) a way to implement &lt;a href=&quot;https://en.wikipedia.org/wiki/Type_class&quot;&gt;typeclasses&lt;/a&gt; in an imaginary (and for the most
part, unspecified) language. Nothing much is assumed about the language — it
isn&amp;#39;t assumed to be purely functional for instance. The syntax is taken to look
a bit like Python (using significant indentation).&lt;/p&gt;
&lt;p&gt;Some context about why I wrote this, lifted from the the &lt;a href=&quot;/language-design-notes/&quot;&gt;series
index&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As I started thinking about typeclasses more, I found the need to write down
some form of specification of the system I was imagining, so that I could
refer to other parts of the design, and see if it was consistent.&lt;/p&gt;
&lt;p&gt;I found the need to be fairly precise. Or maybe I just got carried away... but
I think the precision really helps throw in relief the small detail that
threatens the consistency and elegance of the whole. Anyhow, this ended up
looking more like a specification than a nice explanative article, although I
tried to include enough examples.&lt;/p&gt;
&lt;p&gt;It&amp;#39;s not perfect, but as &lt;a href=&quot;/more-content/&quot;&gt;discussed earlier&lt;/a&gt;, I want thing to move forward, so
here it is!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And that being said, let&amp;#39;s dive right in!&lt;/p&gt;
&lt;h2 id=&quot;declaring-typeclasses-and-instances&quot;&gt;Declaring Typeclasses and Instances&lt;/h2&gt;
&lt;p&gt;This is how you declare a single-parameter typeclass:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Serializable $T
    fun serialize (it: $T): String
    fun deserialize (str: String): $T&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;$T&lt;/code&gt; is a generic type. Generic types all start with a dollar sign. This makes
them easy to pick out and avoids namespace clashes with regular types. It also
dispenses us from declaring which types are generic separately. This is not a
problem for typeclass declarations, but it is for function declaration, where
generic types may be mingled with normal types.&lt;/p&gt;
&lt;p&gt;For instance, java lists the generic types before the function signature:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;T&amp;gt; String serialize (T it);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Haskell uses the scheme we propose, but with lowercase letters for generic
types. We&amp;#39;d like to keep lowercase letters for things in the domain of values,
while things in the domain of types are capitalized. (That being said, types
will also be first-class values in our language.)&lt;/p&gt;
&lt;p&gt;This is how you create an instance of a single-parameter typeclass for a type
called &lt;code&gt;Point&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;instance Serializable Point
    fun serialize (it: Point): String
        return it.x + &amp;quot;,&amp;quot; + it.y
    fun deserialize (str: String): Point
        val strs = str.split(&amp;quot;,&amp;quot;)
        return Point(parse_int(strs[0]), parse_int(strs[1]))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is how you declare a multiple-parameter typeclass:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;enum Order { BIGGER, EQUAL, SMALLER }

class Orderable $X $Y
    fun order (x: $X, y: $Y): Order&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is how you create an instance of a multiple-parameter typeclass for types
&lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Char&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;instance Orderable String Char
    fun order (x: String, y: Char): Order
        if x.size == 0
            return SMALLER
        if x[0] == y
            return x.size == 1 ? EQUAL : BIGGER
        else
            return x[0] &amp;gt; y ? BIGGER : SMALLER&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that both type parameters of &lt;code&gt;Orderable&lt;/code&gt; can be the same type:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;instance Orderable Int Int
    fun order (x: Int, y: Int): Order
        if (x &amp;gt; y) return BIGGER
        if (x &amp;lt; y) return SMALLER
        return EQUAL&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;instances-names&quot;&gt;Instances Names&lt;/h2&gt;
&lt;p&gt;Every instance must have a name. A subsequent section (&lt;a href=&quot;#picking-instances&quot;&gt;Picking
Instances&lt;/a&gt;) will explain why names are needed, but for the
moment bear with me.&lt;/p&gt;
&lt;p&gt;If a name is not given explicitly, it will be generated automatically. For
instance, our &lt;code&gt;Serializable&lt;/code&gt; instance for &lt;code&gt;Point&lt;/code&gt; will be called
&lt;code&gt;Serializable_Point&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can also give a name explicitly. Imagine we want to serialize points using
slashes (/) because of an obscure data format we use:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;instance PointSlash: Serializable Point
    fun serialize (it: Point): String
        return it.x + &amp;quot;/&amp;quot; + it.y
    fun deserialize (str: String): Point
        val strs = str.split(&amp;quot;/&amp;quot;)
        return Point(parse_int(strs[0]), parse_int(strs[1]))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(The definition is the same as &lt;code&gt;Serializable_Point&lt;/code&gt;, except the comma has been replaced by a
slash.)&lt;/p&gt;
&lt;p&gt;This instance will be called &lt;code&gt;PointSlash&lt;/code&gt;. It will not receive an automatically
generated name.&lt;/p&gt;
&lt;p&gt;The scheme to build automatic names for multiple-parameter typeclasses is what
you&amp;#39;d expect , e.g. &lt;code&gt;Orderable_Int_Int&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;deriving-typeclasses-automatically&quot;&gt;Deriving Typeclasses Automatically&lt;/h2&gt;
&lt;p&gt;We can derive a typeclass instance from the existence of another typeclass as
follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;derive instance Orderable $X $Y
        from Reverse: Orderable $Y $X

    fun order (x: $X, y: $Y): Order
        val rev = Reverse.order(y, x)
        if (rev == BIGGER)  return SMALLER
        if (rev == SMALLER) return BIGGER
        return EQUAL&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We call this declaration an &lt;em&gt;instance derivation&lt;/em&gt;. The instance that will
fullfill the from-clause is called the &lt;em&gt;source instance&lt;/em&gt;. The instance derived
from a specific source instance is simply known as a &lt;em&gt;derived instance&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Instance selection will always prefer an explicit instance rather than a derived
instance when both are in the same scope. So our derived &lt;code&gt;Orderable&lt;/code&gt; instance
does not cause issues when &lt;code&gt;$X&lt;/code&gt; and &lt;code&gt;$Y&lt;/code&gt; are the same type. We&amp;#39;ll talk about
this more in the &lt;a href=&quot;#type-derivations-and-instance-selection&quot;&gt;Type Derivations and Instance
Selection&lt;/a&gt; section.&lt;/p&gt;
&lt;p&gt;Just like instances, instance derivations have names. Similarly, they can have
explicit names:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;derive instance Reversed: Orderable $X $Y
        from Reverse: Orderable $Y $X
    // ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But otherwise an automatic name is attributed. For our example, the name would
be &lt;code&gt;Orderable_$X_$Y_from_Orderable_$Y_$X&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A single derivation can yield many different instances. There will of course be
instances with different type arguments, but also instances using a different
source instance.&lt;/p&gt;
&lt;p&gt;Source instances can be given a name (&lt;code&gt;Reverse&lt;/code&gt; in our example) or have a name
assigned automatically — it would be &lt;code&gt;Orderable_$X_$Y&lt;/code&gt; in our example). This,
however, is not the true name of the source instance — which is simply the name
of whatever instance is selected to fullfill the role of the source instance.
Rather it&amp;#39;s an alias that can be used within the definition of the type
derivation. It may happens that this name clashes with previously declared
names. In this case, this name shadows the previous declaration, for the
duration of the type derivation definition. It will be possible to access
file-levels and imported names by prefixing them with a module name — see next
section.&lt;/p&gt;
&lt;p&gt;While we don&amp;#39;t declare derived instances explicitly, they also have names! These
are derived by treating the name of the derivation as a function of the source
instance, e.g. &lt;code&gt;Reversed(Orderable_Int_Int)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;importing-typeclasses-and-instances&quot;&gt;Importing Typeclasses and Instances&lt;/h2&gt;
&lt;p&gt;In this imaginary language, I&amp;#39;ve decided not to specify explicitly how things
can become imported.&lt;/p&gt;
&lt;p&gt;Having nevertheless given it some thought, it appears clear that importing all
instances explicitly would be cumbersome. One could therefore suppose that
typeclass instances will get imported &lt;em&gt;implicitly&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;For instance, we could &lt;strong&gt;imagine&lt;/strong&gt; that if we import a set of types from a file,
then all typeclass instances in the file for that set of types would get
imported implicitly.&lt;/p&gt;
&lt;p&gt;An instance is said to be &lt;em&gt;in scope&lt;/em&gt; of some code if they&amp;#39;re declared in the
same file, or if they&amp;#39;ve been imported (explicitly or implicitly).&lt;/p&gt;
&lt;p&gt;I imagine that this system will rely on a notion of &lt;em&gt;module&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;As such, it will be possible to prefix of an instance or type derivation by the
name of its defining module — with the special keyword &lt;code&gt;self&lt;/code&gt; designating the
current module. e.g. &lt;code&gt;self.Serializable_Point&lt;/code&gt; or
&lt;code&gt;my_module.Serializable_Point&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;default-functions&quot;&gt;Default Functions&lt;/h2&gt;
&lt;p&gt;Typeclass definitions are free to provide default implementations for the
functions they declare. Such a default definition can always be overidden in the
typeclass instances — otherwise it should just be a normal function and not a
typeclass function!&lt;/p&gt;
&lt;p&gt;For instance, the following class includes a default implementation for
&lt;code&gt;receive_all&lt;/code&gt; in terms of its other function &lt;code&gt;receive&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Receiver $T $X
    fun receive (it: $T, item: $X)
    fun receive_all (it: $T, items: List[$T])
        for item in items:
            receive(it, item)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It&amp;#39;s even possible to have two functions in terms of one another — the user
implementing the instance will have to override at least one of them.&lt;/p&gt;
&lt;p&gt;(It would be possible to add language-level support to defining such sets of
functions, at least one of which needs to be overriden, but I&amp;#39;m not sure the
benefits are worth the conceptual overhead.)&lt;/p&gt;
&lt;p&gt;There are essentially two ways to implement default methods. The first is for
them to be some kind of template, specialized for and copied into each instance
that does not override them. The second is to use a late binding mechanism,
which can be especially interesting if the implementation targets supports it
(e.g. the JVM).&lt;/p&gt;
&lt;h2 id=&quot;typeclass-constraints&quot;&gt;Typeclass Constraints&lt;/h2&gt;
&lt;p&gt;There are two places where it&amp;#39;s possible to constrain types based on whether
they possess a typeclass instance: method definition and typeclass declarations.&lt;/p&gt;
&lt;p&gt;Here is a method with a typeclass constraint:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun foo (it: $T) where Serializable $T
    output(serialize(it))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And here is a typeclass with a constraint:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Reducible $T $X
        where Sequential: Sequence $T $X

    fun reduce (it: $T): $X&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The function&amp;#39;s constraint prevents us from calling &lt;code&gt;foo&lt;/code&gt; with a type &lt;code&gt;$T&lt;/code&gt; that
does not have a corresponding &lt;code&gt;Serializable $T&lt;/code&gt; instance.&lt;/p&gt;
&lt;p&gt;Similarly, the typeclass&amp;#39; constraint prevents us from instanciating &lt;code&gt;Reducible&lt;/code&gt;
for pair of types that do not have a corresponding &lt;code&gt;Sequence $T $X&lt;/code&gt; instance.&lt;/p&gt;
&lt;p&gt;We call instances that satisfy a function&amp;#39;s constraints &lt;em&gt;the call instances&lt;/em&gt;,
and the instances that satisfy a typeclass&amp;#39;s constraint the &lt;em&gt;required
instances&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Sometimes, a typeclass with a type constraint can be very close to a type
derivation, especially when the typeclass defines default implementations for
all its functions. The big difference is that a class must still be implemented
explicitly — an implementation has to be requested even if no functions have to
be implemented. A derivation, on the other hand, is always &amp;quot;active&amp;quot;.&lt;/p&gt;
&lt;p&gt;Just like for source instances in type derivations (cf. the &lt;a href=&quot;#deriving-typeclasses-automatically&quot;&gt;Deriving
Typeclasses Automatically&lt;/a&gt; section), the
required instances may be named and have otherwise an automatically generated
name. This is not the &amp;quot;true&amp;quot; instance name, but a local alias that may shadow
previous declarations.&lt;/p&gt;
&lt;p&gt;The other big difference between typeclass declarations with type constraints
and type derivations is &lt;strong&gt;when&lt;/strong&gt; instance selection occurs. We&amp;#39;ll come back to
it in the &lt;a href=&quot;#type-constraints-vs-type-derivations&quot;&gt;Type Constraints vs Type
Derivations&lt;/a&gt; section.&lt;/p&gt;
&lt;h2 id=&quot;picking-instances&quot;&gt;Picking Instances&lt;/h2&gt;
&lt;p&gt;During the execution of our program, there are a couple times when instances
will need to be picked. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Direct instance selection&lt;/em&gt; — when we call a function that belong to a
typeclass, we need to decide which instance will provide the implementation.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Call instance selection&lt;/em&gt; — selecting the instance that satisfies a typeclass
constraint in a function (cf. last section).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Required instance selection&lt;/em&gt; — selecting the instance that satisfies a
typeclass constraint in a typeclass (cf. last section).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Source instance selection&lt;/em&gt; — select the instances used as source for instance
derivations.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Fortunately, all types of instance selections are similar, and follow the same
rules. In each case, we know the typeclass we want to provide an instance for,
and we have to select that instance from those that are in scope and fit the
bill (or emit an error if no instance will do).&lt;/p&gt;
&lt;p&gt;If there is only one instance that works, the language will know to pick it. But
if there are ambiguities, it needs to decide on a particular instance, based on
hints supplied by the programmer.&lt;/p&gt;
&lt;p&gt;We&amp;#39;ll explain the instance selection rules using &lt;em&gt;direct instance selection&lt;/em&gt;,
and add precisions for other types of selections later, as required.&lt;/p&gt;
&lt;h2 id=&quot;direct-instance-selection&quot;&gt;Direct Instance Selection&lt;/h2&gt;
&lt;p&gt;Imagine that we import &lt;code&gt;Serializable_Point&lt;/code&gt; and &lt;code&gt;PointSlash&lt;/code&gt; from before, two
instances of &lt;code&gt;Serializable Point&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;u&gt;Small aside&lt;/u&gt;: it would be more proper to say &amp;quot;two instances of &lt;code&gt;Serializable&lt;/code&gt;
for the type &lt;code&gt;Point&lt;/code&gt;&amp;quot; — but that&amp;#39;s tedious. And what category does &lt;code&gt;Serializable
Point&lt;/code&gt; even belong to? It&amp;#39;s not a typeclass (&lt;code&gt;Serializable&lt;/code&gt; is) nor an instance
(&lt;code&gt;Serializable_Point&lt;/code&gt; is). If we really need a name, we could could this a
&lt;em&gt;typeclass specification&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun foo (it: Point)
    output(serialize(it))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Which instance should this code use?&lt;/p&gt;
&lt;p&gt;We can select the proper instance in two ways:&lt;/p&gt;
&lt;p&gt;1) Specify the instance to use at the instance selection site:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun foo (it: Point)
    output(Serializable_Point.serialize(it))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2) Specify the instance to use in a certain scope (e.g. file or function) with
   an &lt;code&gt;use&lt;/code&gt; declaration.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun foo (it: Point)
    use PointSlash
    output(serialize(it))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Of course, you could do &lt;code&gt;PointSlash.serialize(it)&lt;/code&gt; and &lt;code&gt;use Serializable_Point&lt;/code&gt;
as well.&lt;/p&gt;
&lt;p&gt;When your two instances have automatically generated names which therefore clash
(i.e. both are named &lt;code&gt;Serializable_Point&lt;/code&gt;), you can prefix with module names to
disambiguate them (e.g. &lt;code&gt;self.Serializable_Point&lt;/code&gt; or
&lt;code&gt;my_module.Serializable_Point&lt;/code&gt;) — see the &lt;a href=&quot;#importing-typeclasses-and-instances&quot;&gt;Importing Typeclasses and
Instances&lt;/a&gt; section.&lt;/p&gt;
&lt;p&gt;Regarding &lt;code&gt;use&lt;/code&gt;, the current plan is that it will be possible to override an
&lt;code&gt;use&lt;/code&gt; declaration with another, even in the same scope. For instance:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun foo (it: Point)
    use PointSlash
    output(serialize(it))
    use Serializable_Point
    output(serialize(it))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Nevertheless, &lt;code&gt;use&lt;/code&gt; remains a &lt;em&gt;declaration&lt;/em&gt; whose scope is purely static. It is
not a &lt;em&gt;statement&lt;/em&gt; (and so cannot be guarded by an if statement, etc).&lt;/p&gt;
&lt;h2 id=&quot;type-derivations-and-instance-selection&quot;&gt;Type Derivations and Instance Selection&lt;/h2&gt;
&lt;p&gt;Derived instances do complicate the instance selection mechanism somewhat.&lt;/p&gt;
&lt;p&gt;The basic issue is relatively simple. If there is a conflict between two
instances, and both of these instances can serve as base for the creation of
derived instance, then you&amp;#39;ll have a conflict there as well.&lt;/p&gt;
&lt;p&gt;Consider the following example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Named $T
    fun name (it: $T): String

instance UserFirst: Named User
    fun name (it: User): String
        return it.first_name

instance UserLast: Named User
    fun name (it: User): String
        return it.last_name

class Stringifiable $T
    fun to_string (it: $T): String

derive instance Stringifiable $T from Named $T
    fun to_string (it: $T): String
        return name(it)

fun foo (usr: User)
    output(to_string(usr))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Should &lt;code&gt;foo&lt;/code&gt; output the users&amp;#39;s first or last name? Say we want the last name.&lt;/p&gt;
&lt;p&gt;There is an easy ways to fix that conflict, should write &lt;code&gt;use UserLast&lt;/code&gt;. This
will have the effect of disambiguating the &lt;em&gt;source instance selection&lt;/em&gt; of the
type derivation, hence &lt;code&gt;foo&lt;/code&gt; will use the &lt;code&gt;Stringifiable&lt;/code&gt; instance derived from
&lt;code&gt;UserLast&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But what if we add the following?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;derive instance ThingNamed: Stringifiable $T
        from Named $T
    fun to_string (it: $T): String
        return &amp;quot;the thing named &amp;#39;&amp;quot; + name(it) + &amp;quot;&amp;#39;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we also need to specify which derivation we want. We can do this in a couple
ways:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;use ThingNamed&lt;/code&gt; — always use the &lt;code&gt;ThingNamed&lt;/code&gt; derivation to supply a
&lt;code&gt;Stringifiable&lt;/code&gt; when a &lt;code&gt;Named&lt;/code&gt; instance exists.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ThingNamed.to_string(usr)&lt;/code&gt; — specifying the derivation to use explicitly at
the use site.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;use ThingNamed(UserLast)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ThingNamed(UserLast).to_string(usr)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first solution is a new form of &lt;code&gt;use&lt;/code&gt; which does not specify an instance but
an instance derivation!&lt;/p&gt;
&lt;p&gt;The second solution is symmetric to the first, we use the derivation instead of
an instance at the instance selection site.&lt;/p&gt;
&lt;p&gt;The third and fourth solution have nothing novel: we just specify the full
instance explicitly.&lt;/p&gt;
&lt;p&gt;The first two solutions, however, do require us to have specified &lt;code&gt;use UserLast&lt;/code&gt;
before! Otherwise, we know to use &lt;code&gt;ThingNamed&lt;/code&gt;, but should it use the the
&lt;code&gt;UserFirst&lt;/code&gt; or &lt;code&gt;UserLast&lt;/code&gt; instance?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Using&lt;/strong&gt; an instance derivation demands &lt;em&gt;source instance selection&lt;/em&gt;. This
selection may be done manually (as in &lt;code&gt;use ThingNamed(UserLast)&lt;/code&gt;) or
automatically — if there is no ambiguity or the proper &lt;code&gt;use&lt;/code&gt; statements have
been made.&lt;/p&gt;
&lt;p&gt;Automatic source instance selection may entail a recursion problem when an
instance derivation creates a instance of the same kind as its pre-requisite. We
already saw a derivation like that:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;instance Orderable Int Int
    // ...

// assume we imported this
derive instance Reversed: Orderable $X $Y
        from Reverse: Orderable $Y $X
    // ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I said earlier:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Instance selection will always prefer an explicit instance rather than a
derived instance when both are in the same scope.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;That&amp;#39;s because I assume that within a single file, you&amp;#39;re aware when an explicit
and derived instance clash.&lt;/p&gt;
&lt;p&gt;But it doesn&amp;#39;t work like that when importing one of the two instances. In that
case, the policy is to let them clash to bring awareness to the conflict.&lt;/p&gt;
&lt;p&gt;If you want the base behaviour, you can do &lt;code&gt;use Orderable_Int_Int&lt;/code&gt; and all is
well. But if you want the derived behaviour, you &lt;strong&gt;can&amp;#39;t&lt;/strong&gt; do &lt;code&gt;use Reversed&lt;/code&gt;.
Because that would mean the derivation would use itself as &lt;code&gt;Reverse&lt;/code&gt; — an
infinite recursion. It is therefore a compile-time error.&lt;/p&gt;
&lt;p&gt;The solution in this case is simply to do manual source instance selection, i.e.
specify the full instance name: &lt;code&gt;use Reversed(Orderable_Int_Int)&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;implicit-use&quot;&gt;Implicit &lt;code&gt;use&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;We need to add an important precision to what precedes.&lt;/p&gt;
&lt;p&gt;Whenever there is a typeclass constraint, the constraint acts like an implicit
&lt;code&gt;use&lt;/code&gt; statement!&lt;/p&gt;
&lt;p&gt;So the following pair of functions are always equivalent:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun foo1 (it: $T) where Serializable $T
    output(serialize(it))n

fun foo2 (it: $T) where Serializable $T
    use Serializable_$T
    output(serialize(it))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The same principle applies for typeclass&amp;#39; constraints.&lt;/p&gt;
&lt;h2 id=&quot;type-constraints-vs-type-derivations&quot;&gt;Type Constraints vs Type Derivations&lt;/h2&gt;
&lt;p&gt;When we introduced typeclass&amp;#39; constraints in the &lt;a href=&quot;#typeclass-constraints&quot;&gt;Typeclass
Constraints&lt;/a&gt; section, we said that a big difference
between typeclasses with constraints on the one hand, and type derivations on
the other hand, was that one must always request a typeclass instances, whereas
type derivation are always &amp;quot;active&amp;quot; to generate instances on a by-need basis.&lt;/p&gt;
&lt;p&gt;Now we can introduce another big difference that directly falls out from that
first difference, namely &lt;em&gt;when&lt;/em&gt; instance selection occurs.&lt;/p&gt;
&lt;p&gt;Instances that implement a typeclass with type constraints cause the required
instances to be &lt;em&gt;captured&lt;/em&gt;. This means they&amp;#39;re essentially stored inside the
instance, and their usage is not dependent on the context in which the instance
functions are used.&lt;/p&gt;
&lt;p&gt;For type derivations, it&amp;#39;s some other instance selection that triggers the
source instance selection!&lt;/p&gt;
&lt;p&gt;Just like other forms of instance selection, required instance selection is
affected by &lt;code&gt;use&lt;/code&gt; statements. Manual disambiguation is also possible with the
&lt;code&gt;using&lt;/code&gt; clause.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Foo $T requires Named $T
    // ...

instance FooUser User using LastName
    // ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;On occasions, the capture of required instances, might lead to situations that
are very slightly unintuitive:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Reducible $T $X
        where Sequential: Sequence $T $X

    fun reduce (it: $T): $X

// ...

fun foo (seq: $T) where Reducible $T Point, Sequence $T Point
    reduce(seq)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the above example, there is not guarantee that the instance selected for the
function&amp;#39;s &lt;code&gt;Sequence $T Point&lt;/code&gt; constraint will be the same as the instance
selected for the typeclass&amp;#39; constraint!&lt;/p&gt;
&lt;p&gt;The first one is selected when the instance satisfying &lt;code&gt;Reducible $T Point&lt;/code&gt; is
defined, whereas the second is selected when the function &lt;code&gt;foo&lt;/code&gt; is called.&lt;/p&gt;
&lt;h2 id=&quot;shortcut-notation-for-parameter-types&quot;&gt;Shortcut Notation For Parameter Types&lt;/h2&gt;
&lt;p&gt;We admit a shortcut notation for uses of unary typeclasses, so thoses two
snippets are equivalent:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun foo (mk_string: $A) where Stringifiable $A
    // ...&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;fun foo (mk_string: Stringifiable)
    // ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The second one sure looks nicer!&lt;/p&gt;
&lt;p&gt;There are a few reason not to use the shorthand though:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When you need to express other constraints on the actual type.&lt;/li&gt;
&lt;li&gt;When you need to reuse the actual type for other parameters.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For instance, these two snippets are equivalent:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun foo (mk_string1: $A, mk_string2 $B)
        where Stringifiable $A, Stringifiable $B
    // ...&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;fun foo (mk_string1: Stringifiable, mk_string2: Stringifiable)
    // ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In practice, names will likely need to be attributed to the underlying generic
type when using the shortcut notation. The current plan is to use simple
sequential identifiers preceded by a reserved string (something like &lt;code&gt;__$A&lt;/code&gt;,
&lt;code&gt;__$B&lt;/code&gt;, ...).&lt;/p&gt;
&lt;p&gt;The shortcut notation can also be used for multi-parameter typeclasses, for
instance the two following snippets are equivalent:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun foo (seq: $A) where Sequence $A String
    // ...&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;fun foo (seq: Sequence[String])
    // ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If there are more than two parameters to the typeclass, supplemental parameters
are separated by a comma:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun foo (graph: Graph[Node, Edge]) // Graph $A Node Edge
    // ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is an example notation anyway, but I&amp;#39;m wondering if using &lt;code&gt;Sequence String&lt;/code&gt;
and &lt;code&gt;Graph Node Edge&lt;/code&gt; wouldn&amp;#39;t be more pleasant? If I don&amp;#39;t type need type-level
operators, maybe I&amp;#39;ll do just that.&lt;/p&gt;
&lt;h2 id=&quot;empty-typeclasses&quot;&gt;Empty Typeclasses&lt;/h2&gt;
&lt;p&gt;One may imagine that we will end up with a lot of typeclasses that define
fine-grained behaviours. Some of those will be related by type constraints. It&amp;#39;s
probably a good idea to make it possible to access required instances from the
instance that requires them.&lt;/p&gt;
&lt;p&gt;Sometimes, we would like to bundle a couple of instances together, to compose a
more precise behaviour contract (which is what a typeclass essentially is) from
a bunch of smaller ones.&lt;/p&gt;
&lt;p&gt;In that case, a common pattern would be to use an empty typeclass with a list of
requirements:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class List $T $X where
    Sequential $T $X,
    Indexable $T $X,
    Iterable $T $X&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Assuming we have an instance of this class, we can access the required instances
by dot references: &lt;code&gt;ListInstance.Sequential_$T_$X&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can also bring required instances in scope via some local import statement:
&lt;code&gt;import ListInstance.Sequential_$T_$X&lt;/code&gt;. Or if we want all of them: &lt;code&gt;import
ListInstance.*&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note that importing the instances brings them in scope. It pointedly &lt;em&gt;does not&lt;/em&gt;
resolve ambiguities. It is not an &lt;code&gt;use&lt;/code&gt; statement! (But you can also supply
required instances to &lt;code&gt;use&lt;/code&gt;, of course.)&lt;/p&gt;
&lt;h2 id=&quot;aliases&quot;&gt;Aliases&lt;/h2&gt;
&lt;p&gt;What if you import an instance and the original author hasn&amp;#39;t given it a nice
name? Fortunately for you, the &lt;code&gt;alias&lt;/code&gt; declaration has you covered:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alias PointComma = Serializable_Point&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;alias&lt;/code&gt; work for any kind of names: typeclass derivations, constructed instance
names, ...&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alias Reversed = Orderable_$X_$Y_from_Orderable_$Y_$X
alias ReversedIntComp = Orderable_$X_$Y_from_Orderable_$Y_$X(Orderable_Int_Int)
// or, using the first allias:
alias ReversedIntComp = Reversed(Orderable_Int_Int)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;An alias makes its left and right part interchangeable for code in which the
&lt;code&gt;alias&lt;/code&gt; is in scope. It&amp;#39;s not the same as giving a name to the instance when
it&amp;#39;s declared: in that case, no automatically generated name is attributed!&lt;/p&gt;
&lt;h2 id=&quot;what-remains-to-be-done&quot;&gt;What Remains to be Done&lt;/h2&gt;
&lt;p&gt;This post is long enough as it is (and a dry read besides), so I thought it wise
to stop myself here.&lt;/p&gt;
&lt;p&gt;There are however a few topics that still need consideration to make for a
truly great typeclass system.&lt;/p&gt;
&lt;p&gt;First, what in Haskell are called &lt;em&gt;existentials&lt;/em&gt;, basically a way to have a type
&lt;code&gt;R exists Serializable R&lt;/code&gt; meaning that there exists some type X such that an
instance of &lt;code&gt;Serializable X&lt;/code&gt; exists, but X is not fixed, so that variables of
type &lt;code&gt;R&lt;/code&gt; can take values with different underlying types.&lt;/p&gt;
&lt;p&gt;A value of such a type is a pair of a value and a typeclass (or potentially, a
tuple of multiple values and typeclass instances).&lt;/p&gt;
&lt;p&gt;Most notably, existentials are necessary to implemented &lt;em&gt;heterogeneous
collections&lt;/em&gt; as you can be had in most language, e.g. &lt;code&gt;List&amp;lt;Serializable&amp;gt;&lt;/code&gt; in
Java. Without existentials, it&amp;#39;s impossible to specify a list of values with
different types who happen to have a corresponding &lt;code&gt;Serializable&lt;/code&gt; instance.&lt;/p&gt;
&lt;p&gt;The second important thing is to add some mechanism that help with code reuse.
In particular, some form of delegation or late binding (e.g. Scala traits) would
be neat. Some would advocate that a benefit of type classes is to get rid of
that aspect of OO, but I disagree. The problem in OO in general is that
permissions are too open by default: non-final clases and methods in Java for
instance. As Joshua Bloch puts it in &lt;a href=&quot;https://books.google.be/books/about/Effective_Java.html?id=ka2VUBqHiWkC&amp;amp;redir_esc=y&quot;&gt;Effective Java&lt;/a&gt;: &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Design and document for inheritance or else prohibit it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Well done late binding is effectively a clean way to specify callbacks,
potentially with a default behaviour in place. These callbacks may themselves
call inside the late bound entity (class or typeclass). Effectively, this saves
a lot of plumbing headaches.&lt;/p&gt;
&lt;p&gt;There are a couple more things that could go in, but they aren&amp;#39;t as essential.&lt;/p&gt;
&lt;p&gt;One particular nicety I can think of is a mechanism for type unions. Not only
boring unions (like &lt;code&gt;int | String&lt;/code&gt; to specify you expect either an integer or a
string), but also being able to specify a type &lt;code&gt;R&lt;/code&gt; such that there is either an
instance of &lt;code&gt;Serializable R&lt;/code&gt; or an instance of &lt;code&gt;Stringifyable R&lt;/code&gt; (or both!).
Similar types intersection are already possible, just by putting multiple
constraints on a type.&lt;/p&gt;
&lt;p&gt;These type unions make some &lt;a href=&quot;/polymorphism/#ad-hoc-polymorphism&quot;&gt;ad-hoc polymorphism&lt;/a&gt; possible, and would be further
well served by some form of pattern matching and &lt;a href=&quot;https://en.wikipedia.org/wiki/Flow-sensitive_typing&quot;&gt;flow typing&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But all this will have to wait for another day!&lt;/p&gt;
      </description>
      <pubDate>2019-03-31T22:00:00.000Z</pubDate>
      <link>http://norswap.com/typeclass-scheme</link>
      <guid isPermaLink="true">http://norswap.com/typeclass-scheme</guid>
    </item>
    <item>
      <title>Language Design Notes 0: A Map of Polymorphism</title>
      <description>
&lt;p&gt;This is the first post in &lt;a href=&quot;/language-design-notes&quot;&gt;a series&lt;/a&gt; where I write my thoughts on some aspects
of language design. This first installment will deal with polymorphism, what it
is, and how it manifests in its three main forms, which we review below.&lt;/p&gt;
&lt;h2 id=&quot;ad-hoc-polymorphism&quot;&gt;Ad-Hoc Polymorphism&lt;/h2&gt;
&lt;p&gt;Basically polymorphism has to do with the ability to reuse the same code for
different types of values.&lt;/p&gt;
&lt;p&gt;Dynamically-typed languages are very polymorphic, since any storage location
(variable, field) can hold any value.&lt;/p&gt;
&lt;p&gt;Functions in dynamically-typed language exhibit &lt;strong&gt;ad-hoc polymorphism&lt;/strong&gt;, which
is to say that functions may work even when supplied arguments of different
types.&lt;/p&gt;
&lt;p&gt;Sometimes you just don&amp;#39;t need to know the type of a value. If you&amp;#39;re just going
to store it in a collection, for instance.&lt;/p&gt;
&lt;p&gt;But sometimes it&amp;#39;s ultimately necessary to separate the behaviour for different
types. This is done either through another kind of polymorphism (often
&lt;em&gt;subtyping polymorphism&lt;/em&gt;), or by checking the type explicitly and branching out
in different execution path on that basis. For instance:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def foo(x):
    if type(x) is Bar:
        foo_bar(x)
    elif type(x) is Baz:
        foo_baz(x)
    else
        raise TypeError(&amp;quot;x is neither Bar nor Baz&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Some people also say that &lt;em&gt;overloading&lt;/em&gt; in statically-typed languages (having
multiple functions with the same name, but differing in the type of their
arguments) counts as polymorphism. I&amp;#39;m not anal about definitions, but
overloading isn&amp;#39;t what I&amp;#39;m talking about here.&lt;/p&gt;
&lt;p&gt;The problem is that (unlike every other types of &amp;quot;polymorphism&amp;quot;), overloading
doesn&amp;#39;t compose. The specific overload that gets called must be determined
statically. As such the type must be fully determined — we can&amp;#39;t use a type
parameter (cf. &lt;em&gt;parametric polymorphism&lt;/em&gt;) and the specific subtype (cf.
&lt;em&gt;subtyping polymorphism&lt;/em&gt;) isn&amp;#39;t taken into account.&lt;/p&gt;
&lt;p&gt;Basically, you can never reuse code that calls an overloaded function for
multiple types. Overloading is ultimately just a naming convenience: you could
give each overload its own name and nothing would change. (There is an exception
to that rule, see the discussion of C++ templates below.)&lt;/p&gt;
&lt;p&gt;Nevertheless, ad-hoc polymorphism can also appear in statically typed languages,
either via a super type (e.g. &lt;code&gt;Object&lt;/code&gt; in Java, but any shared super type will
do) or some other wildcard type that is cast-compatible with the others (e.g.
&lt;code&gt;void *&lt;/code&gt; in C). Using these types essentially brings us back to a &amp;quot;dynamically
typed&amp;quot; scenario, except we can&amp;#39;t directly call functions we know exist: we have
to cast the values to their proper types first.&lt;/p&gt;
&lt;p&gt;In statically-typed languages, &lt;a href=&quot;https://en.wikipedia.org/wiki/Flow-sensitive_typing&quot;&gt;flow typing&lt;/a&gt; and union types (e.g. in
&lt;a href=&quot;https://ceylon-lang.org/documentation/1.3/tour/types/&quot;&gt;Ceylon&lt;/a&gt; or &lt;a href=&quot;http://dotty.epfl.ch/docs/reference/new-types/union-types.html&quot;&gt;Scala&lt;/a&gt;) can help make ad-hoc
polymorphism more palatable.&lt;/p&gt;
&lt;h2 id=&quot;subtyping-inclusion-polymorphism&quot;&gt;Subtyping/Inclusion Polymorphism&lt;/h2&gt;
&lt;p&gt;Another popular type of polymorphism is &lt;strong&gt;subtyping (or inclusion)
polymorphism&lt;/strong&gt;. This is your standard object-oriented class and sub-class
scenario, but also includes things like interface implementations, traits, etc.&lt;/p&gt;
&lt;p&gt;This one works for both dynamically- and statically-typed languages. It&amp;#39;s
straightforward in statically-typed languages: you put a type on a parameter,
and the function can also accept any argument that is a subtype of that type.&lt;/p&gt;
&lt;p&gt;Dynamically-typed languages of the OO variety also have inheritance, but in that
case I&amp;#39;m not sure if it should be considered as subtyping or ad-hoc polymorphism
(and it matters little). The thing is that you can have OO polymorphism without
even sharing a superclass. A function can call a method on an object, and has
long as the object does implement a method by that name, it will work.&lt;/p&gt;
&lt;p&gt;Said otherwise, the interfaces can be left implicit, the following method is
polymorphic for any object that has both a &lt;code&gt;bar()&lt;/code&gt; and &lt;code&gt;baz()&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def foo(x):
    x.bar()
    x.baz()&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;parametric-polymorphism&quot;&gt;Parametric Polymorphism&lt;/h2&gt;
&lt;p&gt;Finally, last of the big three, we have &lt;strong&gt;parametric polymorphism&lt;/strong&gt;. There are a
few famous examples of that: generics in Java and C#, templates in C++.
Basically you endow bits of code (typically functions and data structures) with
type parameters that allow specializing the code for the given type.&lt;/p&gt;
&lt;p&gt;At its most basic, parametric polymorphism for functions is the equivalent of
ad-hoc polymorphism for statically-typed languages: it allows you to call the
same code with values different types, but also preserves the specific type
being used.&lt;/p&gt;
&lt;p&gt;Since the parametrized code must range over multiple types, the available
information is limited. At worse, you know nothing, but you can also have a
&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/generics/bounded.html&quot;&gt;type bound&lt;/a&gt; that gives a common supertype (if also using &lt;em&gt;subtyping
polymorphism&lt;/em&gt;) or some other information that constraint the valid type
arguments.&lt;/p&gt;
&lt;p&gt;So, like ad-hoc polymorphism, if you ultimately want to do something specific to
the actual type, you either have to perform a cast, or rely on subtyping polymorphism.&lt;/p&gt;
&lt;p&gt;We can further distinguish different realization of parametric polymorphism.
With Java and C# generics, the same (binary) code is used regardless of the
actual type arguments being used. In C++ templates, the code is automatically
duplicated and specialized for the specific type arguments. This has both pros
and cons. While Java/C# are limited to accepting object types (i.e. pointers) as
type arguments, C++ can accept any pointer, structure or primitive type — even
if they have different size in memory. The downside is that all the duplication
can bloat the binary size, something significantly so.&lt;/p&gt;
&lt;p&gt;C++ templates are essentially a form of (turing-complete!) macro-expansion. They
are compiled using something called &amp;quot;two phase lookup&amp;quot;. The template definition
is checked for basic syntactic errors, but the check for the existence of the
function calls in the template only occurs when the template is instantiated for
particular type arguments. An interesting consequence of this is that templates
can &amp;quot;redeem&amp;quot; overloading: the same source code can now call different overloads
by virtue of being specialized automatically by C++.&lt;/p&gt;
&lt;p&gt;And by the way, yes, C macros can also be regarded as polymorphism. They can
redeem overloading in the same way as templates, though C doesn&amp;#39;t have
overloading — but that can be papered over by using the &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Typeof.html&quot;&gt;&lt;code&gt;typeof&lt;/code&gt; GCC
extension&lt;/a&gt;. A big difference is that C macros cannot be called automatically —
if you write a specializable function with it, you&amp;#39;ll have to instantiated it
yourself for any type you want to use it with! More advanced types of macros
(e.g. Lisp macros) may take things even further.&lt;/p&gt;
&lt;p&gt;Java and C# generics also differ in one different respect: the erasure or
reification of type arguments. C# actually makes the type arguments available to
the user code, which can use it to perform type checks, type casts, type
reflection... Type arguments are essentially converted to additional arguments
of the generic function. Java, on the other hand, &lt;em&gt;erases&lt;/em&gt; the type arguments
form the bytecode it generates, so the aforementioned use cases are not
possible.&lt;/p&gt;
&lt;p&gt;Downsides of reified generics? Apparently, performance. It&amp;#39;s hard to find a good
analysis of that claim, but Gilad Bracha &lt;a href=&quot;https://gbracha.blogspot.com/2018/10/reified-generics-search-for-cure.html&quot;&gt;made it&lt;/a&gt; based on his
work on the Dart VM, and I&amp;#39;m inclined to believe it. Still the statement isn&amp;#39;t
qualified: how bad is it, really?&lt;/p&gt;
      </description>
      <pubDate>2019-03-23T23:00:00.000Z</pubDate>
      <link>http://norswap.com/polymorphism</link>
      <guid isPermaLink="true">http://norswap.com/polymorphism</guid>
    </item>
    <item>
      <title>Language Design Notes</title>
      <description>
&lt;p&gt;I&amp;#39;m starting a new series on (more or less) disjointed notes on programming
langauge design and related concepts.&lt;/p&gt;
&lt;p&gt;This is the work-in-progress index to the series, which also gives a bit more
context about each post.&lt;/p&gt;
&lt;h3 id=&quot;0-a-map-of-polymorphism&quot;&gt;&lt;a href=&quot;/polymorphism&quot;&gt;0. A Map of Polymorphism&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The original impetus for the series was to write about a couple ideas I had for
language design. The first idea was to use &lt;a href=&quot;https://en.wikipedia.org/wiki/Type_class&quot;&gt;typeclasses&lt;/a&gt; extensively, but freed
of their Haskell shackle.&lt;/p&gt;
&lt;p&gt;As a way to introduce the topic, I wrote an overview of the different types of
polymorphisms. This ended up quite disjointed from what I have now written on
typeclasses (I&amp;#39;m not done yet). Nevertheless, it&amp;#39;s not too shabby as a reference
on polymorphism, so here goes!&lt;/p&gt;
&lt;h3 id=&quot;1-a-precise-typeclass-scheme&quot;&gt;&lt;a href=&quot;/typeclass-scheme&quot;&gt;1. A Precise Typeclass Scheme&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As I started thinking about typeclasses more, I found the need to write down
some form of specification of the system I was imagining, so that I could refer
to different parts of the design, and see if the whole was consistent.&lt;/p&gt;
&lt;p&gt;I found the need to be fairly precise. Or maybe I just got carried away... but I
think the precision really helps throw in relief the small details that
threatens the consistency and elegance of the whole. Anyhow, this ended up
looking more like a specification than a nice explanative article, although I
tried to include enough examples.&lt;/p&gt;
&lt;p&gt;It&amp;#39;s not perfect, but as &lt;a href=&quot;/more-content/&quot;&gt;discussed earlier&lt;/a&gt;, I want thing to move forward, so
here it is!&lt;/p&gt;
      </description>
      <pubDate>2019-03-23T23:00:00.000Z</pubDate>
      <link>http://norswap.com/language-design-notes</link>
      <guid isPermaLink="true">http://norswap.com/language-design-notes</guid>
    </item>
    <item>
      <title>More Content, Less Perfectionism</title>
      <description>
&lt;p&gt;I want to be writing more here in the near future.&lt;/p&gt;
&lt;p&gt;I have some stuff in the pipe, but an issue I keep running into is
perfectionism.&lt;/p&gt;
&lt;p&gt;Perfectionism can be a good thing, it&amp;#39;s what made write the super complete
&lt;a href=&quot;http://norswap.com/ruby-dark-corners/&quot;&gt;Ruby&amp;#39;s Dark Corners&lt;/a&gt; series.&lt;/p&gt;
&lt;p&gt;On the other hand, I probably could put out more stuff if I accepted to just
publish bits and pieces as I write them. The issue is that often, there needs to
be some kind of internal consistency to a series, and I&amp;#39;m uneasy to put out the
first part if I think the later part might make me to wish to edit it (which it
usually does).&lt;/p&gt;
&lt;p&gt;But publishing things feels good! It feels like momentum and progress being
done. Some of my other post series have been done in a much more &amp;quot;good enough&amp;quot;
spirit, including my notes on weight-lifting and anime opinions. Let&amp;#39;s do more
of that.&lt;/p&gt;
&lt;p&gt;So, in the spirit of experimentation, I&amp;#39;m going to try to put out more stuff,
including stuff that isn&amp;#39;t as finished as I would like it to be.&lt;/p&gt;
&lt;p&gt;After all, nothing prevents me to re-edit it later, if that&amp;#39;s what I really
wish.&lt;/p&gt;
&lt;p&gt;More broadly, I&amp;#39;d like to apply this philosophy to more than just writing on my
blog, but it&amp;#39;s a good start. And I want to write about what I do on my blog
anyway, so starting here will impact the rest.&lt;/p&gt;
&lt;p&gt;Head nod to Venkatesh Rao&amp;#39;s idea of &lt;a href=&quot;https://www.ribbonfarm.com/series/mediocratopia-2/&quot;&gt;mediocrity being actually
good&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;First thing coming up is going to be articles in a series of more or less
disjointed notes about language design and relevant concepts.&lt;/p&gt;
&lt;p&gt;I also want to publish a more shorter things, mostly highlighting cool things
I&amp;#39;ve encountered elsewhere — without the need to add much value personally.&lt;/p&gt;
&lt;p&gt;See you soon!&lt;/p&gt;
      </description>
      <pubDate>2019-03-23T23:00:00.000Z</pubDate>
      <link>http://norswap.com/more-content</link>
      <guid isPermaLink="true">http://norswap.com/more-content</guid>
    </item>
    <item>
      <title>Elegant Optional Arguments in Java</title>
      <description>
&lt;p&gt;Today, an adventure in programming in the in-between, not quite programming in
the small, not quite in the large either.&lt;/p&gt;
&lt;p&gt;The problem is that we would like to have a Java method (or constructor) with
optional parameters: parameters who take default value as arguments if not
supplied.&lt;/p&gt;
&lt;p&gt;The standard way to do this would be to generate overloads with only a subset of
arguments. This is of course exponential in the number of optional parameters:
with four of them, we&amp;#39;re already generating 16 overloads! It&amp;#39;s also dependent on
optional parameters not sharing the same type, and requires one to remember the
ordering of parameters.&lt;/p&gt;
&lt;p&gt;A better solution: create a configuration object to hold all optional arguments.
This is good, but shifts the issue of optional parameters to the instantiation
of the configuration object. One solution is have a no-argument constructor and
use setters to specify the non-default values. This can be relatively terse and
elegant by means of the &lt;a href=&quot;https://dzone.com/articles/design-patterns-the-builder-pattern&quot;&gt;builder pattern&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It&amp;#39;s also possible to forego the configuration object and store the
configuration directly on the concerned object. But there is the risk to clutter
the object, muddling the public interface of the class. It&amp;#39;s better to separate
concerns so that configuration data is separate from other fields (&amp;quot;work data&amp;quot;,
stored items, ...).&lt;/p&gt;
&lt;p&gt;And there you have it, if you require more than one or two optional parameters,
or you feel the set of optional parameters may grow, consider whipping up
configuration object with the builder pattern!&lt;/p&gt;
      </description>
      <pubDate>2019-02-12T23:00:00.000Z</pubDate>
      <link>http://norswap.com/java-optional-parameters</link>
      <guid isPermaLink="true">http://norswap.com/java-optional-parameters</guid>
    </item>
    <item>
      <title>More Weightlifting Observations</title>
      <description>
&lt;p&gt;Previously: &lt;a href=&quot;/weight-training&quot;&gt;Starting Weight Training&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;progression&quot;&gt;Progression&lt;/h2&gt;
&lt;p&gt;The &lt;a href=&quot;/weight-training&quot;&gt;first post&lt;/a&gt; was written two months after I started training. It&amp;#39;s now been
about 7 months. The time the post was written ended up being somewhat
unfortunate, because I almost immediately had to deload some of my lifts. My
squat form was slightly subpar, and I deloaded the row and the bench press as
part of the program: if you can&amp;#39;t progress three times straight, you deload.
Some form tweaks were also applied.&lt;/p&gt;
&lt;p&gt;Here&amp;#39;s what total progress looks like. The screencap in &lt;a href=&quot;/weight-training&quot;&gt;last post&lt;/a&gt;
was taken around the 19th of May.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;weights.png&quot; alt=&quot;Graph of weight lifted over time.&quot;&gt;&lt;/p&gt;
&lt;p&gt;You can see dips for the previously mentionned lifts in between the 11 May and
22 June bars. You should ignore the sharp dips right after the 22 June bar —
that&amp;#39;s an anomaly that occured because I changed the weights one day to make up
for having only one hour to spend at the gym.&lt;/p&gt;
&lt;p&gt;Something interesting is the huge barbell row dip. In short, I was doing barbell
row completely wrong. Part of the problem is my size: for proper form (back
horizontal) I&amp;#39;m forced to almost press my stomach to my tights, which I wasnt
doing. It&amp;#39;s also possible that lack of strength in my upper back caused other
muscles to compensate. Anyway, I finally feel like I &amp;quot;get&amp;quot; the exercise and I
can feel its effects, whereas previously it seemed pointless, too easy, and the
form was hard to judge.&lt;/p&gt;
&lt;p&gt;All other dips in the graph are simply the normal &amp;quot;deload on failure&amp;quot; mechanism
kicking in. I particularly remember the squat one towards the end, which
occurred after I came back from my Ireland trip.&lt;/p&gt;
&lt;p&gt;Not represented in the graph, but highly relevant is the fact that I switched to
3x5 (down from 5x5) on the squat and on the bench press, at the beginning of
this month. It&amp;#39;s what the Stronglift program &lt;a href=&quot;https://stronglifts.com/5x5/#321553215312153&quot;&gt;advises&lt;/a&gt;. In fact, had I read that
part carefully, I might have done it earlier:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is one way to know if it’s time to switch from 5×5 to 3×5. If your
workouts are taking two hours because you have to rest 10mins between sets to
get 5×5… you’re probably overdoing it. Don’t get stubborn about sticking with
5×5. Switch to 3×5 so you can continue to make progress.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I only ever did 3-4 mins rests between sets (and 5 on failure), but my workouts
did (and honestly still do) take 2 hours. I progressed though, so it might have
been for the best that I sticked to 5x5.&lt;/p&gt;
&lt;p&gt;Another part that caught my eye:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;5×5 doesn’t work forever. Nothing does. The stronger you get, the heavier the
weights you can lift, and thus the bigger the stress of each 5×5 workout. That
stress eventually becomes too big for your body to recover from by the next
workout. You don’t get stronger in time so you fail reps.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And that was exactly the situation in September, in fact it had been for some
time (at least one month). I was feeling physically quite tired a lot of the
time. Not really like brain fog, but much more like I&amp;#39;d been doing hard manual
labor all day.&lt;/p&gt;
&lt;p&gt;Switching to 3x5 helped, but I took it further, and since two weeks I&amp;#39;m only
doing two workouts a week instead of three. With three workouts I was feeling I
really didn&amp;#39;t have enough time to recover and consolidate my gains — especially
when there was only one resting day in between workouts, and especially on the
squat which is done on every workout. I&amp;#39;m feeling pretty good about this right
now (not to mention the time savings), but we&amp;#39;ll see how it works out in the
long run.&lt;/p&gt;
&lt;h2 id=&quot;nutrition&quot;&gt;Nutrition&lt;/h2&gt;
&lt;p&gt;At some point, I really realized I needed to eat more to be able to progress.
After some experiments, I&amp;#39;ve settled on taking bigger dinners (which were
usually lighter for me), as well as occasionally indulging in some more proteins
at lunch. I also try to be more consistently taking protein shakes twice a day.&lt;/p&gt;
&lt;p&gt;Speaking about protein shakes, I&amp;#39;ve switched to Optimum Nutrition &lt;a href=&quot;https://www.amazon.fr/OPTIMUM-NUTRITION-Standard-Prot%C3%A9ine-Chocolat/dp/B000QSNYGI&quot;&gt;Gold Standard
Whey&lt;/a&gt;, double chocolate flavor, after a friend recommended it to me. I mix that
with milk, and the result is that it tastes a bit like milk with cocoa powder.
Finally, proteins that don&amp;#39;t taste FOUL. Thanks god.&lt;/p&gt;
&lt;p&gt;Something disappointing regarding nutrition is that since I started lifting, it
seems like my body fat percentage didn&amp;#39;t really move. I didn&amp;#39;t measure it with
any precision, but while it&amp;#39;s clear I have more muscles, it isn&amp;#39;t clear at all
that I have less fat. This is annoying, because my primary objective was to look
better... I&amp;#39;ve drifted from that somewhat (discussion in the next section) but
it would be cool if I could do something about it without jeopardizing muscle
gains too much.&lt;/p&gt;
&lt;p&gt;My current idea is to try some form of intermittent fasting (IF). I almost
already do an 8/16 IF split where I eat only during at 8 hour window
(12:00-20:00), but I&amp;#39;m not being strict about it — I usually have some fruits or
nuts in the morning, dessert in the evening, and protein shakes of course. I
want to try being extra strict and see if it enables some fat loss.&lt;/p&gt;
&lt;p&gt;If that doesn&amp;#39;t work, I might try another of IF, which I&amp;#39;ll refer to as &amp;quot;day
fasting&amp;quot;: fast one or more whole day in the week. Some popular approaches are
alternate-day fasting (but that&amp;#39;s too much while doing the gym) and &lt;a href=&quot;https://leangains.com/&quot;&gt;Leangains&lt;/a&gt;
(twice a week + additional dietetic advice). I&amp;#39;d just do a single day with no
more constraints honestly.&lt;/p&gt;
&lt;p&gt;And if &lt;em&gt;that&lt;/em&gt; does not work, I guess I&amp;#39;ll need to revert to theh good old &amp;quot;cut&amp;quot;:
losing fat while preventing muscle loss. Apparently it&amp;#39;s much harder to gain
muscle than to prevent the loss of already existing muscle.&lt;/p&gt;
&lt;h2 id=&quot;sleep&quot;&gt;Sleep&lt;/h2&gt;
&lt;p&gt;During the period where I was feeling very tired, I started noticing a few
effects that would definitely help my gym performance. Having some caffeine in
the morning, and some light breakfast (e.g. a fruit and a toast) before lifting
helped somewhat. Lifting in the afternoon rather than in the morning helped more
(and I&amp;#39;m now usually lifting Wednesday and Sunday afternoon). But most of all, a
good night sleep was necessary: a short night of sleep would ruin my chances at
breaking through a plateau.&lt;/p&gt;
&lt;p&gt;I&amp;#39;ve started tracking my sleep using the &lt;a href=&quot;https://sleep.urbandroid.org/introducing-sonar-as-sensor/&quot;&gt;sonar tech&lt;/a&gt; of the application &lt;a href=&quot;https://play.google.com/store/apps/details?id=com.urbandroid.sleep&quot;&gt;Sleep
as Android&lt;/a&gt;. From my research on the topic, the tracking of sleep phases doesn&amp;#39;t
really seem to be accurate. However, using the app has been an effective
incentive to get my average time in bed to 8 hours / night over the past month.&lt;/p&gt;
&lt;p&gt;I did an experience a couple years ago — while writing my master thesis — where
I would not set any alarm clock and sleep as long as my body would require for a
few months. The results was that after a brief adjustment period where I sleeped
A LOT, I ended up sleeping 9 hours every night. Which is still a lot more than
most people get. This doesn&amp;#39;t seem to have changed (or maybe has worsened), as
even when I sleep 8.5 hours, I never wake up naturally but always from my alarm
clock.&lt;/p&gt;
&lt;p&gt;I&amp;#39;m hoping I can try to increase my sleep even further, since apparently that&amp;#39;s
what I need. It seems to help the lifting anyhow, at least when combined with
the switch to a twice-a-week rythm.&lt;/p&gt;
&lt;h2 id=&quot;objectives-&quot;&gt;Objectives?&lt;/h2&gt;
&lt;p&gt;In my last post, I set some objectives after which to re-evaluate my training
regimen. Namely: 96kg on squat, 72kg on bench press, 120kg on deadlift and 48kg
on overhead press. I&amp;#39;ve blown past all of those, and haven&amp;#39;t changed.&lt;/p&gt;
&lt;p&gt;One reason is &amp;quot;don&amp;#39;t change something that works&amp;quot; and the program kept working
for me.&lt;/p&gt;
&lt;p&gt;However, one of my initial objectives was to look better. And I did look better
when I wrote last post compared to two months prior, and I do look even better
now. But it&amp;#39;s a quite subtle improvement for the amount of work put in.&lt;/p&gt;
&lt;p&gt;The problem is two-fold: first, I have too much fat and that hinders muscle
definition; second, I experience relatively little muscle hypertrophy (my
muscles are strong, but not that big).&lt;/p&gt;
&lt;p&gt;(However, I&amp;#39;ll note my weight gains have been relatively steady, following an
initial burst. I&amp;#39;m now at 86kg.)&lt;/p&gt;
&lt;p&gt;There are well-known easy solutions for those things: go into a cut to get rid
of the fat (cf. last section) and switch to a hypertrophy/bodybuilding program
for muscle growth.&lt;/p&gt;
&lt;p&gt;The thing is... I have some aversion to switching from the path delineated by
the program and its advanced versions. One reason might be
familiarity/change-aversion. Another is that I really enjoy constantly beating
my records and seeing the numbers go up. I&amp;#39;m also quite curious. How far can I
go? If I stop on the strength training path, will I ever be able to come back
and see? Doubtful.&lt;/p&gt;
&lt;p&gt;I guess I could alternate hypertrophy and strength training, at least experiment
to see if it&amp;#39;s a viable strategy. But I&amp;#39;m still progressing with the current
strategy, and it has well-defined changes to implement in case I stall anyway
(go to 3x5 than 3x3, switch to &lt;a href=&quot;https://stronglifts.com/madcow-5x5/&quot;&gt;Madcow&lt;/a&gt;, switch to &lt;a href=&quot;https://stronglifts.com/stronglifts-advanced-strength-muscle-building-training-program/&quot;&gt;StrongLifts advanced&lt;/a&gt;,
switch to &lt;a href=&quot;https://old.reddit.com/r/Fitness/wiki/recommended_routines&quot;&gt;5/3/1&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;The trade-off outlined before me is simple: risk being unoptimal — maybe I would
look better and be stronger faster if I alternated hypertrophy with strength
training; or risk completely wasting my time and jeopardize my motivation — if I
blow the hypertrophy approach or it doesn&amp;#39;t end up being beneficial for my
strength.&lt;/p&gt;
&lt;p&gt;For now I&amp;#39;m staying on the straigth and narrow, but I&amp;#39;m open to re-evaluate when
the time comes.&lt;/p&gt;
      </description>
      <pubDate>2018-10-26T22:00:00.000Z</pubDate>
      <link>http://norswap.com/weight-training-2</link>
      <guid isPermaLink="true">http://norswap.com/weight-training-2</guid>
    </item>
    <item>
      <title>Static Website Generation, Incrementally</title>
      <description>
&lt;p&gt;The piece of Javascript that generates this very website has to be one of the
most zen piece of code I ever wrote. I wrote about it in &lt;a href=&quot;http://norswap.com/ribosome-static-site/&quot;&gt;an article back in
2016&lt;/a&gt;. It has served me well since, and hasn&amp;#39;t broken on me the way
that I would have expected something written in Ruby to do.&lt;/p&gt;
&lt;p&gt;Yet not all was perfect. The whole website took mabye 15-20 seconds to generate,
and complete generation was the only option.&lt;/p&gt;
&lt;p&gt;With that in mind, it was my project to implement incremental generation: only
re-generate the parts of the content that have actually changed. I also wanted a
&lt;em&gt;watch&lt;/em&gt; feature: the ability to auto-regenerate content whenever I saved a
source file.&lt;/p&gt;
&lt;p&gt;I&amp;#39;ve achieved these objectives, and this blog post is about that. Before I dive
in, however, a remark with the benefit of hindsight. Should I have done this at
all? The &lt;em&gt;watch&lt;/em&gt; feature had to be done, but otherwise, if my objective was to
speed up generation, maybe I should have gone and figured exactly why the
generation process was so slow... because 15-20 seconds for ~50 blog posts is
VERY slow, even for Javascript. I haven&amp;#39;t done that, but I think I should have.&lt;/p&gt;
&lt;p&gt;Now for the good part. &lt;a href=&quot;https://github.com/norswap/norswap.github.io/blob/f643a18ef7681ecfc176265ae66629decc19ec1e/.factory/generate.js&quot;&gt;Here&amp;#39;s the resulting code.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The process started with a lot of refactoring: pounding what was essentially a
linear script into functions that could be reused.&lt;/p&gt;
&lt;h2 id=&quot;async-await-fun&quot;&gt;Async/Await Fun&lt;/h2&gt;
&lt;p&gt;As part of that refactoring, I also made sure that all the calls that touched
the file systems were now using &lt;a href=&quot;https://javascript.info/async&quot;&gt;promises with async and await&lt;/a&gt;. This was
mostly for fun and my own education, because &lt;a href=&quot;http://sustrik.github.io/ribosome/&quot;&gt;Ribosome&lt;/a&gt; — the templating library
I use — is fully synchronous. I also think it might be responsible for the slow
execution times (or maybe just my use of it which involve writing then reading
to a temp file once per post), but that&amp;#39;s an investigation for another day.&lt;/p&gt;
&lt;p&gt;I think async is great however, although there were a few pitfalls I fell right
in. As you may know, using async functions guarantees linear execution without
crazy callback pyramid of doom... if you use the &lt;code&gt;await&lt;/code&gt; keyword! It&amp;#39;s easy to
forget it and it causes no warning (by design, this is not a complain).&lt;/p&gt;
&lt;p&gt;Async also required me to get ... creative in one instance. The package I use
for watching the file system takes a callback to which it supplies an array of
events that occured since last time the callback was called. The problem is that
this callback is never &lt;code&gt;await&lt;/code&gt;ed, even if it returns a promise. As such, if you
do async stuff within that callback (and I did), it&amp;#39;s very possible that the
package will fire another callback before the last one finished processing. This
was not acceptable to me: each set of filesystem changes had to be fully
processed before the processing of the nex tone began.&lt;/p&gt;
&lt;p&gt;Here is how I solved it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;async function watch()
{
    let lock = Promise.resolve()
    ...
    const watching = await watcher(..., async (events) =&amp;gt; {
        let resolve
        const old_lock = lock
        lock = new Promise((r, _) =&amp;gt; resolve = r)
        await old_lock
        ...
        // process events
        ...
        resolve()
    })
    watching.start()
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Basically, each invocation of the callback creates a &amp;quot;lock&amp;quot; object, which is an
unfullfilled promise. It then waits on the previous lock to be fullfilled. Only
when it has finished processing does if fullfill (&lt;code&gt;resolve&lt;/code&gt;) its own lock.
Notice that since code is never executed in parallel, it&amp;#39;s perfectly safe to use
a &amp;quot;global&amp;quot; variable to save the last lock. Each successive callback invocation
creates a copy of the last lock then replaces it with its own. This ensures that
only a single callback may be waiting on a lock, and thus there is no data race:
the callbacks are serialized neatly, each waiting on the previous callback&amp;#39;s
lock to be fullfilled.&lt;/p&gt;
&lt;h2 id=&quot;incremental-index-pages&quot;&gt;Incremental Index Pages&lt;/h2&gt;
&lt;p&gt;Architecturally, the big challenge was how to regen index pages without having
to reprocess every blog post ever.&lt;/p&gt;
&lt;p&gt;The problem occurs for instance when you add a new post: all the index pages
have to have their post shifted backwards one unit. Reparsing the HTML would
have been a possibility, although I didn&amp;#39;t once contemplate it. It&amp;#39;s still a bit
ugly in my mind as the HTML page is a product, not a source. But it might
actually have worked.&lt;/p&gt;
&lt;p&gt;What I ended up doing instead is create a file called &lt;code&gt;posts.json&lt;/code&gt; that
serialized all the needed post data. This includes title, date, layout type, as
well as content for (a) posts that need to appear in the &lt;a href=&quot;/atom.xml&quot;&gt;atom feed&lt;/a&gt; and (b)
posts whose layout is &lt;code&gt;brief&lt;/code&gt;, i.e. posts whose content appears directly on the
index pages.&lt;/p&gt;
&lt;p&gt;I also pushed the vice further, and only regenerated the index pages that
actually needed to. For instance, if I removed the very first post, only the
last index page would have to be regenerated. I didn&amp;#39;t push this as hard as I
could have: for instance renaming a post will also cause all subsequent index
pages to be regenerated, when there is really no need to.&lt;/p&gt;
&lt;h2 id=&quot;filesystem-watching-frustrations&quot;&gt;Filesystem Watching Frustrations&lt;/h2&gt;
&lt;p&gt;The only frustrating thing I had to deal with was the filesystem watching
libraries.&lt;/p&gt;
&lt;p&gt;This was further compounded by a dumb mistake of my own which made my whole
prior evaluation of libraries irrelevant. I don&amp;#39;t even remember what it was I
did, but it caused me to think the libraries were malfunctioning while it was me
that was actually being a dumbass.&lt;/p&gt;
&lt;p&gt;Anyway, here are the libraries that I considered, and should reconsider at some
point in the future:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/chokidar&quot;&gt;Chokidar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/nsfw&quot;&gt;nsfw&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/@atom/watcher&quot;&gt;@atom/watcher&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/fb-watchman&quot;&gt;fb-watchman&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There is also the built-in &lt;code&gt;fs.watch&lt;/code&gt;, but the &lt;a href=&quot;https://www.npmjs.com/package/chokidar&quot;&gt;Chokidar&lt;/a&gt; page reports that it
has a slew of issues, which I am inclined to believe.&lt;/p&gt;
&lt;p&gt;I ended up going with &lt;code&gt;nsfw&lt;/code&gt; as it was the one I had setup when I finally
understood my mistake. However I cannot recommend it, it works quite shittily,
at the very least on Windows. Amongst the issue I had to contend with and hack
around:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Duplicate events.&lt;/li&gt;
&lt;li&gt;File renaming causes a creation event on the old file and a modify event on
the new file (in addition to the renaming event).&lt;/li&gt;
&lt;li&gt;File creation also causes a modify event on the created file (in addition to
the creation event).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These may just be &lt;code&gt;fs.watch&lt;/code&gt; issues that &lt;code&gt;nsfw&lt;/code&gt; didn&amp;#39;t guard against though...&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nsfw&lt;/code&gt; also has different dependencies for Windows and MacOS, which causes some
trouble for me, as I have my code on Dropbox so that I may seamlessly switch
from my laptop to my desktop without requiring a dirty commit (it&amp;#39;s on Git as
well, don&amp;#39;t worry).&lt;/p&gt;
&lt;p&gt;Also note that the &lt;code&gt;@atom/watcher&lt;/code&gt; is different from the original &lt;code&gt;watcher&lt;/code&gt; lib,
which doesn&amp;#39;t build anymore. I think the build script is the only thing that has
been altered however.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fb-watchman&lt;/code&gt; required an OS-specific software install outside of NPM.&lt;/p&gt;
&lt;p&gt;One of the tools required some Windows build tools to be installed globally (you
could install it locally, but it&amp;#39;s huge). Another one (or the same, I don&amp;#39;t
remember) required a flag to ask for Python 2.7.&lt;/p&gt;
&lt;p&gt;All in all, this was a bit of a headache.&lt;/p&gt;
&lt;p&gt;If you were to try one of those, my hunch and the above tells me to go with
Chokidar.&lt;/p&gt;
      </description>
      <pubDate>2018-10-22T22:00:00.000Z</pubDate>
      <link>http://norswap.com/static-generation-incrementally</link>
      <guid isPermaLink="true">http://norswap.com/static-generation-incrementally</guid>
    </item>
    <item>
      <title>What I&#39;ve Been Up To</title>
      <description>
&lt;p&gt;Been a while! What I&amp;#39;ve been to since July, in no particular order:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;I visited &lt;a href=&quot;https://photos.app.goo.gl/NrzEvTjUMPfdXKwb9&quot;&gt;Tokyo&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://photos.app.goo.gl/RpXdMQpQa7beJkL96&quot;&gt;Ireland&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I improved the program that generates this website, it now does incremental
generation, and I have a post in the works about it (edit: &lt;a href=&quot;/static-generation-incrementally/&quot;&gt;here&lt;/a&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I started writing my thesis, and got a good headstart.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I finished my re-read of the first 13 books of &lt;a href=&quot;https://en.wikipedia.org/wiki/The_Wheel_of_Time&quot;&gt;The Wheel of Time&lt;/a&gt;, and my first
read of the 14th and final book. (I must have read 3 of them since July.) I
thought of writing about it, but the series means so much to me (&lt;a href=&quot;https://twitter.com/norswap/status/1032258555846569986&quot;&gt;I&amp;#39;m not the
only one&lt;/a&gt;), I&amp;#39;m afraid not to do it justice. I must also recoup my
thoughts about it.&lt;/p&gt;
&lt;p&gt;Did you know Amazon is adapting it into a TV show? Might use that as an excuse
to re-read and write about it.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I&amp;#39;ve kept &lt;a href=&quot;/weight-training/&quot;&gt;lifting weights&lt;/a&gt;, I&amp;#39;ll write some thoughts about it soon (edit:
&lt;a href=&quot;/weight-training-2/&quot;&gt;here&lt;/a&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I&amp;#39;m now reading &lt;a href=&quot;https://eightyearsinazeroth.blogspot.com/&quot;&gt;8 Years in Azeroth&lt;/a&gt;, the account of player Hanzo as he leads
his guild &lt;Descendants of Draenor&gt; through the first eight years of World of
Warcraft.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I&amp;#39;ve started tracking my sleep using the &lt;a href=&quot;https://sleep.urbandroid.org/introducing-sonar-as-sensor/&quot;&gt;sonar tech&lt;/a&gt; of the application
&lt;a href=&quot;https://play.google.com/store/apps/details?id=com.urbandroid.sleep&quot;&gt;Sleep as Android&lt;/a&gt;. I&amp;#39;ve used that as an incentive to get my average time in
bed to 8 hours / night over the past month.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
      </description>
      <pubDate>2018-10-22T22:00:00.000Z</pubDate>
      <link>http://norswap.com/been-up-to</link>
      <guid isPermaLink="true">http://norswap.com/been-up-to</guid>
    </item>
    <item>
      <title>More Anime I Watched</title>
      <description>
&lt;p&gt;About this time last year, I wrote &lt;a href=&quot;/every-anime/&quot;&gt;a post&lt;/a&gt; giving my opinions
about all the anime series I ever watched (15 of them). One year later, it&amp;#39;s
time to update the list and give you my always-so-important opinions on
everything I watched this year. (And two things I watched before that I actually
forgot to include in the previous post.)&lt;/p&gt;
&lt;p&gt;Shows listed in roughly chronological viewing order.&lt;/p&gt;
&lt;h2 id=&quot;accel-world&quot;&gt;Accel World&lt;/h2&gt;
&lt;p&gt;I tried watching Accel World because it is based on light novels by the same
author as the Sword Art Online light novels. It&amp;#39;s not made by the same studio
however.&lt;/p&gt;
&lt;p&gt;It&amp;#39;s fair to say I didn&amp;#39;t like it. The graphical style and the universe is nice
enough. But my god this protagonist. He&amp;#39;s the reluctant kind. Think Shinji from
Evangelion, except way way (way) worse — and without the psychological angle,
nor all the other things that make Evangelion a cult classic.&lt;/p&gt;
&lt;p&gt;Not recommended unless your tolerance to cringe is high. I dropped it after
about 5-6 episodes.&lt;/p&gt;
&lt;h2 id=&quot;a-certain-magical-index&quot;&gt;A Certain Magical Index&lt;/h2&gt;
&lt;p&gt;Another show from before, another one I dropped.&lt;/p&gt;
&lt;p&gt;The plot didn&amp;#39;t manage to pull me in, or to convince me. Without spoiling, there
is a major event happening early in the series, and it doesn&amp;#39;t work at all
because we haven&amp;#39;t built enough rapport with the characters.&lt;/p&gt;
&lt;p&gt;The titular &lt;em&gt;Index&lt;/em&gt; (it&amp;#39;s a character) is almost absent from the show, except as
a poorly exploited plot device. I dropped the show after 5-6 episodes, so maybe
it improves, but I&amp;#39;m not holding out my breath.&lt;/p&gt;
&lt;h2 id=&quot;k-on-&quot;&gt;K-On!&lt;/h2&gt;
&lt;p&gt;K-On! is a typical &lt;em&gt;slice-of-life&lt;/em&gt; show, about a couple of girls forming a music
club — essentially a rock band — in their high school.&lt;/p&gt;
&lt;p&gt;I watched it because it&amp;#39;s the favourite show of &lt;a href=&quot;https://www.youtube.com/user/DigibronyMLP/videos&quot;&gt;Digibro&lt;/a&gt;, an anime commentator
I really like despite often disagreeing with him. The show also seemed nice
enough.&lt;/p&gt;
&lt;p&gt;And it was, I especially enjoyed the first season. The second one seemed a bit
too long and dragging for me — it&amp;#39;s almost twice as long as the first one. The
show is very contemplative. I think slice-of-life shows might be like that in
general. You have to watch it either like me, curled up in your sofa with a warm
drink, enjoying the fuzzy warm glow without spending too much brain cycles on
the action — or, like Digibro, over-analysing every small detail.&lt;/p&gt;
&lt;p&gt;The show is solid though, if those things are for you. I definitely don&amp;#39;t regret
watching it, but I won&amp;#39;t be seeking slice of life shows either. Especially since
this is apparently &lt;em&gt;the best one&lt;/em&gt;. I might &lt;a href=&quot;#a-place-further-than-the-universe&quot;&gt;already&lt;/a&gt; disagree with that
though.&lt;/p&gt;
&lt;h2 id=&quot;attack-on-titan-season-2&quot;&gt;Attack on Titan Season 2&lt;/h2&gt;
&lt;p&gt;I reviewed the first season &lt;a href=&quot;/every-anime/#attack-on-titan&quot;&gt;last time&lt;/a&gt;, but the second season is out, and it
continues to kick ass, hard.&lt;/p&gt;
&lt;p&gt;It is different though. The first season focused much on the grimness and sheer
horror of the universe — showing how, in the process, the characters could
become fucked up in the head. The second season, on the other hand, is more
focused on the narrative, within this universe. And despite the fact many people
said they preferred the first season, I think that&amp;#39;s a good thing. I don&amp;#39;t think
repeating the first season would have worked past a certain point.&lt;/p&gt;
&lt;p&gt;The plot works, the action (and animation thereof) continues to be the
state-of-the-art for anime shows. The &lt;a href=&quot;https://www.youtube.com/watch?v=CID-sYQNCew&quot;&gt;music&lt;/a&gt; rocks. It&amp;#39;s just
FUN to watch.&lt;/p&gt;
&lt;h2 id=&quot;angel-beats-&quot;&gt;Angel Beats!&lt;/h2&gt;
&lt;p&gt;A few friends told me Angel Beats! was their favourite anime, so I went into it
with high expectations... and was quite let down.&lt;/p&gt;
&lt;p&gt;The show is about a place — a high school, &lt;em&gt;of course&lt;/em&gt; — where young people go
when they die a tragic death, and is focused on the antics of the &lt;em&gt;Afterlife
Battlefront&lt;/em&gt; who fights a super-powered character named Angel, who seems
determined to not let them do whatever they want.&lt;/p&gt;
&lt;p&gt;The show has some cute ideas, and it kinda works. I think the ropes are a bit
too thick on this one, and I found the ending particularly offensive on account
of forced sentimentality. But who knows, it might work for you. It&amp;#39;s not bad
anyway.&lt;/p&gt;
&lt;h2 id=&quot;overlord&quot;&gt;Overlord&lt;/h2&gt;
&lt;p&gt;I&amp;#39;m officially a sucker for &lt;a href=&quot;https://en.wikipedia.org/wiki/Isekai&quot;&gt;Isekai&lt;/a&gt;, and so it&amp;#39;s logical I would give Overlord a
shot. The plot is classico-classic: a MMO player gets trapped into the game.
Except this player is almost the most powerful bar none, owns a massive guild
hall that acts as his own personal dungeon, with his own NPC (non-player
characters) lackeys.&lt;/p&gt;
&lt;p&gt;Most of the first season revolves around this protagonist learning about the
world, and having a couple brushes with the NPC geo-politics. Season 2 has a
couple different arcs, some kinda meh (lizard men), some rather good (anything
with Sebas).&lt;/p&gt;
&lt;p&gt;All in all, while the universe is super intriguing, there is something about the
show that is quite disappointing. It&amp;#39;s a far cry from Log Horizon — a personal
favorite that I reviewed &lt;a href=&quot;/every-anime/#log-horizon&quot;&gt;last time&lt;/a&gt;. Log Horizon does the world
building much more subtly and intricately. Everything in Overlord is
over-explicated, over-acted, and there is very little of it.&lt;/p&gt;
&lt;p&gt;Nevertheless, I&amp;#39;ll probably continue watching if new seasons come out. But this
is not a heartfelt recommendation.&lt;/p&gt;
&lt;h2 id=&quot;kill-la-kill&quot;&gt;Kill la Kill&lt;/h2&gt;
&lt;p&gt;Kill la Kill is made by the same people who made Gurren Lagann, perhaps &lt;a href=&quot;/every-anime/#gurren-lagann&quot;&gt;my
favorite anime&lt;/a&gt;. I&amp;#39;d heard plenty of good things about it, and so of
course I was pumped when I started watching it. And I wasn&amp;#39;t let down.&lt;/p&gt;
&lt;p&gt;While Kill la Kill is a bit looser than Gurenn Lagann, it bursts with the same
energy, and it is a joy to watch. It&amp;#39;s full of great ideas, and it&amp;#39;s a technical
masterpiece besides.&lt;/p&gt;
&lt;p&gt;There&amp;#39;s no point in talking too much about it: just watch it.&lt;/p&gt;
&lt;p&gt;And if you&amp;#39;d be tempted to think that it&amp;#39;s just goofy anime, &lt;a href=&quot;https://www.youtube.com/watch?v=Tg8S5A7jFX4&quot;&gt;here&amp;#39;s Digibro
 analyzing&lt;/a&gt; the very first scene of the anime and breaking down how
 brilliantly put together it actually is.&lt;/p&gt;
&lt;h2 id=&quot;my-hero-academia&quot;&gt;My Hero Academia&lt;/h2&gt;
&lt;p&gt;My Hero Academia is a pure shonen anime. In a universe where most people are
born with a power or another, the show focuses on an elite school for &lt;em&gt;heroes&lt;/em&gt;—
future super-powered crime-fighter that engage similarly powerful villains. What
could be more formulaic than that?&lt;/p&gt;
&lt;p&gt;And yet, it works. The show is not about being incredibly original or novel,
it&amp;#39;s all about flawless execution. Just like Attack on Titan, this is a show
that is just an absolute blast to watch. The plot is engaging, the action is
cool, the varieties of powers and characters make some interesting plans and
plots possible, and the characters are credible in their concerns and state of
minds.&lt;/p&gt;
&lt;p&gt;Obligatory &lt;a href=&quot;https://www.youtube.com/watch?v=9LfycWHe1Lg&quot;&gt;analysis video&lt;/a&gt; by Gigguk (contains spoilers!) on
the tournament arc, which really underscores my points — that is (a) that the
show executes really well and (b) that it is something to get hyped about.&lt;/p&gt;
&lt;p&gt;The third season is now airing, and it&amp;#39;s as good as ever, it&amp;#39;s impressive how
steady the show&amp;#39;s quality is.&lt;/p&gt;
&lt;p&gt;Oh, and &lt;a href=&quot;https://www.youtube.com/watch?v=3hnS5DAKkz4&quot;&gt;You Say Run&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;steins-gate&quot;&gt;Steins;Gate&lt;/h2&gt;
&lt;p&gt;Steins;Gate is this weird show about time-travel. I didn&amp;#39;t really know what to
expect, excepted that it was very highly regarded. In the first few episodes,
you really get this sense of mystery and drama to come, but otherwise it seems
to be just about this group of misfits goofing around pretending to do science.&lt;/p&gt;
&lt;p&gt;As the show goes, it gets darker, and you also get to understand there was more
going on under the surface. I really like that there is a real evolution in the
show, it works its way up, increases the stakes without ever being boring or
out-of-place.&lt;/p&gt;
&lt;p&gt;It&amp;#39;s an instant favorite, and it comes highly recommended.&lt;/p&gt;
&lt;h2 id=&quot;is-it-wrong-to-try-to-pick-up-girls-in-a-dungeon-&quot;&gt;Is It Wrong to Try to Pick Up Girls in a Dungeon?&lt;/h2&gt;
&lt;p&gt;This dubiously named anime, more often referred as &lt;em&gt;DanMachi&lt;/em&gt; (an abbreviation
of the Japanese name) is an isekai/harem anime that reminds me very much of
&lt;a href=&quot;/every-anime/#konosuba-&quot;&gt;Konosuba!&lt;/a&gt;. In a fashion typical of some harem anime, the hero (&lt;em&gt;Bell&lt;/em&gt;) doesn&amp;#39;t
actually do any picking up (more like anti-picking-up). However, the story
manages to be quite interesting, with a few touches of humor here and there.&lt;/p&gt;
&lt;p&gt;The whole thing is probably less humor-focused, and less sharp than Konosuba!.
But despite what people say, Konosuba! never really made me laugh, but rather
made me smile. I&amp;#39;d put Danmachi in exactly the same basket, and I could almost
copy &lt;a href=&quot;/every-anime/#konosuba-&quot;&gt;the Konosuba! review&lt;/a&gt;. It&amp;#39;s a comfortable show for me, and
that&amp;#39;s exactly how I enjoy it. Although it must be said it gets considerably
more epic than Konosuba! ever does towards the end. I&amp;#39;m eager to see if it will
continue on this trend — if we ever get a second season that is.&lt;/p&gt;
&lt;h2 id=&quot;no-game-no-life&quot;&gt;No Game No Life&lt;/h2&gt;
&lt;p&gt;This is another show that I heard mentioned repeatedly, and so had to watch.
It&amp;#39;s also sort-of an isekai, although the universe focuses on games whose rules
are imagined by the protagonist and brought to life in the world.&lt;/p&gt;
&lt;p&gt;The main protagonists (Sora and Shiro) are siblings who are incredibly talented
at games, and are because of this summoned to an alternate universe (Disboard)
by the god Tet.&lt;/p&gt;
&lt;p&gt;The plot revolves around Sora and Shiro struggle for power in this world through
high-stakes games. My main criticism here is that, as is often the case, the
outcome of these games feel highly &lt;em&gt;ex machina&lt;/em&gt;. There is no way to predict the
winning actions the characters make with the information we have (or that they
have, for that matter). Like in &lt;a href=&quot;/every-anime/#code-geass&quot;&gt;Code Geass&lt;/a&gt; and &lt;a href=&quot;#death-note&quot;&gt;Death Note&lt;/a&gt;, the supposed
genius of the protagonists feels fake and forced.&lt;/p&gt;
&lt;p&gt;If you can get over this, it&amp;#39;s not a bad show though.&lt;/p&gt;
&lt;h2 id=&quot;citrus&quot;&gt;Citrus&lt;/h2&gt;
&lt;p&gt;I went intro Citrus expecting to find the next representative of the trash anime
genre, after &lt;a href=&quot;https://myanimelist.net/anime/32901/Eromanga-sensei&quot;&gt;Eromanga Sensei&lt;/a&gt; (which I still haven&amp;#39;t watched). Instead, I found
a cute love story. A cute &lt;em&gt;incestuous&lt;/em&gt; lesbian love story, but still.&lt;/p&gt;
&lt;p&gt;And with that, almost everything is said. Frankly, it&amp;#39;s a cute love story with
girls and that&amp;#39;s it. For what it&amp;#39;s worth, I quite enjoyed it, but I don&amp;#39;t really
have a reference frame here.&lt;/p&gt;
&lt;h2 id=&quot;a-place-further-than-the-universe&quot;&gt;A Place Further Than The Universe&lt;/h2&gt;
&lt;p&gt;This anime is about four girls striving to achieve a common goal: going to
Antartica, and — spoiler alert (not) — their journey there.&lt;/p&gt;
&lt;p&gt;I&amp;#39;m not exactly sure what this is — slice-of-life? — but who cares? The
point is that it is tremendously cute, touching and inspiring. There is a sense
of youthful possibilities and optimism that permeates the series.&lt;/p&gt;
&lt;p&gt;The show has been critically very well received (&lt;a href=&quot;https://www.youtube.com/watch?v=ZGsvHRyiTG0&quot;&gt;exhibit a&lt;/a&gt;, &lt;a href=&quot;https://www.youtube.com/watch?v=wO6CGqKimC0&quot;&gt;exhibit b&lt;/a&gt;), I
think with good reason. As a mentionned earlier, I&amp;#39;m not too experienced with
this kind of anime, but I think this is what it should strive to be: something
touching but not mushy, cute but not brainless, optimistic but not naive. It
think it does well while definitely remaining in the light tone of the genre. No
darkness will be found here.&lt;/p&gt;
&lt;p&gt;Also, &lt;a href=&quot;https://www.youtube.com/watch?v=XJeOoMkXTFw&quot;&gt;this song&lt;/a&gt;, doesn&amp;#39;t it just sound like optimism?&lt;/p&gt;
&lt;h2 id=&quot;death-note&quot;&gt;Death Note&lt;/h2&gt;
&lt;p&gt;Death Note is a huge classic. It&amp;#39;s currently &lt;a href=&quot;https://myanimelist.net/topanime.php?type=bypopularity&quot;&gt;#1 in popularity&lt;/a&gt; on
my anime list. And to be sure, it is enjoyable.&lt;/p&gt;
&lt;p&gt;Buuut, my criticism of it is almost exactly the same as for &lt;a href=&quot;/every-anime/#code-geass&quot;&gt;Code Geass&lt;/a&gt;. Both
shows are actually very close. In both of them an anti-hero lead character tries
to assume dominion of the world through 3D mental chess, helped by a handy
super-power. In this case the power is the nominal &lt;em&gt;Death Note&lt;/em&gt; — a notebook in
which writing people&amp;#39;s name kills them. Same criticism then, which is that plot
development is &lt;em&gt;ex machina&lt;/em&gt;. It&amp;#39;s not a fair playing field: characters in the
show knows what the writer knows, but you don&amp;#39;t.&lt;/p&gt;
&lt;p&gt;But once again, aside from that, it&amp;#39;s a solid show.&lt;/p&gt;
&lt;p&gt;I&amp;#39;ve heard multiple people say that the second part is less good than the first,
but I didn&amp;#39;t feel this way, feeling the quality to be more or less constant. It
is true that a big event happening around halfway through is a big letdown
however. I found the ending to be relatively satisfying, if not exempt from the
series&amp;#39; overall sins. Let&amp;#39;s just say that it didn&amp;#39;t feel inevitable at all,
given what was previously shown.&lt;/p&gt;
&lt;h2 id=&quot;grimgar-of-fantasy-and-ash&quot;&gt;Grimgar of Fantasy and Ash&lt;/h2&gt;
&lt;p&gt;It&amp;#39;s another Isekai. But what an Isekai!&lt;/p&gt;
&lt;p&gt;The protagonists are trapped inside a game — or an alternative reality, we don&amp;#39;t
really know — and lost their memory. So they get to work, painstakingly trying
to kill some measly goblins to sustain their continued existance.&lt;/p&gt;
&lt;p&gt;The show starts cute and slightly goofy, but soon things take a more dark turn.
It&amp;#39;s consistently poetic and thoughtful however. I like how the subtleties of
the characters&amp;#39; personalities are explored through the prism of the inner
monologue of the main character (Haruhiro).&lt;/p&gt;
&lt;p&gt;If you&amp;#39;ve picked up my tastes a bit, you understand there is no way I could not
love this show. And indeed, it&amp;#39;s an instant favorite and I&amp;#39;m desperately hoping
for a sequel.&lt;/p&gt;
&lt;h2 id=&quot;sword-art-online-alternative-gun-gale-online&quot;&gt;Sword Art Online Alternative: Gun Gale Online&lt;/h2&gt;
&lt;p&gt;This is a &lt;a href=&quot;/every-anime/#sword-art-online&quot;&gt;Sword Art Online&lt;/a&gt; spin-off set within the &lt;em&gt;Gun Gale
Online&lt;/em&gt; game (from SAO season 2). There is no Kirito, Asuna &amp;amp; co, but it&amp;#39;s stil
quintessentially Sword Art Online: an event in an online game (a tournament) has
spillovers causing danger in real life. Hand-wavy but fun fights are also par
for the course. There&amp;#39;s even an Eir Aoi theme song.&lt;/p&gt;
&lt;p&gt;There is nothing truly original or marvelous in GGO, but if you like Sword Art
Online, you will find it enjoyable. For me, it&amp;#39;s a comfy show.&lt;/p&gt;
      </description>
      <pubDate>2018-07-01T22:00:00.000Z</pubDate>
      <link>http://norswap.com/more-anime</link>
      <guid isPermaLink="true">http://norswap.com/more-anime</guid>
    </item>
  </channel>
</rss>
