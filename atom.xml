<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>norswap</title>
    <description></description>      
    <link>http://norswap.com/</link>
    <atom:link href="http://norswap.com/atom.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Stuckness and Understanding</title>
      <description>
        &lt;p&gt;The second big idea (1) I got out of reading
        &lt;a href=&quot;https://en.wikipedia.org/wiki/Zen_and_the_Art_of_Motorcycle_Maintenance&quot;&gt;Zen and the Art of Motorcycle Maintenance&lt;/a&gt; is how getting stuck is a
        common part of most work processes, and how to deal with it. The tidbits below
        are from my own notes, with some phrases lifted or paraphrased from Pirsig.&lt;/p&gt;
        &lt;p&gt;(1) &lt;a href=&quot;/peace-of-mind&quot;&gt;First one here&lt;/a&gt;&lt;/p&gt;
        &lt;hr&gt;
        &lt;p&gt;Getting stuck is common. Getting stuck is trying to do too many things at once.
        To get unstuck, separate the things and do them one at a time. Separate thinking
        about what to say and saying things. Make a list of things to say in any order.
        If there are too many, pick the best things.&lt;/p&gt;
        &lt;hr&gt;
        &lt;p&gt;Hypotheses generation is the realm of quality. The difference between a good and
        a bad mathematician or mechanic is the ability to select the good facts from the
        bad ones on the basis of quality. The scientific method operates only after you
        have an hypothesis.&lt;/p&gt;
        &lt;hr&gt;
        &lt;p&gt;Stuckness isn&amp;#39;t the worst of all possible situations: zen buddhists go to much
        throuble to induce it (through koans, meditation, etc). It&amp;#39;s called &amp;quot;begginer&amp;#39;s
        mind&amp;quot;. This moment is not to be feared but cultivated. If your mind is truly
        stuck, you might be much better off than when it was loaded with ideas.&lt;/p&gt;
        &lt;p&gt;If you try to hold onto the stuckness, it is bound to disappear. Your mind will
        naturally and freely move toward a solution. The longer you stay stuck, the more
        you see quality and it gets you unstuck every time. What&amp;#39;s getting you stuck is
        frantically trying to get unstuck by rummaging through your knowledge.&lt;/p&gt;
        &lt;p&gt;Stuckness is the psychic predecessor of all understanding. An egoless acceptance
        of it is key to understanding quality. Self-taught mechanics are often superior
        to instructed ones because they can handle new situations.&lt;/p&gt;
        &lt;hr&gt;
        &lt;p&gt;Harry Truman on adminstration programs:&lt;/p&gt;
        &lt;blockquote&gt;
        &lt;p&gt;We&amp;#39;ll just try them - and if they don&amp;#39;t work &amp;mdash; why then we&amp;#39;ll just try
        something else.&lt;/p&gt;
        &lt;/blockquote&gt;
        &lt;hr&gt;
        &lt;p&gt;The skill of the inventor is to choose the convenient facts. There is an
        inconscient selection (subliminal self) where many possible but useless
        facts/conventions are rejected.&lt;/p&gt;
        &lt;p&gt;Look at things that ties up with the theory... then looks at things that are
        very different, to gain insight. Maybe they are the same, maybe not. Select
        facts with harmony and mathematical beauty in mind.&lt;/p&gt;
      </description>
      <pubDate>2016-08-12T22:00:00.000Z</pubDate>
      <link>http://norswap.com/stuckness-and-understanding</link>
      <guid isPermaLink="true">http://norswap.com/stuckness-and-understanding</guid>
    </item>
    <item>
      <title>Good Work is Peace of Mind</title>
      <description>
        &lt;blockquote&gt;
        &lt;p&gt;I&amp;#39;ve a set of instructions at home which open up great realms for the
        improvement of technical writing. They begin, &amp;#39;Assembly of Japanese bicycle
        require great peace of mind.&amp;#39;&lt;/p&gt;
        &lt;/blockquote&gt;
        &lt;p&gt;Over the past few months, I have been reading
        &lt;a href=&quot;https://en.wikipedia.org/wiki/Zen_and_the_Art_of_Motorcycle_Maintenance&quot;&gt;Zen and the Art of Motorcycle Maintenance&lt;/a&gt; by Robert Pirsig. This post
        collects a few quotes on one of the big idea I got out of the book, namely that
        doing good work is synonymous with tending to your peace of mind.&lt;/p&gt;
        &lt;blockquote&gt;
        &lt;p&gt;Peace of mind isn&amp;#39;t at all superficial [...] It&amp;#39;s the whole thing. That which
        produces it is good maintenance; that which disturbs it is poor maintenance.
        [...] The ultimate test&amp;#39;s always your own serenity. If you don&amp;#39;t have this
        when you start and maintain it while you&amp;#39;re working you&amp;#39;re likely to build
        your personal problems right into the machine itself.&lt;/p&gt;
        &lt;p&gt;The test of the machine is the satisfaction it gives you. [...] If the machine
        produces tranquility it&amp;#39;s right. If it disturbs you it&amp;#39;s wrong until either
        the machine or your mind is changed. The test of the machine&amp;#39;s always your own
        mind. There isn&amp;#39;t any other test.&lt;/p&gt;
        &lt;/blockquote&gt;
        &lt;hr&gt;
        &lt;blockquote&gt;
        &lt;p&gt;Sometime look at a novice workman or a bad workman and compare his expression
        with that of a craftsman whose work you know is excellent and you&amp;#39;ll see the
        difference. The craftsman isn&amp;#39;t ever following a single line of instruction.
        He&amp;#39;s making decisions as he goes along. For that reason he&amp;#39;ll be absorbed and
        attentive to what he&amp;#39;s doing even though he doesn&amp;#39;t deliberately contrive this.
        His motions and the machine are in a kind of harmony. He isn&amp;#39;t following any set
        of written instructions because the nature of the material at hand determines
        his thoughts and motions, which simultaneously change the nature of the material
        at hand. The material and his thoughts are changing together in a progression of
        changes until his mind&amp;#39;s at rest at the same time the material&amp;#39;s right.&lt;/p&gt;
        &lt;/blockquote&gt;
        &lt;hr&gt;
        &lt;blockquote&gt;
        &lt;p&gt;I say inner peace of mind. It has no direct relationship to external
        circumstances. It can occur to a monk in meditation, to a soldier in heavy
        combat or to a machinist taking off that last ten-thousandth of an inch. It
        involves unselfconsciousness, which produces a complete identification with
        one&amp;#39;s circumstances, and there are levels and levels of this identification
        and levels and levels of quietness quite as profound and difficult of
        attainment as the more familiar levels of activity.&lt;/p&gt;
        &lt;p&gt;This inner peace of mind occurs on three levels of understanding. Physical
        quietness seems the easiest to achieve, although there are levels and levels of
        this too, as attested by the ability of Hindu mystics to live buried alive for
        many days. Mental quietness, in which one has no wandering thoughts at all,
        seems more difficult, but can be achieved. But value quietness, in which one has
        no wandering desires at all but simply performs the acts of his life without
        desire, that seems the hardest.&lt;/p&gt;
        &lt;p&gt;I&amp;#39;ve sometimes thought this inner peace of mind, this quietness is similar to if
        not identical with the sort of calm you sometimes get when going fishing, which
        accounts for much of the popularity of this sport. Just to sit with the line in
        the water, not moving, not really thinking about anything, not really caring
        about anything either, seems to draw out the inner tensions and frustrations
        that have prevented you from solving problems you couldn&amp;#39;t solve before and
        introduced ugliness and clumsiness into your actions and thoughts.&lt;/p&gt;
        &lt;p&gt;You don&amp;#39;t have to go fishing, of course, to fix your motorcycle. A cup of
        coffee, a walk around the block, sometimes just putting off the job for five
        minutes of silence is enough. When you do you can almost feel yourself grow
        toward that inner peace of mind that reveals it all. That which turns its back
        on this inner calm and the Quality it reveals is bad maintenance. That which
        turns toward it is good. The forms of turning away and toward are infinite but
        the goal is always the same.&lt;/p&gt;
        &lt;p&gt;[...]&lt;/p&gt;
        &lt;p&gt;Zen Buddhists talk about &amp;quot;just sitting,&amp;quot; a meditative practice in which the idea
        of a duality of self and object does not dominate one&amp;#39;s consciousness. What I&amp;#39;m
        talking about here in motorcyele maintenance is ``just fixing,&amp;#39;&amp;#39; in which the
        idea of a duality of self and object doesn&amp;#39;t dominate one&amp;#39;s consciousness. When
        one isn&amp;#39;t dominated by feelings of separateness from what he&amp;#39;s working on, then
        one can be said to &amp;quot;care&amp;quot; about what he&amp;#39;s doing. That is what caring really is,
        a feeling of identification with what one&amp;#39;s doing.&lt;/p&gt;
        &lt;p&gt;So the thing to do when working on a motorcycle, as in any other task, is to
        cultivate the peace of mind which does not separate one&amp;#39;s self from one&amp;#39;s
        surroundings. When that is done successfully then everything else follows
        naturally. Peace of mind produces right values, right values produce right
        thoughts. Right thoughts produce right actions and right actions produce work
        which will be a material reflection for others to see of the serenity at the
        center of it all.&lt;/p&gt;
        &lt;p&gt;[...]&lt;/p&gt;
        &lt;p&gt;The social values are right only if the individual values are right. The place
        to improve the world is first in one&amp;#39;s own heart and head and hands, and then
        work outward from there. other people can talk about how to expand the destiny
        of mankind. I just want to talk about how to fix a motorcycle.&lt;/p&gt;
        &lt;/blockquote&gt;
        &lt;hr&gt;
        &lt;blockquote&gt;
        &lt;p&gt;The real cycle you&amp;#39;re working on is yourself.&lt;/p&gt;
        &lt;/blockquote&gt;
      </description>
      <pubDate>2016-07-22T22:00:00.000Z</pubDate>
      <link>http://norswap.com/peace-of-mind</link>
      <guid isPermaLink="true">http://norswap.com/peace-of-mind</guid>
    </item>
    <item>
      <title>Building a static website with Ribosome and Node.js</title>
      <description>
        &lt;p&gt;I&amp;#39;ve transitioned the website from &lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt; to a custom system based on
        &lt;a href=&quot;http://ribosome.ch/&quot;&gt;Ribosome&lt;/a&gt;. I wasn&amp;#39;t updating the website very regularly, and each
        time I picked it up again, I had to spend an hour or so battling the
        particularly horrible Ruby dependencies on Windows.&lt;/p&gt;
        &lt;p&gt;Ribosome is essentially a templating engine driven by a script language
        (JavaScript, Python or Ruby &amp;mdash; I went with Javascript). It takes a js/py/rb
        script as input, which also contains lines starting with a dot. The script is
        run, but whenever a dotted line is encountered, it is sent to an output file. It
        supports embedded expression within dotted lines, special directives to change
        the file to which the output is redirected and include other files. This makes
        it possible to generate your whole website from a single script
        (&lt;a href=&quot;https://github.com/norswap/norswap.github.io/blob/master/.factory/generate.js&quot;&gt;have a look at mine&lt;/a&gt;).&lt;/p&gt;
        &lt;p&gt;Something I really like about Ribosome is how it respects whitespace, resulting
        in really nice-looking output, unlike most templating engines (have a look at
        the html for this page). It&amp;#39;s &lt;a href=&quot;http://ribosome.ch/documentation.html#advanced-layout-management&quot;&gt;block layouting&lt;/a&gt; capability is also quite
        handy.&lt;/p&gt;
        &lt;p&gt;I&amp;#39;m also very pleased about the Node.js ecosystem. I was really easy to find
        libraries to &lt;a href=&quot;https://www.npmjs.com/package/gray-matter&quot;&gt;parse YAML front matter&lt;/a&gt;, &lt;a href=&quot;https://www.npmjs.com/package/marked&quot;&gt;parse Markdown&lt;/a&gt;,
        &lt;a href=&quot;http://momentjs.com/&quot;&gt;manipulate dates&lt;/a&gt;, &lt;a href=&quot;https://www.npmjs.com/package/escape-html&quot;&gt;escaping html&lt;/a&gt; and
        &lt;a href=&quot;https://www.npmjs.com/package/tmp&quot;&gt;create temporary files&lt;/a&gt;. They were easy to use too.&lt;/p&gt;
        &lt;p&gt;All in all, updating the website was a surprisingly pleasant experience.
        Ribosome in particular is great, I encourage you to try it.&lt;/p&gt;
      </description>
      <pubDate>2016-07-12T22:00:00.000Z</pubDate>
      <link>http://norswap.com/ribosome-static-site</link>
      <guid isPermaLink="true">http://norswap.com/ribosome-static-site</guid>
    </item>
    <item>
      <title>Building Java with Make</title>
      <description>
        &lt;p&gt;In &lt;a href=&quot;https://github.com/norswap/violin&quot;&gt;violin&lt;/a&gt;, I set up the build using the good old &lt;code&gt;make&lt;/code&gt; tool (you might have
        gathered that &lt;a href=&quot;/rant-java-build&quot;&gt;I harbor no love&lt;/a&gt; for Java build systems).&lt;/p&gt;
        &lt;p&gt;For examples of how to perform common Java build tasks by calling command line
        tools from make, &lt;a href=&quot;https://github.com/norswap/violin/blob/master/makefile&quot;&gt;have a look at the makefile&lt;/a&gt;.&lt;/p&gt;
      </description>
      <pubDate>2016-07-08T22:00:00.000Z</pubDate>
      <link>http://norswap.com/build-java-with-make</link>
      <guid isPermaLink="true">http://norswap.com/build-java-with-make</guid>
    </item>
    <item>
      <title>Micro-Rant: Java Build Systems</title>
      <description>
        &lt;p&gt;Ant is Make in XML.&lt;/p&gt;
        &lt;p&gt;Maven is an over-engineered, yet castrated build system. You can&amp;#39;t do
        fundamental stuff (such as specifying which version of Java you want to use or
        &lt;strong&gt;moving files&lt;/strong&gt;) without importing a plugin or calling Ant. Want to do something
        slightly different? Build you own plugin (this process is more painful than it
        sounds). On the plus side, Maven does have a handy (but not best-in-class)
        dependency system, which is why we still have to suffer it.&lt;/p&gt;
        &lt;p&gt;Gradle allows custom build tasks (&lt;strong&gt;finally!&lt;/strong&gt;). It&amp;#39;s also huge, bloated, and
        comes with a &lt;a href=&quot;https://docs.gradle.org/current/userguide/userguide.html&quot;&gt;70-chapters manual&lt;/a&gt; that still manages to be lacunary and
        confusing. Understanding Gradle is not the work of an afternoon but of weeks.&lt;/p&gt;
        &lt;p&gt;Scala is not served better. To think sbt once stood for &amp;quot;simple build
        tool&amp;quot; (now retconned to &amp;quot;scala build tool&amp;quot;) is enough to choke on the irony.&lt;/p&gt;
        &lt;p&gt;&lt;a href=&quot;/build-java-with-make&quot;&gt;One might as well build Java using Make.&lt;/a&gt;&lt;/p&gt;
        &lt;h2 id=&quot;hope-&quot;&gt;Hope?&lt;/h2&gt;
        &lt;p&gt;&lt;a href=&quot;http://beust.com/kobalt/&quot;&gt;Kobalt&lt;/a&gt; is a sane build system for Kotlin &amp;amp; Java by Cedric Beust (the
        author of TestNG). However it&amp;#39;s still in its infancy.&lt;/p&gt;
        &lt;p&gt;&lt;a href=&quot;http://pluto-build.github.io/&quot;&gt;pluto&lt;/a&gt; is a prototype from academia (&lt;a href=&quot;http://www.informatik.uni-marburg.de/~seba/publications/pluto-incremental-build.pdf&quot;&gt;related paper&lt;/a&gt;)
        that enables incremental, minimal, and safe builds (no need to &lt;code&gt;make clean&lt;/code&gt;).
        You can&amp;#39;t really use it as is, but the idea only asks to be picked up.&lt;/p&gt;
      </description>
      <pubDate>2016-07-08T22:00:00.000Z</pubDate>
      <link>http://norswap.com/rant-java-build</link>
      <guid isPermaLink="true">http://norswap.com/rant-java-build</guid>
    </item>
    <item>
      <title>Released: Violin, a human-sized Kotlin utility library</title>
      <description>
        &lt;p&gt;I just released &lt;a href=&quot;https://github.com/norswap/violin&quot;&gt;violin&lt;/a&gt;, a small Kotlin utility library that features
        simple streams and some other stuff too.&lt;/p&gt;
      </description>
      <pubDate>2016-07-08T22:00:00.000Z</pubDate>
      <link>http://norswap.com/violin-release</link>
      <guid isPermaLink="true">http://norswap.com/violin-release</guid>
    </item>
    <item>
      <title>The Path to Wisdom</title>
      <description>
        &lt;blockquote&gt;
        &lt;p&gt;The path to wisdom is like this: each time you get one step closer, the target
        moves two steps away.&lt;/p&gt;
        &lt;/blockquote&gt;
      </description>
      <pubDate>2016-07-07T22:00:00.000Z</pubDate>
      <link>http://norswap.com/path-to-wisdom</link>
      <guid isPermaLink="true">http://norswap.com/path-to-wisdom</guid>
    </item>
    <item>
      <title>In Defence of Checked Exceptions</title>
      <description>
        &lt;p&gt;I had a minor epiphany recently. I realized that checked exceptions are great.
        Until then I supported the hip opinion that checked exceptions are a design
        mistakes, and that all exceptions should be unchecked.&lt;/p&gt;
        &lt;p&gt;The first step on my path to enlightenment was to realize the different use
        cases for checked and unchecked exceptions. Java Practices &lt;a href=&quot;http://www.javapractices.com/topic/TopicAction.do?Id=129&quot;&gt;says it best&lt;/a&gt;:&lt;/p&gt;
        &lt;blockquote&gt;
        &lt;p&gt;Unchecked exceptions represent defects in the program (bugs) - often invalid
            arguments passed to a non-private method. To quote from The Java Programming
            Language, by Gosling, Arnold, and Holmes: &amp;quot;Unchecked runtime exceptions
            represent conditions that, generally speaking, reflect errors in your
            program&amp;#39;s logic and cannot be reasonably recovered from at run time.&amp;quot;&lt;/p&gt;
        &lt;p&gt;Checked exceptions represent invalid conditions in areas outside the
            immediate control of the program (invalid user input, database problems,
            network outages, absent files).&lt;/p&gt;
        &lt;/blockquote&gt;
        &lt;p&gt;Ideally, all unchecked exceptions can be removed from your program without
        causing problems. They are just a debugging aid in pinpointing what went wrong
        when you made a mistake. Under this assumption, unchecked exceptions should
        never be handled: the program is incorrect and should crash and burn. Or at
        least, the component (~ a blob of features) should. It&amp;#39;s good form to insulate
        other components from the failure of a component, if they can still perform
        usefully without it.&lt;/p&gt;
        &lt;p&gt;On the other hand, you can&amp;#39;t prevent checked exceptions from occuring, they are
        outside your sphere of control. Hence the need to ensure that are handled
        correctly.&lt;/p&gt;
        &lt;p&gt;This seems to make sense. So why are people so fiercely opposed to checked
        exceptions?&lt;/p&gt;
        &lt;p&gt;Well imagine that you are writing some code, and you make a call to a method
        that throws a checked exception. You have two choices: add a &lt;code&gt;throws&lt;/code&gt; clause to
        your method, or wrap the method call in a try-catch block. The right thing to do
        is to use try-catch if you can handle the exception at that level, otherwise to
        add a &lt;code&gt;throws&lt;/code&gt; clause. In practice, the &lt;code&gt;throws&lt;/code&gt; clause is almost always the
        right thing to do. Yet, adding a &lt;code&gt;throws&lt;/code&gt; clause is tedious, because it must be
        propagated to all the callers of the current method. It&amp;#39;s much easier to add a
        try-catch block even though there&amp;#39;s nothing we can do about the exception, and
        so ignore it silently, leading to a loss of information in case of failure.&lt;/p&gt;
        &lt;p&gt;People who oppose exceptions have either performed this kind of abuse, or have
        been bitten by the consequences of other people doing it. I am not making this
        up, it&amp;#39;s quite obvious from pieces like &lt;a href=&quot;http://www.mindview.net/Etc/Discussions/CheckedExceptions&quot;&gt;this one&lt;/a&gt; and it&amp;#39;s explained in
        great length &lt;a href=&quot;http://stackoverflow.com/a/614494/298664&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
        &lt;p&gt;Summarized: people don&amp;#39;t want exceptions because they are going to be abused by
        lazy programmers.&lt;/p&gt;
        &lt;p&gt;I can also think of another reason why exceptions might be frustrating to use:
        people don&amp;#39;t understand the distinction between checked and unchecked exceptions
        as spelled out above, and so create frustrating APIs. Even Sun has been guilty
        of this: should &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/NoSuchMethodException.html&quot;&gt;NoSuchMethodException&lt;/a&gt; really be a checked exception?
        Probably not.&lt;/p&gt;
        &lt;p&gt;Finally, I&amp;#39;ll note that it&amp;#39;s sometimes allowable to cheat a little bit. If
        you&amp;#39;re writing a component with a well-delimited interface, you could for
        instance eschew checked exceptions if all the exceptions are going to be handled
        at the API boundary and no cleanup needs to be performed. You&amp;#39;re trading off
        some safety for some typing. Just be aware that you are making the trade-off.&lt;/p&gt;
        &lt;p&gt;In conclusion, do use checked exception, but use them properly: define checked
        exceptions only for areas outside the programmer&amp;#39;s control; and don&amp;#39;t silently
        swallow checked exceptions.&lt;/p&gt;
      </description>
      <pubDate>2015-10-02T22:00:00.000Z</pubDate>
      <link>http://norswap.com/checked-exceptions</link>
      <guid isPermaLink="true">http://norswap.com/checked-exceptions</guid>
    </item>
    <item>
      <title>The Most Useful Java Function</title>
      <description>
        &lt;p&gt;Warning: title may contain hyperbole.&lt;/p&gt;
        &lt;p&gt;Without further ado:&lt;/p&gt;
        &lt;pre&gt;&lt;code&gt;public class Caster
        {
            @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
            public static &amp;lt;T&amp;gt; T cast(Object obj)
            {
                return (T) obj;
            }
        }
        &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now you can write:&lt;/p&gt;
        &lt;pre&gt;&lt;code&gt;List&amp;lt;Object&amp;gt; x = objectList(&amp;quot;cthulhu&amp;quot;);
        functionExpectingStringList(Caster.cast(x));
        &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;instead of:&lt;/p&gt;
        &lt;pre&gt;&lt;code&gt;List&amp;lt;Object&amp;gt; x = objectList(&amp;quot;cthulhu&amp;quot;);
        @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
        List&amp;lt;String&amp;gt; y = (List&amp;lt;String&amp;gt;) x;
        functionExpectingStringList(y);
        &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, it does two things: (1) automatically infer the destination type and (2)
        avoid an intermediate variable declaration, which you need if you want to ignore
        the resulting &amp;quot;unchecked cast&amp;quot; warning. This warning appears when the cast can&amp;#39;t
        be checked at run-time, as is the case when casting between types that differ in
        their generic type parameters.&lt;/p&gt;
        &lt;p&gt;The type inference part will only work with Java 8 and higher. The definition of
        &lt;code&gt;cast&lt;/code&gt; is valid on Java 5 and higher however, and you still get benefit (2).&lt;/p&gt;
        &lt;p&gt;In the cases where the type cannot be inferred, you need to specify it
        explicitly:&lt;/p&gt;
        &lt;pre&gt;&lt;code&gt;Object x = &amp;quot;cthulhu&amp;quot;;
        functionExpectingString(Caster.&amp;lt;String&amp;gt;cast(x));
        &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It also holds up remarkably well when using multiple casts with generics:&lt;/p&gt;
        &lt;pre&gt;&lt;code&gt;static &amp;lt;T&amp;gt; void takeArrayListPair(ArrayList&amp;lt;T&amp;gt; a, ArrayList&amp;lt;T&amp;gt; b) {}
        
        static void test()
        {
            List&amp;lt;String&amp;gt; x = new ArrayList&amp;lt;&amp;gt;();
            List&amp;lt;Integer&amp;gt; y = new ArrayList&amp;lt;&amp;gt;();
        
            takeArrayListPair(Caster.cast(x), Caster.cast(y));
            // x and y are casted to ArrayList&amp;lt;Object&amp;gt;
        }
        &lt;/code&gt;&lt;/pre&gt;
      </description>
      <pubDate>2015-02-23T23:00:00.000Z</pubDate>
      <link>http://norswap.com/java_caster</link>
      <guid isPermaLink="true">http://norswap.com/java_caster</guid>
    </item>
    <item>
      <title>C: Scope, Duration &amp; Linkage</title>
      <description>
        &lt;p&gt;&lt;a name=&quot;intro&quot;&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;p&gt;This article explains the concepts of scope, linkage and duration (aka lifetime)
        in the C programming language. It also explains how scope, linkage and duration
        are determined for each function or variable declaration, depending on its
        location in the file and its storage class specifier (&lt;code&gt;extern&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;, etc).&lt;/p&gt;
        &lt;p&gt;In what follows we will use the term &amp;quot;object&amp;quot; to mean &amp;quot;function or variable&amp;quot;.
        The terminology is used by the C standard and avoids tedious repetitions. When
        we say &amp;quot;declaration&amp;quot;, we always mean &amp;quot;object declaration&amp;quot;, since types have
        declarations as well. An &amp;quot;identifier&amp;quot; is just a name; e.g., a variable name.&lt;/p&gt;
        &lt;p&gt;The &lt;strong&gt;scope&lt;/strong&gt; of a declaration is the part of the code where the declaration is
        seen and can be used.&lt;/p&gt;
        &lt;p&gt;Note that this says nothing about whether the object associated to the
        declaration can be accessed from some other part of the code via another
        declaration!&lt;/p&gt;
        &lt;p&gt;We uniquely identify an object by its memory: the storage for a variable or the
        function code.&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;Duration&lt;/strong&gt; indicates whether the object associated to the declaration persists
        throughout the program&amp;#39;s execution or whether it is allocated dynamically when
        the declaration&amp;#39;s scope is entered.&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;Linkage&lt;/strong&gt; is what determines if multiple declarations of the same object refer
        to the same object, or to separate ones.&lt;/p&gt;
        &lt;p&gt;As you might suspect, the three notions are closely inter-related. Let&amp;#39;s try to
        untangle them.&lt;/p&gt;
        &lt;h1 id=&quot;scope&quot;&gt;Scope&lt;/h1&gt;
        &lt;p&gt;&lt;a name=&quot;scope&quot;&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;p&gt;C features four scopes:&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;block scope&lt;/li&gt;
        &lt;li&gt;function scope&lt;/li&gt;
        &lt;li&gt;function prototype scope&lt;/li&gt;
        &lt;li&gt;file scope&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;Every variable or function declaration that appears inside a block (including a
        function body) has &lt;strong&gt;block scope&lt;/strong&gt;. The scope goes from the declaration to the end
        of the innermost block in which the declaration appears.&lt;/p&gt;
        &lt;p&gt;Function parameter declarations in function definitions (but not in prototypes)
        also have block scope. The scope of a parameter declaration therefore includes
        the parameter declarations that appear after it.&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;Function scope&lt;/strong&gt; is a bit special: it is the scope of goto labels. Goto labels are
        implicitly declared at the place where they appears, but they are visible
        throughout the function, even if they appear inside a block.&lt;/p&gt;
        &lt;p&gt;Note that goto labels have a different namespace than objects, meaning you can
        have goto labels and objects using the same identifier without incurring any
        problems.&lt;/p&gt;
        &lt;p&gt;&lt;strong&gt;Function prototype scope&lt;/strong&gt; is the scope for function parameters that appear inside
        a function prototype. It extends until the end of the prototype. This scope
        exists to ensure that function parameters have distinct names.&lt;/p&gt;
        &lt;p&gt;All variables and functions defined outside functions have &lt;strong&gt;file scope&lt;/strong&gt;. They are
        visible from their declaration until the end of the file. Here, the term &amp;quot;file&amp;quot;
        should be understood as the source file being compiled, after all includes have
        been resolved.&lt;/p&gt;
        &lt;div class=&quot;nsep&quot;&gt;&lt;/div&gt;
        
        &lt;p&gt;The other two concepts (duration and linkage) are only relevant to declarations
        that have block scope or file scope. We will ignore the two other kinds of scope
        from now on.&lt;/p&gt;
        &lt;p&gt;Finally, note that a declaration in a nested scope can hide a declaration in an
        outer scope; but only if one of the two has no linkage. Most compilers have
        warning flags to warn you when this kind of hiding occurs, as it can be
        error-prone.&lt;/p&gt;
        &lt;h1 id=&quot;storage-class-specifiers&quot;&gt;Storage Class Specifiers&lt;/h1&gt;
        &lt;p&gt;The are five storage class specifiers: &lt;code&gt;static&lt;/code&gt;, &lt;code&gt;extern&lt;/code&gt;, &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;register&lt;/code&gt;
        and &lt;code&gt;typedef&lt;/code&gt;. Each declaration can only have a single storage class specifier.&lt;/p&gt;
        &lt;p&gt;As you are probably well aware, &lt;code&gt;typedef&lt;/code&gt; is kind of a hack, and we don&amp;#39;t need
        to concern ourselves with it for regular declarations.&lt;/p&gt;
        &lt;h2 id=&quot;at-block-scope&quot;&gt;At Block Scope&lt;/h2&gt;
        &lt;p&gt;The storage class specifiers &lt;code&gt;auto&lt;/code&gt; and &lt;code&gt;register&lt;/code&gt; are only valid for variable
        declarations appearing inside functions.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;auto&lt;/code&gt; cannot apply to parameter declarations. It is the default for variable
        declared inside a function body, and is hence never necessary. The existence of
        &lt;code&gt;auto&lt;/code&gt; is rather puzzling, as is the fact that it is not allowed with
        parameters. &lt;code&gt;auto&lt;/code&gt; is in fact a historic leftover from C predecessor&amp;#39;s &amp;quot;B&amp;quot;.&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;register&lt;/code&gt; is a hint to the compiler that it might be a good idea to store the
        variable in a register, but the compiler is not forced to do so. The compiler
        does make sure that you do not take the address of a variable with the
        &lt;code&gt;register&lt;/code&gt; storage class.&lt;/p&gt;
        &lt;p&gt;Inside a function, variable declarations with the &lt;code&gt;static&lt;/code&gt; storage class
        specifiers keeps its value in between invocations of the function.&lt;/p&gt;
        &lt;p&gt;Variables declared inside a function with the &lt;code&gt;extern&lt;/code&gt; behaves exactly like a
        file-scope &lt;code&gt;extern&lt;/code&gt; declaration, excepted for the difference in scope.&lt;/p&gt;
        &lt;h2 id=&quot;at-file-scope&quot;&gt;At File Scope&lt;/h2&gt;
        &lt;p&gt;At file scope, &lt;code&gt;extern&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt; influence the linkage of a declaration,
        according to rules that we will describe shortly.&lt;/p&gt;
        &lt;h1 id=&quot;duration&quot;&gt;Duration&lt;/h1&gt;
        &lt;p&gt;There are two kind of duration:&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;automatic&lt;/li&gt;
        &lt;li&gt;static&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;A static duration means the object associated to the declaration persists for
        the whole program execution. Automatic duration means the object is allocated
        dynamically when the declaration&amp;#39;s scope is entered.&lt;/p&gt;
        &lt;p&gt;Within functions (at block-scope), declarations without &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;
        have automatic duration. Any other declaration (at file or block-scope) has
        static duration.&lt;/p&gt;
        &lt;p&gt;Sometimes, people talk of &lt;strong&gt;lifetime&lt;/strong&gt;. Strictly speaking the duration is either
        automatic or static, while the lifetime refers to the portion of the execution
        during which memory is reserved for the object. The distinction is moot and both
        terms are often used interchangeably.&lt;/p&gt;
        &lt;h1 id=&quot;linkage&quot;&gt;Linkage&lt;/h1&gt;
        &lt;p&gt;Remember that linkage is what determines if multiple declarations of the same
        object refer to the same object (i.e., memory location), or to separate ones.&lt;/p&gt;
        &lt;p&gt;There are three kind of linkage:&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;no linkage&lt;/li&gt;
        &lt;li&gt;internal linkage&lt;/li&gt;
        &lt;li&gt;external linkage&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;A declaration with no linkage is associated to an object that is not shared with
        any other declaration.&lt;/p&gt;
        &lt;p&gt;In a single compilation unit, all declarations for the same object that have
        linkage (so not &amp;quot;no linkage&amp;quot;) must have the same linkage (either internal or
        external).&lt;/p&gt;
        &lt;p&gt;Within the compilation unit, all declarations with internal linkage for the same
        identifier refer to the same object.&lt;/p&gt;
        &lt;p&gt;Within the whole program, all declarations with external linkage for the same
        identifier refer to the same object.&lt;/p&gt;
        &lt;p&gt;Of course, all declarations for the same object must agree on its type!&lt;/p&gt;
        &lt;p&gt;All declarations with no linkage happen at block-scope: all block-scope
        declarations without the &lt;code&gt;extern&lt;/code&gt; storage class specifier have no linkage.&lt;/p&gt;
        &lt;p&gt;For all other objects in the compilation units, the object has internal linkage
        if there is a declaration with the &lt;code&gt;static&lt;/code&gt; storage class specifier. This
        declaration must happen before any &lt;code&gt;extern&lt;/code&gt; declaration, and there cannot be any
        declaration without storage class specifier (or a compilation error ensues).
        Otherwise, it has external linkage.&lt;/p&gt;
        &lt;h1 id=&quot;declarations-definitions&quot;&gt;Declarations &amp;amp; Definitions&lt;/h1&gt;
        &lt;p&gt;&lt;a name=&quot;declarations_and_definitions&quot;&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;p&gt;All declarations with no linkage are also definitions.&lt;/p&gt;
        &lt;p&gt;Other declarations are definitions if they have an initializer. A function body
        is treated as an initializer.&lt;/p&gt;
        &lt;p&gt;A file-scope &lt;strong&gt;variable&lt;/strong&gt; declaration without the &lt;code&gt;extern&lt;/code&gt; storage class
        specifier or initializer is a tentative definition.&lt;/p&gt;
        &lt;p&gt;Note that &lt;code&gt;extern&lt;/code&gt; declarations can have an initializer; although it makes no
        sense to do that (since dropping the &lt;code&gt;extern&lt;/code&gt; specifier preserves the behaviour
        and makes and clarifies intent). Some compiler warn if you try to specify both
        &lt;code&gt;extern&lt;/code&gt; and an initializer.&lt;/p&gt;
        &lt;p&gt;For a declared object to be defined, there must be at least one definition or
        tentative definition, and not more than one non-tentative definition.&lt;/p&gt;
        &lt;p&gt;The object for a variable defined without initializer is initialized to 0 (its
        memory is zeroed).&lt;/p&gt;
        &lt;p&gt;Why does this matter? To be able to use a declared object, there must be a
        definition. Second, these rules ensure that an object isn&amp;#39;t initialized
        multiple times.&lt;/p&gt;
        &lt;h1 id=&quot;const&quot;&gt;Const&lt;/h1&gt;
        &lt;p&gt;A small note about the &lt;code&gt;const&lt;/code&gt; qualifier (not the same thing as a storage class
        specifier). Using &lt;code&gt;const&lt;/code&gt; does not influence scope, duration or linkage in C. In
        C++ however, declaration with &lt;code&gt;const&lt;/code&gt; at the &amp;quot;top-level&amp;quot; (the outermost pointer,
        or the whole variable if there&amp;#39;s no pointer) have internal linkage by default.&lt;/p&gt;
        &lt;p&gt;The reason C++ does this is to enable more optimizations: if the address of the
        variable is not taken, then memory does not need to be allocated for it and its
        value can be inlined in the assembly code.&lt;/p&gt;
        &lt;h1 id=&quot;storage-class-specifiers-summary&quot;&gt;Storage Class Specifiers Summary&lt;/h1&gt;
        &lt;p&gt;Here&amp;#39;s a short summary of which storage class specifiers are valid in which part
        of a program, and what difference they make compared to omitting the
        storage class specifier. As we said earlier, there can be at most one storage
        class specifier by declaration.&lt;/p&gt;
        &lt;p&gt;Storage class specifiers valid for block-scope variable declarations:&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;none: automatic duration, no linkage&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;auto&lt;/code&gt; (never required)&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;register&lt;/code&gt; (compiler hint)&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;static&lt;/code&gt; (static duration)&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;extern&lt;/code&gt; (static duration; copy previous linkage)&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;Storage class specifiers valid for parameter declarations:&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;none: automatic duration, no linkage&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;register&lt;/code&gt; (compiler hint)&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;Storage class specifiers valid for file-scope variable declarations:&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;none: static duration, external linkage&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;extern&lt;/code&gt; (copy previous linkage, else external linkage)&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;static&lt;/code&gt; (internal linkage)&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;Storage class specifiers valid for file-scope function declarations:&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;none: static duration; copy previous linkage, else external linkage&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;extern&lt;/code&gt; (same as none)&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;static&lt;/code&gt; (internal linkage)&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;Storage class specifiers valid for block-scope function declarations (useless):&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;none: static duration; copy previous linkage, else external linkage&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;extern&lt;/code&gt; (same as none)&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;Finally, note that the &lt;code&gt;extern&lt;/code&gt; storage class specifier prevents a declaration
        from being a tentative definition.&lt;/p&gt;
        &lt;h1 id=&quot;summary&quot;&gt;Summary&lt;/h1&gt;
        &lt;p&gt;So in summary, each declaration has:&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;a scope: block, function, function prototype, or file&lt;/li&gt;
        &lt;li&gt;a duration: automatic or static&lt;/li&gt;
        &lt;li&gt;linkage: no linkage, internal linkage, or external linkage&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;Refer to the &lt;a href=&quot;#intro&quot;&gt;intro&lt;/a&gt; for a short definition of these three concepts.&lt;/p&gt;
        &lt;p&gt;One can determine the linkage and duration of any declaration using only three
        rules (most prioritary rule first):&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;&lt;p&gt;Within functions, declarations without &lt;code&gt;extern&lt;/code&gt; have no linkage.&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;p&gt;Within functions, declarations without &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; have automatic
        duration. Any other declaration, at any scope, has static duration.&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;p&gt;Within a compilation unit, objects have internal linkage if there is a
        declaration with the &lt;code&gt;static&lt;/code&gt; storage class specifier. This declaration must
        happen before any &lt;code&gt;extern&lt;/code&gt; declaration, and there cannot be any declaration
        without storage class specifier (or a compilation error ensues). Otherwise,
        they have external linkage.&lt;/p&gt;
        &lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;Finally, for a variable to be defined there should be exactly one declaration
        with an initializer; or, failing that, at least one declaration without
        &lt;code&gt;extern&lt;/code&gt;.&lt;/p&gt;
        &lt;h1 id=&quot;if-we-could-do-it-over-&quot;&gt;If we could do it over...&lt;/h1&gt;
        &lt;p&gt;Perhaps the most obvious flaw of the scheme is that &lt;code&gt;static&lt;/code&gt; at file scope bears
        no relationship with &lt;code&gt;static&lt;/code&gt; at block scope. One of the two should have a
        different name.&lt;/p&gt;
        &lt;p&gt;Second, the interplay of &lt;code&gt;extern&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt; (at file-scope), and no specifier
        (at file-scope) is too complex.&lt;/p&gt;
        &lt;p&gt;We could describe the behaviour of &lt;code&gt;extern&lt;/code&gt; as follows:&lt;/p&gt;
        &lt;pre&gt;&lt;code&gt;if (first declaration for same object was static)
            static linkage
        else
            external linkage
        &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;While no-specifier (at file-scope) means:&lt;/p&gt;
        &lt;pre&gt;&lt;code&gt;if (object is a function
                &amp;amp;&amp;amp; first declaration for same object was static)
            static linkage
        else
            external linkage
        &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The reason for making the lack of a specifier act like &lt;code&gt;extern&lt;/code&gt; for functions is
        that functions don&amp;#39;t have tentative definitions.&lt;/p&gt;
        &lt;p&gt;Why do we even need tentative definitions? The only advantage I see is that one
        can declare a variable only in a header file and get a definition for it. The
        gain in convenience is so small that I&amp;#39;d propose to get rid of it.&lt;/p&gt;
        &lt;p&gt;At that point, we don&amp;#39;t need &amp;quot;no specifier&amp;quot; anymore, and can force all of our
        declarations to be either &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;. Let&amp;#39;s pick one as the default.
        &lt;code&gt;static&lt;/code&gt; seems better suited, since it does not pollute the namespace of other
        compilation units: other compilation units can still declare an object with the
        same identifier and external linkage.&lt;/p&gt;
        &lt;p&gt;Let&amp;#39;s also get rid of the fact that &lt;code&gt;extern&lt;/code&gt; &amp;quot;copies&amp;quot; the previous linkage. I
        can see no case where it would be necessary.&lt;/p&gt;
        &lt;p&gt;The scheme ends up simple enough: only add &lt;code&gt;extern&lt;/code&gt; to declarations of symbol
        one wants to export or import to/from other compilation units. If we were not
        bound by the fact that C uses header files that are generally included both in
        the exporting and importing compilation unit, we could even split &lt;code&gt;extern&lt;/code&gt; into
        &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;public&lt;/code&gt; to make things clearer.&lt;/p&gt;
        &lt;h1 id=&quot;clarifying-intent&quot;&gt;Clarifying Intent&lt;/h1&gt;
        &lt;p&gt;Since many of us are stuck with C, here are a few macros and guidelines on how
        to use them to make things clearer. It roughly follows the scheme proposed in
        the last section, except that we can&amp;#39;t make &lt;code&gt;static&lt;/code&gt; the default, or statically
        check that the scheme is used properly.&lt;/p&gt;
        &lt;ul&gt;
        &lt;li&gt;&lt;code&gt;#define import extern&lt;/code&gt; - for declarations in header files &amp;amp; declarations in C
        files to be imported from other compilation units&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;#define public&lt;/code&gt; - for declaratons in C files to be exported to other
        compilation units&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;#define private static&lt;/code&gt; - for declarations in C files local to the
        compilation unit&lt;/li&gt;
        &lt;li&gt;&lt;code&gt;#define local   static&lt;/code&gt; - for block-scope variables that should persist
        accross function invocations&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;All file-scope declarations should be qualified by one of &lt;code&gt;import&lt;/code&gt;, &lt;code&gt;public&lt;/code&gt; or
        &lt;code&gt;private&lt;/code&gt;. Within a compilation unit, all declarations for an object should have
        the same specifier. The only exception is that for a single object there can be
        one declaration with &lt;code&gt;import&lt;/code&gt; in the header file, and one with &lt;code&gt;public&lt;/code&gt; in the C
        file. Block-scope declarations can use &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;local&lt;/code&gt;.&lt;/p&gt;
        &lt;h1 id=&quot;sources&quot;&gt;Sources&lt;/h1&gt;
        &lt;ul&gt;
        &lt;li&gt;&lt;a href=&quot;http://publications.gbdirect.co.uk/c_book/chapter8/declarations_and_definitions.html&quot;&gt;The C Book, Chapter 8&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf&quot;&gt;The C Standard (*)&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;Experimentations with GCC and MSVC&lt;/li&gt;
        &lt;/ul&gt;
        &lt;p&gt;(*) This is for C11, but these things haven&amp;#39;t changed in a long time.&lt;/p&gt;
      </description>
      <pubDate>2015-01-25T23:00:00.000Z</pubDate>
      <link>http://norswap.com/c_scope_duration_linkage</link>
      <guid isPermaLink="true">http://norswap.com/c_scope_duration_linkage</guid>
    </item>
  </channel>
</rss>
