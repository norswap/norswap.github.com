<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>norswap</title>
    <description></description>      
    <link>http://norswap.com/</link>
    <atom:link href="http://norswap.com/atom.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>The Most Useful Kotlin Function</title>
      <description>
&lt;p&gt;Two years ago, I wrote a posted called &lt;a href=&quot;/java_caster&quot;&gt;The Most Useful Java Function&lt;/a&gt;.
This was rather tongue-in-cheek, as the function in question lets you cast from
a type to another, inferring the target type and suppressing unchecked cast
exceptions.&lt;/p&gt;
&lt;p&gt;Nevertheless, it is useful remarkably often.&lt;/p&gt;
&lt;p&gt;With Kotlin however, you can step up your game to a whole new level.
Introducing &lt;code&gt;proclaim&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-kotlin&quot;&gt;val list: Collection&amp;lt;Int&amp;gt; = ArrayList(list(1, 2, 3))
proclaim(list as ArrayList&amp;lt;Int&amp;gt;)
val x = list[0] // works
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The trick here is actually not &lt;code&gt;proclaim&lt;/code&gt;. It&amp;#39;s the fact that Kotlin has &amp;quot;smart
casts&amp;quot; which are essentially a form of flow typing.&lt;/p&gt;
&lt;p&gt;The type inferencer reasons out that if the cast &lt;code&gt;list as ArrayList&amp;lt;Int&amp;gt;&lt;/code&gt;
succeeds, then it means that &lt;code&gt;list&lt;/code&gt; is indeed an &lt;code&gt;ArrayList&amp;lt;Int&amp;gt;&lt;/code&gt;. And since
&lt;code&gt;list&lt;/code&gt; is a &lt;code&gt;val&lt;/code&gt;, its value can&amp;#39;t change. So in the rest of the body where the
cast appears, list is &amp;quot;smart-casted&amp;quot; to &lt;code&gt;ArrayList&amp;lt;Int&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here is a possible definition for &lt;code&gt;proclaim&lt;/code&gt; (0 run-time overhead besides the
cast):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-kotlin&quot;&gt;@Suppress(&amp;quot;UNUSED_PARAMETER&amp;quot;, &amp;quot;NOTHING_TO_INLINE&amp;quot;)
inline fun proclaim (cast: Any)
    = Unit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&amp;#39;s get the obvious out of the way: of course this can be misused.&lt;/p&gt;
&lt;p&gt;On the other hand, just like the casting function, it is handy surprisingly
often. Type systems just aren&amp;#39;t powerful enough to be able to figure some things
we know to be true in our code. Especially that of Java and Kotlin.&lt;/p&gt;
&lt;p&gt;I&amp;#39;m not giving any examples: by their nature they would be short and easily
rewritten to accomodate the type system. But if you genuinely want to know, you
can search the net for &amp;quot;(path-)dependent types&amp;quot; use case or examples. Keep in
mind that&amp;#39;s just a subset of what we can&amp;#39;t express in Java/Kotlin though.&lt;/p&gt;
      </description>
      <pubDate>2017-03-19T23:00:00.000Z</pubDate>
      <link>http://norswap.com/kotlin-proclaim</link>
      <guid isPermaLink="true">http://norswap.com/kotlin-proclaim</guid>
    </item>
    <item>
      <title>Thread-Local Properties in Kotlin</title>
      <description>
&lt;p&gt;The &lt;a href=&quot;https://kotlinlang.org/&quot;&gt;Kotlin&lt;/a&gt; language has a feature called &lt;a href=&quot;https://kotlinlang.org/docs/reference/delegated-properties.html&quot;&gt;Delegated Properties&lt;/a&gt;. It basically
lets you delegate a getter (and optionally a setter) to an object that
implements the &lt;code&gt;getValue&lt;/code&gt; (and optionally the &lt;code&gt;setValue&lt;/code&gt;) method.&lt;/p&gt;
&lt;p&gt;I haven&amp;#39;t had much use of the feature, but I just found something very nifty
that could be done with it: create thread-local properties.&lt;/p&gt;
&lt;p&gt;Here&amp;#39;s an example of what you can do:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-kotlin&quot;&gt;import norswap.utils.thread_local.*

class Test
{
    val _i = ThreadLocal.withInitial { 0 }
    val i by _i

    val j by thread_local(0)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This creates two counters, &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; that are backed by instances of
&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html&quot;&gt;&lt;code&gt;ThreadLocal&amp;lt;Int&amp;gt;&lt;/code&gt;&lt;/a&gt;. In the first case we specify the instance explicitly,
while in the second case the &lt;code&gt;ThreadLocal&lt;/code&gt; instance is created implicitly, given
a default value (0 here).&lt;/p&gt;
&lt;p&gt;And now for the implementation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-kotlin&quot;&gt;package norswap.utils.thread_local
import kotlin.properties.ReadWriteProperty
import kotlin.reflect.KProperty

class ThreadLocalDelegate&amp;lt;T&amp;gt; (val local: ThreadLocal&amp;lt;T&amp;gt;)
: ReadWriteProperty&amp;lt;Any, T&amp;gt;
{
    companion object {
        fun &amp;lt;T&amp;gt; late_init ()
            = ThreadLocalDelegate&amp;lt;T&amp;gt;(ThreadLocal())
    }

    constructor (initial: T):
        this(ThreadLocal.withInitial { initial })

    constructor (initial: () -&amp;gt; T):
        this(ThreadLocal.withInitial(initial))

    override fun getValue
            (thisRef: Any, property: KProperty&amp;lt;*&amp;gt;): T
        = local.get()

    override fun setValue
            (thisRef: Any, property: KProperty&amp;lt;*&amp;gt;, value: T)
        = local.set(value)
}

typealias thread_local&amp;lt;T&amp;gt; = ThreadLocalDelegate&amp;lt;T&amp;gt;

operator fun &amp;lt;T&amp;gt; ThreadLocal&amp;lt;T&amp;gt;.provideDelegate
        (self: Any, prop: KProperty&amp;lt;*&amp;gt;)
    = ThreadLocalDelegate(this)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&amp;#39;s do a quick rundown. The &lt;code&gt;ThreadLocalDelegate&lt;/code&gt; class does what it says on
the tin: it delegates all attempts to read or write the property to the
&lt;code&gt;ThreadLocal&lt;/code&gt; instance.&lt;/p&gt;
&lt;p&gt;What is more interesting is the different ways you can instantiate the delegate:
you can pass it a &lt;code&gt;ThreadLocal&lt;/code&gt; instance (primary constructor), an initial
value, or a function that computes the initial value. The companion object also
has a function &lt;code&gt;late_init()&lt;/code&gt; that lets you create a delegate with no initial
value.&lt;/p&gt;
&lt;p&gt;Now we could use &lt;code&gt;ThreadLocalDelegate&lt;/code&gt; like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-kotlin&quot;&gt;val num by ThreadLocalDelegate(0)
val str by ThreadLocalDelegate&amp;lt;String&amp;gt;.late_init()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But that&amp;#39;s quite a mouthful, so there is a typealias &lt;code&gt;thread_local&lt;/code&gt; to make
things look nicer.&lt;/p&gt;
&lt;p&gt;Finally, the &lt;code&gt;provideDelegate&lt;/code&gt; operator function tells Kotlin how to create a
delegate from a &lt;code&gt;ThreadLocal&lt;/code&gt; instance. That&amp;#39;s how we could do &lt;code&gt;val i by _i&lt;/code&gt; at
the top of the post.&lt;/p&gt;
&lt;p&gt;Aaand that&amp;#39;s pretty much it for today :)&lt;/p&gt;
      </description>
      <pubDate>2017-03-18T23:00:00.000Z</pubDate>
      <link>http://norswap.com/kotlin-threadlocal-properties</link>
      <guid isPermaLink="true">http://norswap.com/kotlin-threadlocal-properties</guid>
    </item>
    <item>
      <title>Prolog Served DRY</title>
      <description>
&lt;p&gt;I believe there should be more programming books targetted at experienced
programmers. In particular, it seems like most books about programming
languages go to great lengths to be accessible to beginners.&lt;/p&gt;
&lt;p&gt;But this is actually detrimental to the experience of the experienced
programmer, who either wants to get up and running with the language as fast as
possible, or to understand what makes the language tick.&lt;/p&gt;
&lt;p&gt;Most of the time, I&amp;#39;m firmly in the second category: I want the mental models
and implentation details underlying the language. Those are of paramount
importance to reach proficiency with the language, yet they are rarely taught
explicitly.&lt;/p&gt;
&lt;p&gt;At the start of this year, I actually was in a position to do something about
this, as I needed to design the lab sessions for our Programming Language
Paradigms course. While the (master) students are not exactly &lt;em&gt;experienced&lt;/em&gt; in
the traditional sense, they already have at least 3 languages under their belts
and are quite capable of handling what we throw at them.&lt;/p&gt;
&lt;p&gt;The first language we cover is Prolog. There are three lab sessions on the topic
and I have now made them available &lt;a href=&quot;https://github.com/norswap/prolog-dry&quot;&gt;on Github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you&amp;#39;re interested in Prolog, give them a spin. You might find them
interesting, maybe not all that easy, and – I hope – enlightening.&lt;/p&gt;
      </description>
      <pubDate>2017-03-13T23:00:00.000Z</pubDate>
      <link>http://norswap.com/prolog-served-dry</link>
      <guid isPermaLink="true">http://norswap.com/prolog-served-dry</guid>
    </item>
    <item>
      <title>Patterns of Software: Highlights</title>
      <description>
&lt;p&gt;Last month, I finished reading the book Patterns of Software by Richard Gabriel
(available for free &lt;a href=&quot;https://www.dreamsongs.com/Files/PatternsOfSoftware.pdf&quot;&gt;here [pdf]&lt;/a&gt;). It&amp;#39;s a very interesting read, and I
recommend it to everyone who cares about the craft of writing software.&lt;/p&gt;
&lt;p&gt;I didn&amp;#39;t really know what to expect going into the book. The first part explains
architect Scott Alexanders&amp;#39; vision of patterns and pattern languages, and makes
a parallel with programming. It&amp;#39;s miles away from the &lt;a href=&quot;https://en.wikipedia.org/wiki/Design_Patterns&quot;&gt;gang of four&lt;/a&gt;, which is
just as well. The second part speaks about Gabriel&amp;#39;s own personal experiences. I
didn&amp;#39;t expect that, but it was nevertheless captivating. The book ends with an
expanded version of Gabriel&amp;#39;s &lt;a href=&quot;https://www.dreamsongs.com/RiseOfWorseIsBetter.html&quot;&gt;Worse is Better&lt;/a&gt; thesis.&lt;/p&gt;
&lt;p&gt;Below, I highlight some of my take-aways from the book. Most of the excerpts
come from the first part of the book and from the final chapter.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;reuse-vs-compression&quot;&gt;Reuse vs Compression&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Object-orientation promotes reuse through inheritance, but that is most
properly called compression: the logic is not encapsulated but interspersed.
It&amp;#39;s still there, but now it&amp;#39;s implicit. True reuse would be using library
functions. Compression is easier than true reuse because you don&amp;#39;t have to
think the interface as carefully.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!------&gt;
&lt;blockquote&gt;
&lt;p&gt;Compression is the characteristic of a piece of text that the meaning of any
part of it is “larger” than that particular piece has by itself. This
characteristic is created by a rich context, with each part of the text
drawing on that context—each word draws part of its meaning from its
surroundings.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!------&gt;
&lt;blockquote&gt;
&lt;p&gt;Such webs are examples of compression: The meaning of an expression written in
the context of the web is determined by the contents of the entire web. If you
need to change another part of the web, your compressed expression might
change its meaning, what it does, or even whether it works at all. So when we
build our tight inheritance hierarchy in object-oriented fashion—weblike or
pyramid style — we might be falling into this trap.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;habitability-and-piecemeal-growth&quot;&gt;Habitability and Piecemeal Growth&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;It&amp;#39;s more important for code to be habitable than clear or beautiful.
Habitable means it can be extended easily and that new people can get to run
with the code easily. Perfect clarity is intimidating: it&amp;#39;s hard to improve.
If everything is interlocked too tightly, with no overhang on which to hang
extension, the program will be hard to extend, even though it is arguably
perfect. Abstraction is over-valued because a completed program full of the
right abstractions is beautiful. But most programs are by definition never
completed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!------&gt;
&lt;blockquote&gt;
&lt;p&gt;Habitability is the characteristic of source code that enables programmers,
coders, bug-fixers, and people coming to the code later in its life to
understand its construction and intentions, and to change it comfortably and
confidently.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!------&gt;
&lt;blockquote&gt;
&lt;p&gt;Piecemeal growth is the process of design and implementation in which software
is embellished, modified, reduced, enlarged, and improved through a process of
repair rather than of replacement.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;pattern-languages&quot;&gt;Pattern Languages&lt;/h3&gt;
&lt;p&gt;According to Gabriel, pattern languages failed in (brick and mortar)
architecture because in addition to having the right process, you have to be an
artist, to manipulate the language artistically.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;symmetries&quot;&gt;Symmetries&lt;/h3&gt;
&lt;p&gt;The book discusses symmetries in the context of rug-weaving, but it think the
notion can apply to software as well. Code with local symmetry is easier to
read. Repeating patterns are pleasant, and many instantiation of the same
principles can make a codebase more familiar.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;language-design-adoption&quot;&gt;Language Design &amp;amp; Adoption&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Aesthetic principles and design goals don’t excite me, because often they have
nothing to do with how people really program (habitability and piecemeal
growth) but more often reflecting mathematical or abstract considerations and
look-Ma-no-hands single-mechanism trickery. One cannot deny, however, that a
small set of principles and goals applied to designing a small language
usually results in a consistent concise language.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!------&gt;
&lt;blockquote&gt;
&lt;p&gt;Languages are accepted and evolve by a social process, not a technical or technological one.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A language is minimally acceptable if it solves a new problem or make certain
tasks easier.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Early adopters are trying to hit a home run with new technology to make the
career moves or corporate improvements they crave.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;productivity-impact&quot;&gt;Productivity &amp;amp; Impact&lt;/h3&gt;
&lt;p&gt;Gabriel recount the story of the Borland Quattro Pro for Windows, who was
tremendously productive.&lt;/p&gt;
&lt;p&gt;One of the most peculiar things this team did was having multi-hours meeting
each day to gvie overview of changes and define the interfaces.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A manager should be like the sweeper in curling: The sweeper runs ahead of the
stone and sweeps away debris from the path of the stone so that the progress
of the stone will be smooth and undisturbed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!------&gt;
&lt;blockquote&gt;
&lt;p&gt;An isolated good success can be better than a string of mediocre successes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;poetry&quot;&gt;Poetry&lt;/h3&gt;
&lt;p&gt;Reading poetry is a good way to appreciate good fiction writing, and to become
better at writing in general.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;First, modern and contemporary poetry is about compression: Say as much in as
few words as possible. Poets avoid adjectives, adverbs, gerunds, and
complicated clausal structure. Their goal is to get the point across as fast
as they can, with the fewest words, and generally with the constraint of
maintaining an easily spoken verbal rhythm.&lt;/p&gt;
&lt;p&gt;Second, poets say old things in new ways. When you read good poetry, you will
be amazed at the insights you get by seeing a compressed expression presenting
a new way of looking at things.&lt;/p&gt;
&lt;p&gt;Third, poets love language and write sentences in ways you could never
imagine. I don’t mean that their sentences are absurd or unusual—rather, the
sentences demonstrate the poet’s keen interest in minimally stating a complex
image or point.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;software-development-models&quot;&gt;Software Development Models&lt;/h3&gt;
&lt;p&gt;Richard Gabriel is well known for his famous essay on &lt;a href=&quot;https://www.dreamsongs.com/RiseOfWorseIsBetter.html&quot;&gt;Worse is Better&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;Worse is Better&lt;/em&gt; model is explained in the book, but Gabriel expands on how
the model is highly market-efficient.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It takes less development time, so it is out early and can be adopted as the
de facto standard in a new market area.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!------&gt;
&lt;blockquote&gt;
&lt;p&gt;If it has some value, it will be ported or adopted and will tend to spread
like a virus. If it has value and becomes popular, there will be pressure to
improve it, and over time it will acquire the quality and feature-richness of
systems designed another way, but with the added advantage that the features
will be those the customers or users want, not those that the developers think
they should want.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!------&gt;
&lt;blockquote&gt;
&lt;p&gt;Worse-is-better takes advantage of the natural advantages of incremental
development. Incremental improvement satisfies some human needs. When
something is an incremental change over something else already learned,
learning the new thing is easier and therefore more likely to be adopted than
is something with a lot of changes. To some it might seem that there is value
to users in adding lots of features, but there is, in fact, more value in
adding a simple, small piece of technology with evolvable value.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!------&gt;
&lt;blockquote&gt;
&lt;p&gt;One of the key characteristics of the mainstream customer is conservatism.
Such a customer does not want to take risks; he (let’s say) doesn’t want to
debug your product; he doesn’t want to hit a home run so he can move up the
corporate ladder. Rather, he wants known, predictable improvement over what he
is doing today with his own practices and products. He wants to talk to other
folks like himself and hear a good story. He doesn’t want to hear how someone
bet it all and won; he wants to hear how someone bought the product expecting
10% improvement and got 11%. This customer is not interested in standing out
from the crowd, particularly because of a terrible error in his organization
based on a bad buying decision.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!------&gt;
&lt;blockquote&gt;
&lt;p&gt;The ideal of the free market supports this kind of growth. If you decide to
spend a lot of resources developing a radical innovation product, you may be
throwing away development money. Why bet millions of dollars all at once on
something that could flop when you can spend a fraction, test the ideas,
improve the ideas based on customer feedback, and spend the remainder of money
on the winning evolution of the technology? If you win, you will win more,
and, if you lose, you will lose less. Moreover, you will be out there ahead of
competition which is happily making the right-thing mistake.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!------&gt;
&lt;blockquote&gt;
&lt;p&gt;When you put out small incremental releases, you can do it more frequently
than you can with large releases, and you can charge money for each of those
releases. With careful planning you can charge more for a set of improvements
released incrementally than the market would have borne had you released them
all at once, taking a risk on their acceptance to boot. Moreover, when you
release many small improvements, you have less risk of having a recall, and
managing the release process also is easier and cheaper. With incremental
improvement, the lifetime of an idea can be stretched out, and so you don’t
have to keep coming up with new ideas. Besides, who wants to base one’s
economic success on the ability to come up with new ideas all the time?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Sounds familiar?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The ideal situation is that your proprietary value is small compared with the
total size of your product, which perhaps can be constructed from standard
parts by either you or your customers or partners.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!------&gt;
&lt;blockquote&gt;
&lt;p&gt;Wade’s Maxim: No one ever made money by typing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!------&gt;
&lt;blockquote&gt;
&lt;p&gt;What this means in our context is that you cannot try to build too large and
complex product by yourself—you need to get parts from other places if your
product is complex, and you must make your value clear and apparent, and it
must be a simple decision for a customer to use your technology.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;epilogue&quot;&gt;Epilogue&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;In software engineering—if there really be such a thing—we have worked
thoroughly on Firmness, some during the last 10 years on Commodity, and none
on Delight.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Clearly that has changed some. But have we gone far enough?&lt;/p&gt;
      </description>
      <pubDate>2017-03-12T23:00:00.000Z</pubDate>
      <link>http://norswap.com/patterns-of-software</link>
      <guid isPermaLink="true">http://norswap.com/patterns-of-software</guid>
    </item>
    <item>
      <title>Ruby&#39;s Lookups &amp; Scopes</title>
      <description>
&lt;p&gt;This is the third and last article in the &lt;a href=&quot;/ruby-dark-corners&quot;&gt;Ruby&amp;#39;s Dark Corners&lt;/a&gt; series.&lt;/p&gt;
&lt;h2 id=&quot;lookups-in-ruby&quot;&gt;Lookups in Ruby&lt;/h2&gt;
&lt;p&gt;The great difficulty in Ruby is knowing what names refer
to. &lt;a href=&quot;/ruby-module-linearization&quot;&gt;Linearization&lt;/a&gt; showed us that knowing which method gets
called is non-trivial. Unfortunately it&amp;#39;s only part of the story.&lt;/p&gt;
&lt;p&gt;In Ruby, names can refer to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;methods: &lt;code&gt;x.name&lt;/code&gt; or &lt;code&gt;name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;local variables: &lt;code&gt;name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;class variables: &lt;code&gt;@@name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;global variables: &lt;code&gt;$name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;constants: &lt;code&gt;NAME&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;modules: &lt;code&gt;Name&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We also would like to know on which module methods are defined. By the way,
since &lt;code&gt;Class &amp;lt; Module&lt;/code&gt;, when we say &lt;em&gt;modules&lt;/em&gt; we mean &lt;em&gt;modules and classes&lt;/em&gt;,
unless otherwise specified.&lt;/p&gt;
&lt;p&gt;There are five big concepts involved with these lookups (and then some fun
sprinkled on top):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;self&lt;/strong&gt;: what does &lt;code&gt;self&lt;/code&gt; refer to?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;definee&lt;/strong&gt;: if a method definition appears, on which class is it defined?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;scoping&lt;/strong&gt;: knowing which constructs create new scope for local variables and
which don&amp;#39;t&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;nesting&lt;/strong&gt;: what are the surrounding modules? (often called &lt;em&gt;cref&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let&amp;#39;s look at how each type of name is resolved.&lt;/p&gt;
&lt;h2 id=&quot;local-global-variables&quot;&gt;Local &amp;amp; Global Variables&lt;/h2&gt;
&lt;p&gt;Global variables are prefixed with &lt;code&gt;$&lt;/code&gt; and they are easy: they are accessible
everywhere.&lt;/p&gt;
&lt;p&gt;Local variables depend on static scopes. New scopes are create when you enter a
new method or module body, or when you enter a method call&amp;#39;s block. Control flow
statements do not create scopes!&lt;/p&gt;
&lt;p&gt;Only scopes created by blocks inherit their parent&amp;#39;s scope. Scope created by
methods and modules are completely isolated from their parent&amp;#39;s scope. It is
sometimes said that &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;def&lt;/code&gt; are &lt;em&gt;scope gates&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;x = 1
module Foo
  p x # NameError
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is however a trick you can use:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;x = 1
Foo = Module.new do
  p x # ok
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is possible to make local variables survive their lexical scope:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;def foo
  x = 0
  [lambda { x += 1 }, lambda { p x }]
end
x, y = foo
x.call()
y.call() # 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Something else that is peculiar: a variable is &amp;quot;in scope&amp;quot; in an assignment to it
has appeared before in the current scope.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;p x # NameError
x = 1
# but
x = 1 if false
p x # nil
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Reflection can help with local variables too: the &lt;code&gt;binding&lt;/code&gt; method (both
&lt;code&gt;Kernel#binding&lt;/code&gt; and &lt;code&gt;Proc#binding&lt;/code&gt;) returns a &lt;code&gt;Binding&lt;/code&gt; object which describes
the local variables in scope.&lt;/p&gt;
&lt;h2 id=&quot;instance-variables&quot;&gt;Instance Variables&lt;/h2&gt;
&lt;p&gt;Instance variables are prefixed by &lt;code&gt;@&lt;/code&gt;. They are &lt;strong&gt;always&lt;/strong&gt; looked up on &lt;code&gt;self&lt;/code&gt;.
If an instance variable doesn&amp;#39;t exists (it has never been assigned), it
evaluates to &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note that this means that instance variables are effectively instance-private:
an instance of &lt;code&gt;X&lt;/code&gt; cannot access the instance variables of another instance of
&lt;code&gt;X&lt;/code&gt;. This is more restrictive than &lt;code&gt;private&lt;/code&gt; in Java for instance. However, it&amp;#39;s
easy to use reflection to side-step this with
&lt;code&gt;Object#instance_variable_get/set&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;class-variables&quot;&gt;Class Variables&lt;/h2&gt;
&lt;p&gt;Class variables are prefixed with &lt;code&gt;@@&lt;/code&gt;. They are defined on modules, and can be
accessed both in module bodies and in method bodies. Strangely, they can also be
accessed in the meta-class of a module (and its meta-meta-class, etc).&lt;/p&gt;
&lt;p&gt;If a module inherits multiple version of a class variable, it&amp;#39;s always the first
inherited version that wins (so the first &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt; or &lt;code&gt;preprend&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;You can list the class variables &amp;quot;owned&amp;quot; by a module with
&lt;code&gt;Module#class_variables(false)&lt;/code&gt; (&lt;code&gt;false&lt;/code&gt; says not to include class inherited
class variables). Interestingly, class variables can &amp;quot;migrate&amp;quot;: if the module is
a class that has a class variable &lt;code&gt;@@a&lt;/code&gt;, and that &lt;code&gt;@@a&lt;/code&gt; becomes defined on one
of its ancestor, the class variable will disappear from the class. This will not
happen for non-class modules however.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;class T; @@a = &amp;#39;t&amp;#39;; end
class Object; @@a = &amp;#39;o&amp;#39;; end
class T
  p @@a # o
  p class_variables(false) # []
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If a class variable is accessed before it has been assigned, a &lt;code&gt;NameError&lt;/code&gt;
occurs.&lt;/p&gt;
&lt;p&gt;Final catch, class variables can only be accessed inside the body of a class
that inherits/includes the class defining the variables. This means you can&amp;#39;t
use the &lt;code&gt;@@x&lt;/code&gt; notation with the &lt;code&gt;eval&lt;/code&gt; method that we will see later. However,
you can use reflection: &lt;code&gt;Module#class_variable_get/set&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;constants-and-modules-&quot;&gt;Constants (and Modules)&lt;/h2&gt;
&lt;p&gt;Constants start with an uppercase letter, and modules are actually a kind of
constant.&lt;/p&gt;
&lt;p&gt;Constants depend on the notion of &lt;code&gt;nesting&lt;/code&gt;: you can access a constant if it is
declared inside a module body that is around you, or in one of the ancestors of
the current module (but &lt;strong&gt;not&lt;/strong&gt; in an ancestor of a surrounding module!). You
can also use &lt;code&gt;::&lt;/code&gt; to navigate through modules:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;X = 0
module A
  X = 1
  p ::X # 0
  module B; module C; Y = 2; end; end
  module D
    p X # 1
    p B::C::Y
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following exemple illustrates two gotchas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You don&amp;#39;t have access to constants defined in an ancestor of a surrounding
module.&lt;/li&gt;
&lt;li&gt;Constants in surrounding modules take precedence over constants in ancestors.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;module A; X = &amp;#39;a&amp;#39;; end
module B; Y = &amp;#39;b&amp;#39;; end
module C
  include A
  p X # ok
  Y = &amp;#39;c&amp;#39;
  module D
    include B
    p Y # &amp;#39;c&amp;#39;!
    p X # NameError
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The module body really has to be around you:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;module A::B::C; p Y; end # ok (Y defined in C)
module A::D; p X; end # NameError (X defined in A)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can access the current nesting with &lt;code&gt;Module::nesting&lt;/code&gt; and clarify the
example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;module A
  module D; p Module.nesting; end # [A, A::D]
end
module A::D; p Module.nesting; end # [A::D]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, if you try to access a constant before it has been assigned, a
&lt;code&gt;NameError&lt;/code&gt; ensues. &lt;code&gt;Module::constants&lt;/code&gt; will list the constants defined at the
point of call, while &lt;code&gt;Module#constants&lt;/code&gt; will list the constants defined by the
module (and optionally by its ancestors, depending on the argument).&lt;/p&gt;
&lt;h2 id=&quot;methods&quot;&gt;Methods&lt;/h2&gt;
&lt;p&gt;Methods are looked up on the receiver (the thing before the dot). If there is no
receiver, &lt;code&gt;self&lt;/code&gt; is assumed. Then it&amp;#39;s just a matter to perform the lookup
according to &lt;a href=&quot;/ruby-module-linearization&quot;&gt;linearization&lt;/a&gt;. &lt;code&gt;self&lt;/code&gt; may also have a meta-class which has
priority on all other ancestors.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Refinements&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;However, there is another subtlety, called &lt;em&gt;refinements&lt;/em&gt;. In Ruby, it is common
to use &lt;em&gt;monkey patching&lt;/em&gt; to open a class and add and redefine methods. However,
if every library starts doing this, you can end up with nasty conflicts.
Refinements were introduced as a solution to this problem.&lt;/p&gt;
&lt;p&gt;Refinements can only be defined in non-class modules, and only classes can be refined:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;class C
  def foo; &amp;#39;foo&amp;#39;; end
end

module M
  refine C do
    def foo; &amp;#39;bar&amp;#39;; end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Defining a refinement does nothing by itself. You have to use the &lt;code&gt;Module#using&lt;/code&gt;
function to enable some refinements in the current module:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;module N
  p C.new.foo # &amp;#39;foo&amp;#39;
  using M
  p C.new.foo # &amp;#39;bar&amp;#39;
end
p C.new.foo # &amp;#39;foo&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;using&lt;/code&gt; statements are somewhat peculiar, because they are strictly lexical in
scope. Said otherwise, the introduced refinements have the same visibility as
constants, &lt;strong&gt;excepted&lt;/strong&gt; that the &lt;code&gt;using&lt;/code&gt; is not inherited (via sublassing or
include):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;class A; using M; end
class B &amp;lt; A
  p C.new.foo # &amp;#39;foo&amp;#39;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, refinements themselves are inherited:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;module O
  include M
end
module P
  using O
  p C.new.foo # &amp;#39;bar&amp;#39;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;How prioritary are refinements? Refinements always take priority over everything
else. What if multiple refinements conflicts? The latest innermost &lt;code&gt;using&lt;/code&gt; statement
always wins.&lt;/p&gt;
&lt;p&gt;You can get a list of modules whose refinements are visible with
&lt;code&gt;Module::used_modules&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;on-which-module-are-methods-defined-&quot;&gt;On which module are methods defined?&lt;/h2&gt;
&lt;p&gt;Last, but not least, when you use the &lt;code&gt;def&lt;/code&gt; keyword, on which module are the
methods defined? The not-so-helpful answer is that these methods become instance
methods of &lt;em&gt;the definee&lt;/em&gt;. Entering certain declarations and calling certain
functions change the definee, as we&amp;#39;ll see in the next section.&lt;/p&gt;
&lt;h2 id=&quot;how-self-and-the-definee-change&quot;&gt;How &lt;code&gt;self&lt;/code&gt; and the definee change&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;where&lt;/th&gt;
&lt;th&gt;self&lt;/th&gt;
&lt;th&gt;definee&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;top-level (file or REPL)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;main&lt;/code&gt; (an instance of &lt;code&gt;Object&lt;/code&gt;)&lt;/td&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in a module&lt;/td&gt;
&lt;td&gt;module&lt;/td&gt;
&lt;td&gt;module&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in &lt;code&gt;class &amp;lt;&amp;lt; X&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;metaclass of &lt;code&gt;X&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;metaclass of &lt;code&gt;X&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in a &lt;code&gt;def method&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;receiver&lt;/td&gt;
&lt;td&gt;surrounding module&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;in a &lt;code&gt;def X.method&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;receiver (&lt;code&gt;X&lt;/code&gt;)&lt;/td&gt;
&lt;td&gt;metaclass of &lt;code&gt;X&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X.instance_eval&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;receiver (&lt;code&gt;X&lt;/code&gt;)&lt;/td&gt;
&lt;td&gt;metaclass of &lt;code&gt;X&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X.class_eval&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;receiver (&lt;code&gt;X&lt;/code&gt;, a module)&lt;/td&gt;
&lt;td&gt;receiver (&lt;code&gt;X&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Also note that &lt;code&gt;Module#module_eval&lt;/code&gt; is an alias for &lt;code&gt;Module#class_eval&lt;/code&gt;. There
are also variants called &lt;code&gt;class/module/instance_exec&lt;/code&gt;, which do the same thing
as the &lt;code&gt;eval&lt;/code&gt; version but allow passing additional arguments to the block
(useful to make instance variables accessible to the block). This is &lt;strong&gt;the
only&lt;/strong&gt; difference between the &lt;code&gt;exec&lt;/code&gt; and &lt;code&gt;eval&lt;/code&gt; family, despite the
documentation seeming to hint at some bizarre lookup behaviour.&lt;/p&gt;
&lt;p&gt;Note that for the two &lt;code&gt;def&lt;/code&gt; rows, the definee is both the module on which the
method itself is being defined, and the definee for nested method definitions.&lt;/p&gt;
&lt;p&gt;At first, it may seem that &lt;code&gt;class/module_eval&lt;/code&gt; does the same as a &lt;code&gt;module&lt;/code&gt; or
&lt;code&gt;class&lt;/code&gt; block. However, you cannot open a class inside a method, so &lt;code&gt;class_eval&lt;/code&gt;
helps in you need to evaluate something in the context of a class as part of a
method. Note however that it is possible to open metaclasses in a method through
&lt;code&gt;class &amp;lt;&amp;lt; X&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There are also string-based &lt;code&gt;eval&lt;/code&gt; based. But things are complex enough as it
is, if you can avoid to go there, please do.&lt;/p&gt;
&lt;p&gt;Finally, if you experiment, you may find out you cannot define singleton method
on the classes &lt;code&gt;Integer&lt;/code&gt; and &lt;code&gt;Symbol&lt;/code&gt; (e.g. &lt;code&gt;def Integer.foo&lt;/code&gt;). I assume for
performance reasons.&lt;/p&gt;
&lt;h2 id=&quot;doing-better-&quot;&gt;Doing Better?&lt;/h2&gt;
&lt;p&gt;The situation is a bit hairy, to say the least. How could we simplify things?&lt;/p&gt;
&lt;p&gt;Once you wrap your head around them, globals, class and instance variables are
rather simple. One caveat: I would allow accessing class variables whenever
&lt;code&gt;self&lt;/code&gt; is the class, removing an exception with little benefit.&lt;/p&gt;
&lt;p&gt;Regarding local variables, it&amp;#39;s not quite obvious why scope gates are needed.
Maybe because they would encourage people to use class-local variables instead
of class variables? It doesn&amp;#39;t really hurt, but adds yet another thing to
remember to the language.&lt;/p&gt;
&lt;p&gt;Constants lookup is puzzling. My take is that constants should be looked up
first in the ancestors then in the surrounding module and its ancestors, etc.
That would be much less surprising. I don&amp;#39;t see &lt;strong&gt;any&lt;/strong&gt; reason to do things in
the current way (surrounding modules take precedence over the ancestors).&lt;/p&gt;
&lt;p&gt;I think a useful heuristic is to preserve the ability to move code vertically.
Code that is well-defined in a class should have the same meaning in a subclass
or in a superclass, unless some symbols are overridden in the class. Surrounding
modules should not affect such code.&lt;/p&gt;
&lt;p&gt;Refinements blatantly violate the heuristic above. I can appreciate why: the
idea was to to restrict monkey patching to a well-defined blob of code, and
inheriting &lt;code&gt;using&lt;/code&gt; statements goes against that by forcing monkey patching on
sub-classes. On the other hand, I think it goes against the principle of least
surprise by violating my heuristic above.&lt;/p&gt;
&lt;p&gt;Another reason refinements are awkward is that they introduce not one, but two
new forms of lookup: &lt;code&gt;using&lt;/code&gt; statements and refinement definitions (&lt;code&gt;refine&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;I believe it was a mistake to overload modules with another role as &amp;quot;refinement
container&amp;quot;. It would probably have been better to merge &lt;code&gt;using&lt;/code&gt; into &lt;code&gt;refine&lt;/code&gt;:
make all refinements active as soon as defined, and combine them through
inheritance (using the ancestor chain).&lt;/p&gt;
&lt;p&gt;If it was really desirable to refine a method only within a superclass but not
within its subclasses, the &lt;code&gt;private&lt;/code&gt; function could have been reused. This would
have made refinement lookups similar to method lookup, and would have surprised
no-one.&lt;/p&gt;
&lt;p&gt;There is a big problem with this idea: dynamically looking up refinement is
expensive: you now need to walk two ancestor chains instead of one for every
lookup. A simple countermeasure: forbid adding new refinements dynamically,
which is already the case in the current version.&lt;/p&gt;
&lt;p&gt;Finally, I would allow opening classes and modules in methods, and allow any
expression in place of the class name. This would remove the need for
&lt;code&gt;class_eval&lt;/code&gt; method. If needed one can add the restriction that only existing
classes and modules can be opened in methods.&lt;/p&gt;
&lt;p&gt;I would also remove &lt;code&gt;instance_eval&lt;/code&gt;, however it has no immediate analog. I would
retool the &lt;code&gt;class &amp;lt;&amp;lt; X&lt;/code&gt; notation for this purpose. The metaclass can still be
accessed through &lt;code&gt;Object#singleton_class&lt;/code&gt;. This field can be used in conjunction
with &lt;code&gt;class&lt;/code&gt; so that &lt;code&gt;class X.singleton_class&lt;/code&gt; achieves the previous effect of
&lt;code&gt;class &amp;lt;&amp;lt; X&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So in summary:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Allow class variables to be used anywhere where &lt;code&gt;self&lt;/code&gt; is the class.&lt;/li&gt;
&lt;li&gt;Abolish scope gates?&lt;/li&gt;
&lt;li&gt;Lookup constants first in the ancestors, then in the surround class and their
ancestors.&lt;/li&gt;
&lt;li&gt;Merge &lt;code&gt;using&lt;/code&gt; into &lt;code&gt;refine&lt;/code&gt;, and make this new kind of refinement inheritable,
except when qualified with &lt;code&gt;private&lt;/code&gt;. Forbid dynamically adding refinements to
avoid dynamic refinement lookup.&lt;/li&gt;
&lt;li&gt;Remove the &lt;code&gt;instance_eval&lt;/code&gt; and &lt;code&gt;class_eval&lt;/code&gt; methods; allow opening classes in
methods; and make &lt;code&gt;class &amp;lt;&amp;lt; X&lt;/code&gt; take the meaning of &lt;code&gt;X.instance_eval&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Add a &lt;code&gt;metaclass&lt;/code&gt; field to class &lt;code&gt;Object&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Of course, it&amp;#39;s too late for Ruby. But for a language inspired by Ruby, these
points are worth considering.&lt;/p&gt;
      </description>
      <pubDate>2017-03-05T23:00:00.000Z</pubDate>
      <link>http://norswap.com/ruby-lookups-scopes</link>
      <guid isPermaLink="true">http://norswap.com/ruby-lookups-scopes</guid>
    </item>
    <item>
      <title>Morning Winds</title>
      <description>
&lt;p&gt;And now, for something &lt;strong&gt;completely&lt;/strong&gt; different.&lt;/p&gt;
&lt;p&gt;I&amp;#39;ve started taking part in a forum-based role-play game based on the universe
of Game of Thrones. If you&amp;#39;re interested, it happens &lt;a href=&quot;http://s4.zetaboards.com/A_Game_of_Thrones&quot;&gt;over here&lt;/a&gt; (warning: 90s
web design).&lt;/p&gt;
&lt;p&gt;As part of that, I made an RP post to introduce the character I&amp;#39;ll be playing,
the somber Lord Nyron Gaunt. Some very biased people told me it was good. I&amp;#39;m
not under any such illusion, yet here it is for the records:&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Like every morning, Lord Nyron Gaunt stood atop his battlements to take in the
fresh morning air. A faint drizzle was falling, making his face and the surface
of his clothes slightly wet.&lt;/p&gt;
&lt;p&gt;Nyron liked the weather. Most men despised it, he had noticed. They complained
about it much more than they would about a heavy downpour. Like if the gods had
decided to take a piss on what would otherwise be a perfectly good day.&lt;/p&gt;
&lt;p&gt;It was sixteen years ago on this day that he became lord of Honorton. A bitter
memory, that. His father, murdered; and the culprit known almost beyond doubts.
And yet, justice had been sorely lacking on that day. Instead, Nyron had
brokered an uneasy truce. It had been necessary, he knew.&lt;/p&gt;
&lt;p&gt;Lucan had been howling for blood, of course. That was the worse of it, to hear
his heart echo in the words and wails of his younger brother; but, in the end,
to do nothing.&lt;/p&gt;
&lt;p&gt;It had been the right decision. He knew it back then, and knew it even now. It
still left a bad taste in his mouth.&lt;/p&gt;
&lt;p&gt;Sixteen years of strife. It had been hard. He hadn&amp;#39;t expected to trade his
leisurely hunts and the comforts of a good book for the burden of command so
soon. He always had had his head on his shoulder however, so he made do.&lt;/p&gt;
&lt;p&gt;Fortunately he had his wife, and their children. They were the sun rays in the
unending drizzle of his existence. Them, and his people, whom he had worked so
hard to protect. A good people.&lt;/p&gt;
&lt;p&gt;Nyron Gaunt was no fool. He knew there was nothing magical in the seed of the
men living in the plains around Honorton. Nothing inborn that made them better
than other men. But he thought — hoped — that he and his predecessors had put
something in their minds. Inspired them, somehow, by their example. A bit like
when you took good care of a plant or a flower, it grew and bloomed.&lt;/p&gt;
&lt;p&gt;His people were plants. That made Nyron Gaunt chuckle.&lt;/p&gt;
&lt;p&gt;Sixteen years of strife. And not much to show for it, truth be told. At least,
there was peace now. He would not have his sons waste their youth like he had,
warring and angling and currying favors.&lt;/p&gt;
&lt;p&gt;There was peace now, and there would continue to be peace. He would make sure of
it. He was not about to let his hard work undone by some fools.&lt;/p&gt;
&lt;p&gt;Nyron sighed heavily. Then he turned around, and got back to work.&lt;/p&gt;
      </description>
      <pubDate>2017-02-27T23:00:00.000Z</pubDate>
      <link>http://norswap.com/morning-winds</link>
      <guid isPermaLink="true">http://norswap.com/morning-winds</guid>
    </item>
    <item>
      <title>Unconstraining</title>
      <description>
&lt;blockquote&gt;
&lt;p&gt;You believe that you are your mind. This is the delusion. The instrument has taken you over.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- --&gt;
&lt;blockquote&gt;
&lt;p&gt;The more you are identified with your mind, the more you suffer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- --&gt;
&lt;blockquote&gt;
&lt;p&gt;There is one thing we can actually control—the mind-set with which we respond
to the events around us.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- --&gt;
&lt;blockquote&gt;
&lt;p&gt;It is the purpose of the training to allow people to see that the
circumstances of their lives and that their attitudes about the circumstances
of their lives exist in a context or a system of knowing, and that it is
possible to have exactly the same circumstances and attitudes about these
circumstances held in a different context, and that, as a matter of fact, it
is possible for people to choose their own context for the contents of their
lives.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- --&gt;
&lt;blockquote&gt;
&lt;p&gt;They no longer are their point of view. They have one, and know that the one
they have is the one they chose, until now, and that they can, and probably
will, choose to create other points of view. They experience, that is, that
they are the one who defines the point of view, and not the reverse. They
experience the intended result of the training, which is a shift in what
orients people&amp;#39;s being from the attempt to gain satisfaction - a deficiency
orientation - to the expression of satisfaction already being experienced - a
sufficiency orientation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- --&gt;
&lt;blockquote&gt;
&lt;p&gt;Each time we try to prove we are not fools we reinforce the belief that we must
prove that we are not.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- --&gt;
&lt;blockquote&gt;
&lt;p&gt;And yet, the experience of responsibility for one&amp;#39;s own experience is the
awareness that I am the source of my experience. It is absolutely inseparable
from the experience of satisfaction.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- --&gt;
&lt;blockquote&gt;
&lt;p&gt;When you first start learning, early in life, there is a bottleneck in the
amount of information you have access to. You soak up everything like a sponge,
because you are open and there is relatively little to absorb.&lt;/p&gt;
&lt;p&gt;But very quickly, in elementary school, your access to information stops being
the limiting factor. You take home a few giant textbooks, and suddenly the
bottleneck moves to ways of structuring and contextualizing the information.&lt;/p&gt;
&lt;p&gt;In high school, you learn a variety of methods to structure
information — outlines, diagrams, underlining and highlighting, reports, essays,
notebooks and binders. The bottleneck moves to your ability to synthesize this
information, to turn it into new ideas.&lt;/p&gt;
&lt;p&gt;In college, if you make it that far, the bottleneck moves to insight generation.
You start questioning the world as given, and find that the juiciest
intellectual rewards are ideas that shift how you view it. You start hunting for
the revolutionary, the controversial, steering your learning toward the red
pills of paradoxes and contradictions.&lt;/p&gt;
&lt;p&gt;If you are lucky enough to go beyond this, the bottleneck moves once again: to
your assumptions. They constrain your view, what you are allowed to see, and
thereby the thoughts and actions available to you. You start getting a kick out
of unearthing new assumptions, shining a light on blindspots that, by
definition, you didn’t know you didn’t know about. This process is unbounded,
because with enough examination, all your beliefs are revealed to be
assumptions.&lt;/p&gt;
&lt;p&gt;There are many ways to reveal assumptions. Interesting experiences, traveling,
genuine conversation, and reading fiction all help you question your own point
of view.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- --&gt;
&lt;blockquote&gt;
&lt;p&gt;The interesting thing about constraints is that they are never on you. They
are constraints on your context, shaping the space of possibilities you allow
yourself to consider.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Sources: Eckhart Tolle, Robert Greene, Werner Erhard, Tiago Forte&lt;/p&gt;
&lt;p&gt;Warning: Greene and Erhard require a hefty pinch of salt.&lt;/p&gt;
&lt;p&gt;For a practical roadmap to unconstraining,
read &lt;a href=&quot;https://medium.com/praxis-blog/&quot;&gt;Tiago Forte&lt;/a&gt;.&lt;/p&gt;
      </description>
      <pubDate>2017-02-27T23:00:00.000Z</pubDate>
      <link>http://norswap.com/unconstraining</link>
      <guid isPermaLink="true">http://norswap.com/unconstraining</guid>
    </item>
    <item>
      <title>Ruby Module Linearization</title>
      <description>
&lt;p&gt;This is the second article in the &lt;a href=&quot;/ruby-dark-corners&quot;&gt;Ruby&amp;#39;s Dark Corners&lt;/a&gt; series.&lt;/p&gt;
&lt;h2 id=&quot;mixin-modules&quot;&gt;Mixin Modules&lt;/h2&gt;
&lt;p&gt;In Ruby, classes can only inherit from a single class. However they can
&lt;em&gt;include&lt;/em&gt; multiple modules.&lt;/p&gt;
&lt;p&gt;A class that includes a module will be able to use the methods defined in the
modules. A class doesn&amp;#39;t really &amp;quot;inherit instance variables&amp;quot;. Instance variables
must not be declared, they exist just by virtue of being accessed. This means
that if a class and its superclass (or an included module) both access a
variable &lt;code&gt;@x&lt;/code&gt;, they will access the same variable.&lt;/p&gt;
&lt;p&gt;This is because of &lt;em&gt;late binding&lt;/em&gt; (aka &lt;em&gt;dynamic dispatch&lt;/em&gt;): both instance
variables and methods will be looked up from &lt;em&gt;self&lt;/em&gt; at run-time.&lt;/p&gt;
&lt;p&gt;While here is only a single copy of each instance variable, there could be
multiple method declarations with the same name. How does Ruby select which one
to use?&lt;/p&gt;
&lt;p&gt;The answer is a process called &lt;em&gt;linearization&lt;/em&gt;, which defines how Ruby orders
all the (transitively) inherited classes and included modules. You can inspect
this ordering through the &lt;code&gt;Module#ancestors&lt;/code&gt; method. For instance try
&lt;code&gt;Integer.ancestors&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;More than lookup, linearization also controls the behaviour of calls to super
methods through &lt;code&gt;super()&lt;/code&gt;. Ruby reorganizes all modules and classes into a
single inheritance chain (the &lt;em&gt;ancestor chain&lt;/em&gt;) and consecutive calls to
&lt;code&gt;super()&lt;/code&gt; move up this chain.&lt;/p&gt;
&lt;h2 id=&quot;confusing-examples&quot;&gt;Confusing Examples&lt;/h2&gt;
&lt;p&gt;But how does linearization work, exactly?&lt;/p&gt;
&lt;p&gt;Here are a couple scenarios, what do you think the behaviour for each of this
scenario is? Each is tailored to show something about the linearization process.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;# Scenario 1

module A1; end
module B1; end
module C1
  include A1
  include B1
end

# C1.ancestors    =&amp;gt; [C1, B1, A1]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;# Scenario 2

module A2; end
module B2; end
module C2
  include A2
end
module D2
  include B2
end
module E2
  include C2
  include D2
end

# E2.ancestors    =&amp;gt; [E2, D2, B2, C2, A2]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;# Scenario 3

module A3; end
module C3
  include A3
end
module D3
  include A3
end
module E3
  include C3
  include D3
end

# E3.ancestors    =&amp;gt; [E3, D3, C3, A3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So far, so good.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;# Scenario 4

module A4; end
module B4; end
module F4; end
module C4
  include B4
  include A4
end
module D4
  include F4
  include A4
end
module E4
  include C4
  include D4
end

# E4.ancestors    =&amp;gt; [E4, D4, C4, A4, F4, B4]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;# Scenario 5

module A5; end
module B5; end
module C5
  include B5
  include A5
end
module D5
  include A5
  include B5
end
module E5
  include C5
  include D5
end

# E5.ancestors    =&amp;gt; [E5, D5, C5, A5, B5]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pretty surprising, isn&amp;#39;t it?&lt;/p&gt;
&lt;p&gt;Two things further complicate the situation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;prepend&lt;/code&gt; function is a variant of &lt;code&gt;include&lt;/code&gt; with a slightly different
behaviour.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;include A, B&lt;/code&gt; is the same as &lt;code&gt;include B; include A&lt;/code&gt;. Yep.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;the-algorithm&quot;&gt;The Algorithm&lt;/h2&gt;
&lt;p&gt;The linearization algorithm is very hard to describe precisely with a few
sentences, so I&amp;#39;ll just serve you the code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;Include = Struct.new :mod
Prepend = Struct.new :mod

# Returns the ancestry chain of `mod`, given the environment `env`.
#
# No distinctions are made between classes and modules: where a class extends
# another class, that class is treated as the first included module.
#
# params:
# - mod: Symbol
#   Represents a module.
# - env: Map&amp;lt;Symbol, Array&amp;lt;Include|Prepend&amp;gt;&amp;gt;
#   Maps modules to inclusions, in order of apperance.

def ancestors (mod, env)
  chain = [mod]
  includes = env[mod]
  includes.each { |it| insert(mod, it, env, chain) }
  chain
end


def insert (mod, inclusion, env, chain)
  i = inclusion.is_a?(Prepend) ? 0 : 1
  ancestors(inclusion.mod, env).each do |it|
    raise ArgumentError(&amp;#39;cyclic include detected&amp;#39;) if it == mod
    j = chain.find_index it
    if not j.nil?
      i = j + 1 if j &amp;gt;= i
      next
    end
    chain.insert(i, it)
    i += 1
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;intuition&quot;&gt;Intuition&lt;/h3&gt;
&lt;p&gt;Let&amp;#39;s try to get some intuition in there. Let&amp;#39;s start with some observations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If B is included after A, B take precedence over A.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If B extends or includes A, B takes precedences over A.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;When including a module X, the algorithm tries to maintain the ordering
of the ancestor chain of X.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If there is a conflict of ordering, the algorithm always favors the
ordering of modules that were included earlier.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The last point highlight the most unintuitive thing about the algorithm: modules
included later take precedence, but when considering conflicts of ordering, it&amp;#39;s
modules included earlier that win!&lt;/p&gt;
&lt;p&gt;The reason is that in Ruby, we may include a module in another at any time. Ruby
never reorders modules in the ancestor chain, but has no problem inserting
modules in between existing modules. This does make sense, but leads to puzzling
linearization behaviour.&lt;/p&gt;
&lt;p&gt;Making module included earlier take precedence would solve the problem. However
when we include a module in another at runtime, we usually would like it to take
precedence on previously included modules!&lt;/p&gt;
&lt;h3 id=&quot;inheritance-vs-inclusion&quot;&gt;Inheritance vs Inclusion&lt;/h3&gt;
&lt;p&gt;As mentionned in the comment, there is no difference between inheritance and
inclusion with regards to linearization. An inherited class is treated as though
it was the first included module.&lt;/p&gt;
&lt;h3 id=&quot;merging-ancestor-chains&quot;&gt;Merging Ancestor Chains&lt;/h3&gt;
&lt;p&gt;If you look at the algorithm, you will see that it is a recursive process: to
include a module, you need to acquire its ancestor chain, then merge it with the
current ancestor chain of the includer.&lt;/p&gt;
&lt;p&gt;The way this is done — for regular includes — is to start just after the class
then insert the modules one by one. We only diverge from this if a module is
already present in the ancestor chain. Either it is further ahead in the chain:
then we skip to that position and continue the process; or it is earlier in the
chain (signifying there is an ordering conflict between included modules) and we
remain at the current position (in both cases the module is not re-inserted).&lt;/p&gt;
&lt;h3 id=&quot;include-vs-prepend&quot;&gt;Include vs Prepend&lt;/h3&gt;
&lt;p&gt;The only difference between &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;prepend&lt;/code&gt; is that prepend will try
merging the ancestor chain of its parameter &lt;em&gt;before&lt;/em&gt; the class in the class
own&amp;#39;s ancestor chain:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;module M; end
class C; prepend M; end
C.ancestors =&amp;gt; [M, C, ...]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;doing-better-&quot;&gt;Doing Better?&lt;/h2&gt;
&lt;p&gt;Despite its idiosyncracies, I would be hard pressed to improve on the algorithm
without losing some of its nice properties. The key tension is that later calls
to &lt;code&gt;include&lt;/code&gt; should take precedence (to enable effective run-time
meta-programming), but re-ordering modules is objectively bad.&lt;/p&gt;
&lt;p&gt;If you have any idea, make sure to share them!&lt;/p&gt;
&lt;p&gt;It should also be said that, of course, scenarios such as ordering conflicts
rarely happen in practice. Most people ignore these rules and are not really
worse off because of it.&lt;/p&gt;
      </description>
      <pubDate>2017-02-22T23:00:00.000Z</pubDate>
      <link>http://norswap.com/ruby-module-linearization</link>
      <guid isPermaLink="true">http://norswap.com/ruby-module-linearization</guid>
    </item>
    <item>
      <title>Ruby Methods, Procs and Blocks</title>
      <description>
&lt;p&gt;This is the first article in the &lt;a href=&quot;/ruby-dark-corners&quot;&gt;Ruby&amp;#39;s Dark Corners&lt;/a&gt; series.&lt;/p&gt;
&lt;p&gt;Here are a few question this article will try to answer:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What combination of parameters are legal in method definition?&lt;/li&gt;
&lt;li&gt;How are arguments assigned to parameters when calling a method?&lt;/li&gt;
&lt;li&gt;What is a proc in relation with a block?&lt;/li&gt;
&lt;li&gt;What are the differences between lambdas and procs?&lt;/li&gt;
&lt;li&gt;What is the difference between &lt;code&gt;{ ... }&lt;/code&gt; and &lt;code&gt;do ... end&lt;/code&gt;?&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;declaring-parameters&quot;&gt;Declaring Parameters&lt;/h2&gt;
&lt;p&gt;In everything that follows we make the distinction between &lt;em&gt;parameters&lt;/em&gt; (or
&lt;em&gt;formal parameters&lt;/em&gt;): the parameters as they appear in method definitions; and
&lt;em&gt;arguments&lt;/em&gt; (or &lt;em&gt;actual parameters&lt;/em&gt;): the value passed to method calls.&lt;/p&gt;
&lt;p&gt;A method definition admits the following types of parameters:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;type&lt;/th&gt;
&lt;th&gt;example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;required&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;optional&lt;/td&gt;
&lt;td&gt;&lt;code&gt;b = 2&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;array decomposition&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(c, *d)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;splat&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*args&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;post-required&lt;/td&gt;
&lt;td&gt;&lt;code&gt;f&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;keyword&lt;/td&gt;
&lt;td&gt;&lt;code&gt;g:&lt;/code&gt;, &lt;code&gt;h: 7&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double splat&lt;/td&gt;
&lt;td&gt;&lt;code&gt;**kwargs&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;block&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;blk&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;A kitchen sink example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;def foo a, b = 2, *c, d, e:, f: 7, **g, &amp;amp;blk; end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here are quick explanations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Optional parameters can have a default value.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Array decomposition parameters are required parameters that decompose an array
argument into parts. Here are some examples, assuming the argument is &lt;code&gt;[[1,
2], 3]&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(*a)          a = [[1, 2], 3]
(a, b)        a = [1, 2], b = 3
(a, *b)       a = [1, 2], b = [3]
(a, b, *c)    a = [1, 2], b = 3,   c = []
((a, b), c)   a = 1,      b = 2,   c = 3
((a, *b), c)  a = 1,      b = [2], c = 3
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The splat parameter enables variable length argument lists and receives all
extra arguments.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Post-required parameters are required parameters that occur after a splat
parameter.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Keyword operators have to be named explicitly when calling the method:
&lt;code&gt;foo(f: 6)&lt;/code&gt;. They can have default values.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The double splat parameter acts like the splat parameter, but for extra
keyword arguments.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The block parameter gives a name to the block passed to the method, allowing
you to pass it to other methods, and call it by name instead of through
&lt;code&gt;yield&lt;/code&gt;. See more on blocks in the section on &lt;a href=&quot;#blocks-and-procs&quot;&gt;Blocks and Procs&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can get a list of a method&amp;#39;s parameters with &lt;code&gt;Method#parameters&lt;/code&gt;, which will
show the type of each parameter. Here it is, running over our &lt;code&gt;foo&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;method(:foo).parameters
# [[:req, :a], [:opt, :b], [:rest, :c], [:req, :d], [:keyreq, :e], [:key, :f], [:keyrest, :g], [:block, :blk]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that this glitches for array decomposition parameters, indicating just
&lt;code&gt;[:req]&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;ordering&quot;&gt;Ordering&lt;/h3&gt;
&lt;p&gt;You can&amp;#39;t mix match these parameters as you please. All types of parameters are
optional, but those that are present must respect the following ordering:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;required parameters and optional parameters&lt;/li&gt;
&lt;li&gt;splat parameter (at most one)&lt;/li&gt;
&lt;li&gt;post-required parameters&lt;/li&gt;
&lt;li&gt;keyword parameters&lt;/li&gt;
&lt;li&gt;double splat parameter (at most one)&lt;/li&gt;
&lt;li&gt;block parameter (at most one)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As a matter of best practices, you should not mix required and optional
parameters: put all required parameters first. You should also avoid
post-required parameters, and using both optional parameters and a splat
parameter. If you require default values, use keyword parameters instead.&lt;/p&gt;
&lt;p&gt;See &lt;a href=&quot;https://github.com/bbatsov/ruby-style-guide/issues/632&quot;&gt;some rationale&lt;/a&gt; for these practices.&lt;/p&gt;
&lt;h2 id=&quot;assigning-arguments-to-parameters&quot;&gt;Assigning Arguments to Parameters&lt;/h2&gt;
&lt;p&gt;The real complexity of Ruby&amp;#39;s methods is determining how arguments are mapped to
parameters.&lt;/p&gt;
&lt;p&gt;Here are the different types of arguments you can pass to a method call:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;type&lt;/th&gt;
&lt;th&gt;example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;regular&lt;/td&gt;
&lt;td&gt;&lt;code&gt;v&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;keyword&lt;/td&gt;
&lt;td&gt;&lt;code&gt;b:&lt;/code&gt;, &lt;code&gt;b: v&lt;/code&gt; or &lt;code&gt;:b =&amp;gt; v&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hash argument&lt;/td&gt;
&lt;td&gt;&lt;code&gt;v1 =&amp;gt; v2&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;splat&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*v&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double splat&lt;/td&gt;
&lt;td&gt;&lt;code&gt;**v&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;block conversion&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;v&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;block&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{ .. }&lt;/code&gt; or &lt;code&gt;do .. end&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;You can substitute &lt;code&gt;v&lt;/code&gt; (and &lt;code&gt;v1&lt;/code&gt;, &lt;code&gt;v2&lt;/code&gt;) with almost any expression, as long as
you respect operator precedence.&lt;/p&gt;
&lt;p&gt;A kitchen sink example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;foo 1, *array, 2, c: 3, &amp;quot;d&amp;quot; =&amp;gt; 4, **hash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here are quick explanations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Keyword arguments are equivalent to hash arguments whose key is a symbol. If
you are using keyword arguments with the intent to fill keyword parameters,
you should use the keyword syntax. In what follows, when we say &lt;em&gt;keyword
arguments&lt;/em&gt; we alway refer to keyword argument &lt;strong&gt;and&lt;/strong&gt; hash arguments with a
symbol key: the two are indistinguishable.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Hash arguments will be aggregated into a hash that will be assigned to one of
the method&amp;#39;s parameters. Keywords argument may or may not be added to this
hash (see below).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If the splat argument is an &lt;code&gt;Array&lt;/code&gt; or an object that supported the &lt;code&gt;to_a&lt;/code&gt;
method, it is expanded inside the method call: &lt;code&gt;foo(1, *[2, 3], 3)&lt;/code&gt; is
equivalent to &lt;code&gt;foo(1, 2, 3, 4)&lt;/code&gt;. Otherwise the splat expands to a regular
argument.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A double splat works the same, but for hashes: &lt;code&gt;foo(a: 1, **{b: 2, c: 3}, e:
4)&lt;/code&gt; is equivalent to &lt;code&gt;foo(a: 1, b: 2, c: 3, d: 4)&lt;/code&gt;. It performs implicit
conversion to &lt;code&gt;Hash&lt;/code&gt; for objects that support the &lt;code&gt;to_hash&lt;/code&gt; method. Note in
passing that by convention &lt;code&gt;to_hash&lt;/code&gt; represents implicit conversion to a
&lt;code&gt;Hash&lt;/code&gt;, while &lt;code&gt;to_h&lt;/code&gt; represents explicit (on-demand only) conversion.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A block conversion argument must be a &lt;code&gt;Proc&lt;/code&gt;, or an object that can implicitly
converted to one via &lt;code&gt;to_proc&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Finally, a method can be passed a block explicitly. The block will appear
after the argument list. We&amp;#39;ll touch on the difference between the two block
syntaxes in the &lt;a href=&quot;#blocks-and-procs&quot;&gt;section about blocks&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;ordering&quot;&gt;Ordering&lt;/h3&gt;
&lt;p&gt;Again, arguments cannot be supplied in any order. All regular and splat
arguments must appear before any keyword and double splat arguments. A block
conversion or block argument (only one allowed) must appear last.&lt;/p&gt;
&lt;p&gt;If the order is not respected, an error ensues.&lt;/p&gt;
&lt;h3 id=&quot;assigning-arguments-to-parameters&quot;&gt;Assigning Arguments to Parameters&lt;/h3&gt;
&lt;p&gt;Where an error is mentionned, it is most likely an &lt;code&gt;ArgumentError&lt;/code&gt;. I haven&amp;#39;t
re-checked everything, but it should always be the case.&lt;/p&gt;
&lt;p&gt;Here is the full procedure for figuring out how arguments are assigned to
parameters:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Expand any splat or double splat arguments. The expanded content is taken
into account when we talk about regular, keyword or hash arguments later on.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;First, we handle all keywords and hash parameters.&lt;/p&gt;
&lt;p&gt;If there is exactly one more required parameters than there are regular
arguments, all keyword and hash arguments are collected into a hash, which is
assigned to that parameter. If there were any keyword parameter, an error
ensues. If there was a double splat parameter, it is assigned an empty hash.&lt;/p&gt;
&lt;p&gt;Otherwise, if all of the following conditions hold, &lt;em&gt;implicit hash conversion&lt;/em&gt; is
performed.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;There are keyword or double splat parameters.&lt;/li&gt;
&lt;li&gt;There are no keyword or hash arguments.&lt;/li&gt;
&lt;li&gt;There are more regular arguments than required parameters.&lt;/li&gt;
&lt;li&gt;The last regular argument is a hash, or can be converted to one via
&lt;code&gt;to_hash&lt;/code&gt; and that method doesn&amp;#39;t return &lt;code&gt;nil&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Implicit hash conversion simply consists of treating all the (key, value)
pairs from the last regular argument as additional keyword or hash arguments.
These new arguments are taken into account in the rest of the assignment
procedure.&lt;/p&gt;
&lt;p&gt;We now assign keyword arguments to the corresponding keyword parameters. If a
keyword parameter without default value cannot be assigned, an error ensues.&lt;/p&gt;
&lt;p&gt;If there is double splat parameter, assign it a hash aggregating all
remaining keyword parameters.&lt;/p&gt;
&lt;p&gt;If there remains keyword or hash arguments, aggregate them in a hash, which
is to be treated as the last regular argument.&lt;/p&gt;
&lt;p&gt;Note: if two values are supplied for the same key, the last one wins and the
previous one disappears. However, if the two values are visible in the method
call (e.g. &lt;code&gt;foo(a: 1, **{a: 2})&lt;/code&gt;), a warning is emitted.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We now consider regular arguments, which by now consists of the supplied
regular arguments (including the result of splat expansion), minus the last
argument if implicit hash conversion was performed in step 2, plus a final
argument containing a hash if arguments remained in step 2.&lt;/p&gt;
&lt;p&gt;If there are less regular arguments than required parameters, an error
ensues. Otherwise, let &lt;code&gt;x&lt;/code&gt; be the number of regular arguments and &lt;code&gt;n&lt;/code&gt; the
number of required and optional parameters.&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;x &amp;lt;= n&lt;/code&gt;, the last &lt;code&gt;n-x&lt;/code&gt; optional parameters get assigned their default
values, while the remaining &lt;code&gt;x&lt;/code&gt; parameters get assigned the &lt;code&gt;x&lt;/code&gt; regular
arguments.&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;x &amp;gt; n&lt;/code&gt;, the &lt;code&gt;n&lt;/code&gt; first arguments are assigned to the &lt;code&gt;n&lt;/code&gt; parameters. The
&lt;code&gt;x-n&lt;/code&gt; remaining arguments are collected in an array, which is assigned to the
splat parameter. If there is no splat parameter, an error ensues.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If a block or block conversion argument is passed, make a proc from it and
assign it to the block parameter, if any — otherwise it becomes the implicit
block parameter.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;blocks-and-procs&quot;&gt;Blocks and Procs&lt;/h2&gt;
&lt;p&gt;The following is in general much better understood than assignment from
arguments to parameters.&lt;/p&gt;
&lt;p&gt;Procs are &lt;a href=&quot;https://en.wikipedia.org/wiki/Higher-order_function&quot;&gt;higher-order functions&lt;/a&gt;, while blocks are a syntactic
notation to pass a proc to a method. It&amp;#39;s not &lt;em&gt;quite&lt;/em&gt; that simple however. You
can pass procs as regular arguments, but the block parameter is special. All
methods can accept a block implicitly, or explicitly via a block a parameter.
This parameter must be assigned a (syntactic) block (which becomes a proc) or a
&amp;quot;regular&amp;quot; proc marked with &lt;code&gt;&amp;amp;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Other than with blocks, procs can be instantiated with &lt;code&gt;proc&lt;/code&gt;, &lt;code&gt;Proc.new&lt;/code&gt;,
&lt;code&gt;lambda&lt;/code&gt; or &lt;code&gt;-&amp;gt;&lt;/code&gt; (&lt;em&gt;lambda literal&lt;/em&gt; or &lt;em&gt;dash rocket&lt;/em&gt; or &lt;em&gt;stab operator&lt;/em&gt;). The
three first forms simply take a block argument, while the last form looks like
this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;-&amp;gt; (a, b) { ... }
-&amp;gt; (a, b) do .. end
-&amp;gt; { ... }
-&amp;gt; do .. end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When a method accepts an implicit block, you can call it with &lt;code&gt;yield&lt;/code&gt; (you can
also call the explicit block parameter with &lt;code&gt;yield&lt;/code&gt;). Somewhat peculiarly, the
&lt;code&gt;yield&lt;/code&gt; notation cannot be passed a block of its own. A proc or block parameter
named &lt;code&gt;x&lt;/code&gt; can be called using &lt;code&gt;x.call(1, 2)&lt;/code&gt;, &lt;code&gt;x.(1, 2)&lt;/code&gt; or &lt;code&gt;x[1, 2]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A less known trick is that you can also get a reference to the proc backing the
block argument by using &lt;code&gt;proc&lt;/code&gt; or &lt;code&gt;Proc.new&lt;/code&gt; (without passing them a block)
inside the method.&lt;/p&gt;
&lt;h3 id=&quot;procs-vs-lambdas&quot;&gt;Procs vs Lambdas&lt;/h3&gt;
&lt;p&gt;Lambdas are special, stricter kind of procs.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Regular procs can perform non-local control flow: if a proc uses &lt;code&gt;retry&lt;/code&gt;,
&lt;code&gt;return&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt; or &lt;code&gt;redo&lt;/code&gt;, those will be interpreted as though the
proc&amp;#39;s code had been inlined at the point where the proc was called. This can
only happen in the method in which the proc was originally defined. If called
outside the method, a proc that performs non-local control flow will cause a
&lt;code&gt;LocalJumpError&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If regular procs are passed too many arguments, the extra arguments are
ignored instead of causing an error (the behaviour is otherwise the same as
for methods, as outlined above). Lambda behave like methods for parameter
assignment.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Regular prrocs with multiple parameters can be passed a single array argument,
which will be automatically &amp;quot;splatted&amp;quot;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;proc&lt;/code&gt; and &lt;code&gt;Proc.new&lt;/code&gt; are used to create regular procs, while &lt;code&gt;lambda&lt;/code&gt; and &lt;code&gt;-&amp;gt;&lt;/code&gt;
create lambdas.&lt;/p&gt;
&lt;p&gt;It seems possible to convert between proc and lambda like this: &lt;code&gt;lambda
&amp;amp;my_proc&lt;/code&gt; or &lt;code&gt;proc &amp;amp;my_lambda&lt;/code&gt;. However, these conversions don&amp;#39;t do anything:
&lt;code&gt;lambda &amp;amp;my_proc&lt;/code&gt; returns &lt;code&gt;my_proc&lt;/code&gt;, and the regular proc behaviour is
preserved. The converse is true for the reverse conversion.&lt;/p&gt;
&lt;h3 id=&quot;curly-brackets-vs-do-end-&quot;&gt;Curly Brackets (&lt;code&gt;{}&lt;/code&gt;) vs &lt;code&gt;do .. end&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;There is no semantic difference between both forms.&lt;/p&gt;
&lt;p&gt;There is one syntactic difference because the two forms have different
precedences:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-ruby&quot;&gt;foo bar { ... }     # foo(bar { ... })
foo bar do ... end  # foo(bar) { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&amp;#39;t need to use this particularity, there are two popular ways to
choose on form over the other:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Use curlies for single-line blocks, &lt;code&gt;do ... end&lt;/code&gt; for multi-line blocks.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Use curlies when the return value is used, &lt;code&gt;do ... end&lt;/code&gt; when only the
side-effects matter.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;edits&quot;&gt;Edits&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt; (2017/02/09)&lt;/p&gt;
&lt;p&gt;Thanks to &lt;a href=&quot;https://twitter.com/eregontp&quot;&gt;Benoit Daloze&lt;/a&gt;, who pointed out many small mistakes in the article,
as well as the fact that the proper names for what I called &lt;em&gt;regular&lt;/em&gt; and
&lt;em&gt;default&lt;/em&gt; parameters were &lt;em&gt;required&lt;/em&gt; and &lt;em&gt;optional&lt;/em&gt; parameters. He also
mentionned &lt;code&gt;Method#parameters&lt;/code&gt;, and inspired me to improve the section on blocks
and procs.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2&lt;/strong&gt; (2017/02/11)&lt;/p&gt;
&lt;p&gt;Following a conversation with &lt;a href=&quot;https://twitter.com/tom_enebo&quot;&gt;Tom Enebo&lt;/a&gt; on Twitter, I realized that I forgot
to account for hash arguments with non-symbol keys! This lead to some more
investigation and the uncovering of a few errors. The assignment procedure has
been revised and is now much simpler.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3&lt;/strong&gt; (2017/03/27)&lt;/p&gt;
&lt;p&gt;Reader &lt;em&gt;A Quiet Immanence&lt;/em&gt; pointed out in the comments that a conversion between
regular proc and lambda doesn&amp;#39;t do anything, and that an array argument to a
regular proc with multiple parameters is auto-splatted.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4&lt;/strong&gt; (2017/03/27)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wspurgin&quot;&gt;Will Spurgin&lt;/a&gt; pointed out in the comments that you
can have array decomposition, splat and keyword parameters in the same method,
as long as you respect the parameter ordering.&lt;/p&gt;
      </description>
      <pubDate>2017-02-08T23:00:00.000Z</pubDate>
      <link>http://norswap.com/ruby-methods</link>
      <guid isPermaLink="true">http://norswap.com/ruby-methods</guid>
    </item>
    <item>
      <title>Ruby&#39;s Specification Problem</title>
      <description>
&lt;p&gt;I&amp;#39;m start a series of post about &lt;a href=&quot;/ruby-dark-corners&quot;&gt;Ruby&amp;#39;s Dark Corners&lt;/a&gt;. Here I
would like to talk about the reason for these posts: that despite its
popularity, Ruby is thoroughly under-documented.&lt;/p&gt;
&lt;p&gt;Here is a look at some questions I&amp;#39;m answering in my &lt;a href=&quot;/ruby-dark-corners&quot;&gt;dark corners&lt;/a&gt; series:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What combination of parameters are legal in method definition?&lt;/li&gt;
&lt;li&gt;How are arguments assigned to parameters when calling a method?&lt;/li&gt;
&lt;li&gt;How are ancestors ordered when using &lt;code&gt;include&lt;/code&gt;?&lt;/li&gt;
&lt;li&gt;How do we know what name refers to?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It looks like stuff that should be well-understood, but it isn&amp;#39;t. The &lt;a href=&quot;http://ruby-doc.org/core-2.4.0/&quot;&gt;official
documentation&lt;/a&gt; doesn&amp;#39;t cover these topics and doesn&amp;#39;t do so in enough depth.
Sometimes, it is even downright misleading. For each these topics them, I
couln&amp;#39;t find any blog article that was even remotely close from telling the
whole story.&lt;/p&gt;
&lt;p&gt;The behaviour of Ruby is very much implementation-defined. An &lt;a href=&quot;https://www.ipa.go.jp/files/000011432.pdf&quot;&gt;ISO standard&lt;/a&gt; is
available, but it covers Ruby 1.8, which is at this point rather old (the
current version is 2.4). For each of the three topics I&amp;#39;m covering, new versions
change the semantics and/or bring new details to the story. Another artifact of
importance is the &lt;a href=&quot;https://github.com/ruby/spec&quot;&gt;Ruby Spec Suite&lt;/a&gt;, a test suite that is used by alternative
implementations to verify they comply with the official implementation. A test
suite is just what it is however, I haven&amp;#39;t found it very useful as a tool to
understand how things work (e.g. try to understand linearization by reading
&lt;a href=&quot;https://github.com/ruby/spec/blob/master/language/super_spec.rb&quot;&gt;&lt;code&gt;super_spec.rb&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/ruby/spec/blob/master/core/module/include_spec.rb&quot;&gt;&lt;code&gt;include_spec.rb&lt;/code&gt;&lt;/a&gt;). Popular books like &lt;em&gt;Ruby under a
Microscope&lt;/em&gt; and &lt;em&gt;Metaprogramming in Ruby&lt;/em&gt; don&amp;#39;t have the answers either.&lt;/p&gt;
&lt;p&gt;Ultimately, there are two sources of truth: dive in the source code of &lt;a href=&quot;https://github.com/ruby/ruby&quot;&gt;MRI&lt;/a&gt;
(Matz&amp;#39; Ruby Implementation — the official implementation) or experiment with the
interpreter. I chose the later, more as a matter of fact than as a well-planned
strategy. It is entirely possible I made some mistake in the way I interpreted
the rules, but it will put you closer to the truth than anything you can find
online.&lt;/p&gt;
&lt;p&gt;As a concluding remark, I want to emphasize that I&amp;#39;m not picking on Ruby. It&amp;#39;s a
language I really like, and the situation is much the same in many other
languages. Nevertheless that&amp;#39;s not a reason to be satisfied with the status quo,
and my &lt;a href=&quot;/ruby-dark-corners&quot;&gt;Ruby&amp;#39;s Dark Corner&lt;/a&gt; series is my humble contribution to
that.&lt;/p&gt;
      </description>
      <pubDate>2017-02-08T23:00:00.000Z</pubDate>
      <link>http://norswap.com/ruby-specification-problem</link>
      <guid isPermaLink="true">http://norswap.com/ruby-specification-problem</guid>
    </item>
  </channel>
</rss>
